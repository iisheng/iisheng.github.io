<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解JVM之垃圾回收算法</title>
    <url>/2019/10/27/java-gc-algorithm/</url>
    <content><![CDATA[<h3 id="判断对象是否死亡的方法"><a href="#判断对象是否死亡的方法" class="headerlink" title="判断对象是否死亡的方法"></a>判断对象是否死亡的方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被引用。</p>
<blockquote>
<p>很难解决对象之间相互循环引用的问题。</p>
</blockquote>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列叫做“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般的Native方法）引用的对象</li>
</ul>
<a id="more"></a>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次减弱。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是指在程序中普遍存在的，类似<code>Object obj = new Object();</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后 使用<code>SoftReference</code>类来实现软引用。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后 使用<code>WeakReference</code>类来实现弱引用。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时受到一个系统通知。在JDK 1.2之后 使用<code>PhantomReference</code>类来实现虚引用。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要清除的对象，在标记完成后统一回收所有被标记的对象。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都像一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>将对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适用的收集算法。</p>
<p>在新生代中每次垃圾收集时都有大量对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代因为对象存活率高、没有额外空间对它进行分配的担保，就必须使用<strong>标记-清理</strong>或者<strong>标记-整理</strong>算法来进行回收。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>HotSpot虚拟机的垃圾收集器<br><img src="/images/hotspot-garbage-collector.png" alt></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是单线程收集器。它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>Serial收集器是使用复制垃圾回收算法的收集器。</p>
<p>Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World 、对象分配规则、回收策略等都与Serial完全一样。</p>
<h4 id="什么是并发什么是并行"><a href="#什么是并发什么是并行" class="headerlink" title="什么是并发什么是并行"></a>什么是并发什么是并行</h4><p>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>CMS等收集器关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）。</p>
<p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花费1分钟，那吞吐量就是99%。</p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRadio</code>参数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。这个收集器的主要意义在于给Client模式下的虚拟机使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>标记-整理</strong>算法。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短。CMS收集器就非常符合这类应用的需求。</p>
<p>CMS收集器使用<strong>标记-整理</strong>算法实现的。它的运作过程包括以下四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。</p>
<p>初始标记仅仅只是标记一下GC Roots能直接关联的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p>
<p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。但是它也有以下4个明显缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次Full GC的产生。</li>
<li>基于<strong>标记-清除</strong>算法实现，有可能收集结束时有大量空间碎片产生。</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。G1具有如下特点：</p>
<ul>
<li>并行与并发：G1能充分利用多CPU，来缩短Stop The World停顿时间，仍然可以通过并发的方式让Java程序继续运行。</li>
<li>分代收集：它能采用不同的方式处理新创建的对象和已经存活一段时间的对象、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：G1从整体来看是基于<strong>标记-整理</strong>算法，从局部（两个Region）上来看是基于<strong>复制</strong>算法实现的。这两种算法都不会产生空间碎片，收集后能提供规整的可用内存。</li>
<li>可预测的停顿：除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N秒。</li>
</ul>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage First的由来）。</p>
<p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用<code>Remembered Set</code>来避免全堆扫描的。G1中每个Region都有一个与之对应的<code>Remembered Set</code>，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个<code>Write Barrier</code>暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的<code>Remembered Set</code>之中。当进行内存回收时，在GC根节点的枚举范围中加入<code>Remembered Set</code>既可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计维护<code>Remembered Set</code>的操作，G1收集器的运作大概分为以下几步：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>。</p>
<p>虚拟机提供了<code>-XX:PrintGCDetails</code>这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的那种大对象就是那种很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间。</p>
<p>虚拟机提供一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配（不是所有虚拟机都支持该参数）。这样做的目的是避免在Eden区以及两个<code>Suvivor</code>区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这一点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生，并且经历过一次<code>Minor GC</code>后仍存活，并且能被<code>Suvivor</code>容纳的话，将被移动到<code>Suvivor</code>空间中，并且对象年龄设为1。对象在<code>Suvivor</code>区中没熬过一次<code>Minor GC</code>，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>
<p>对象晋升到老年代的阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到了<code>MaxTenuringThreshold</code>才能晋升老年代，如果在<code>Suvivor</code>空间中相同年龄所有对象大小的总和大于<code>Suvivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code>中要去的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<code>HandlePromotionFailure</code>设置不允许冒险，那这时也要改为进行一次 <code>Full GC</code>。</p>
<h3 id="Minor-GC和Full-GC有什么不一样？"><a href="#Minor-GC和Full-GC有什么不一样？" class="headerlink" title="Minor GC和Full GC有什么不一样？"></a>Minor GC和Full GC有什么不一样？</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>新生代GC （Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC会非常频繁，一般回收速度也比较快。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>老年代GC （Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（非绝对）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>垃圾回收算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引 底层数据结构 B+树是什么</title>
    <url>/2019/10/25/b+tree/</url>
    <content><![CDATA[<p>Innodb索引底层数据结构式B+树。所以介绍索引实现原理之前，我们来看一下什么是B+树。看B+树之前我们，要了解一下二叉查找树和平衡二叉树。</p>
<h3 id="什么是二叉查找树？"><a href="#什么是二叉查找树？" class="headerlink" title="什么是二叉查找树？"></a>什么是二叉查找树？</h3><p>二叉查找树，又叫做二叉排序树，也叫做二叉搜索树。</p>
<p>二叉查找树或者使用一颗空树；或者是具有下列性质的二叉树</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若他的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左右子树也分别为二叉搜索树。</li>
</ul>
<p>可以看出来，二叉查找树中序遍历可以得到一个关键字的有序序列。二叉查找树既拥有类似折半查找的特性，又采用了链表做存储结构，因此是动态查找表的一种适宜表示。</p>
<p>在二叉查找树上查找其关键字等于给定值结点的过程，恰是走了一条从根结点到该结点的路径的过程。所以，含有n个结点的二叉查找树夫人平均查找长度和树的形态有关。</p>
<p>当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树。<br>所以，需要对二叉查找树 进行 <strong>平衡化</strong>处理，成为二叉平衡树。</p>
<a id="more"></a>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树（Balanced Binary Tree）又称AVL树。它或者是一颗空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>
<p>如果二叉查找树是AVL树，则它的深度和logn是同数量级的。因此，它的平均查找长度也和logn同数量级。</p>
<h3 id="B-Tree平衡多路查找树"><a href="#B-Tree平衡多路查找树" class="headerlink" title="B-Tree平衡多路查找树"></a>B-Tree平衡多路查找树</h3><p>B-Tree是一种平衡的多路查找树。一颗m阶的的B-树，或为满足下列特性的m叉树：</p>
<ul>
<li>树中每个结点最多有m棵子树；</li>
<li>若根结点不是叶子结点，则至少有两棵子树；</li>
<li>除根之外的所有非终端结点至少有【m/2】棵子树；</li>
<li>所有非终端结点中包含信息数据；</li>
<li>所有叶子结点都出现在同一层次上，并且不带信息。</li>
</ul>
<p>由B-树定义可知，在B-树上进行查找的过程和二叉查找树的查找类似。B-树查找包含两种基本操作：</p>
<ul>
<li>在B-树中找结点；</li>
<li>在结点中找关键字。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是应文件系统所需而出的一种B-树的变形树。一棵m阶的B+树和m阶的B-树的差异在于：</p>
<ul>
<li>有n棵子树的结点中含有n个关键字。</li>
<li>所有叶子结点中包含了全部关键字的信息，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有非终端结点可以看成是索引部分，结点中仅含有其子树中的最大（或最小）关键字。</li>
</ul>
<p>B+树上的查找类似B-树。只是在查找时，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。</p>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之Java类加载机制</title>
    <url>/2019/10/23/java-class-load-mechanism/</url>
    <content><![CDATA[<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>任何一个Class文件都对应着唯一一个类或者接口的定义信息</p>
<ul>
<li>魔数：确定这个文件是否是一个能被虚拟机接受的Class文件</li>
<li>版本号：低版本不能执行高版本Class文件，高版本可以执行低版本</li>
<li>常量池：Class文件中的资源仓库</li>
<li>访问标志：用于识别一些类或者接口层次的访问信息</li>
<li>类索引、父类索引、索引集合：确定类的继承关系</li>
<li>字段表：用于描述接口或者类中声明的变量</li>
<li>方法表：用于描述方法上声明的变量</li>
<li>属性表：Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息</li>
</ul>
<a id="more"></a>
<h4 id="常量池详细介绍"><a href="#常量池详细介绍" class="headerlink" title="常量池详细介绍"></a>常量池详细介绍</h4><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。<strong>这个容量计数是从1开始的</strong>，第0项位置是用来表达<strong>不引用任何一个常量池项目</strong>的含义。</p>
<p>常量池主要存放两大类常量，字面量（Literal）和符号引用（Symbolic References）。字面量比较接近Java语言层面常量的概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的元限定名（Full Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法名称和描述符</li>
</ul>
<p>在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个证明周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机会完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<p>验证阶段大致会完成以下4个阶段的检验动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>首先，这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>其次，这里所说的初始值，通常情况是数据类型的零值。</p>
<p>相对的，有一些特殊情况：如果类字段的字段属性表中存在<code>ConstantValue</code>，那在准备阶段变量就会初始化为<code>ConstantValue</code>属性所指的值。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h5 id="符合引用（Symbolic-References）"><a href="#符合引用（Symbolic-References）" class="headerlink" title="符合引用（Symbolic References）"></a>符合引用（Symbolic References）</h5><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</p>
<h5 id="直接引用（Direct-References）"><a href="#直接引用（Direct-References）" class="headerlink" title="直接引用（Direct References）"></a>直接引用（Direct References）</h5><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>是类加载过程的最后一步。在准备阶段，变量已经赋过一次系统要求的初始值。而在初始化阶段，则根据程序员的代码去初始化类变量和其他资源。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++实现，是虚拟机自身的一部分；另一种就是所有其他类加载器，这些类加载器都是由Java实现的，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>从Java开发人员的角度，类加载器可以分为以下三种：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器负责将<code>JAVA_HOME/lib</code>类库加载到虚拟机内存中。</li>
<li>扩展类加载器：（Extension ClassLoader）:它负责加载<code>JAVA_HOME/lib/ext</code>类库加载到虚拟机内存中。</li>
<li>应用程序类加载器（Application ClassLoader）:它负责加载用户类路径上所指定的类库。</li>
</ul>
<h4 id="双亲委派模型工作过程："><a href="#双亲委派模型工作过程：" class="headerlink" title="双亲委派模型工作过程："></a>双亲委派模型工作过程：</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求派给父类加载器去完成，每一层的加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h4 id="双亲委派模型优点："><a href="#双亲委派模型优点：" class="headerlink" title="双亲委派模型优点："></a>双亲委派模型优点：</h4><p>Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如<code>java.lang.Object</code>，无论哪一个类加载器要加载这个类，最终都会委派给处于模型最顶端的启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之Java内存区域</title>
    <url>/2019/10/22/java-memory-area/</url>
    <content><![CDATA[<h3 id="JVM-内存区域模型"><a href="#JVM-内存区域模型" class="headerlink" title="JVM 内存区域模型"></a>JVM 内存区域模型</h3><p>JVM 内存区域基本上由4个区域组成：</p>
<ul>
<li>类加载器：在JVM启动时或者类运行时，将需要的class加载到JVM中。</li>
<li>运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块。</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。</li>
<li>本地方法调用：执行C/C++实现的本地方法的代码，并返回结果。</li>
</ul>
<p><img src="/images/jvm-composition.png" alt></p>
<a id="more"></a>
<h3 id="Java-运行时数据区域"><a href="#Java-运行时数据区域" class="headerlink" title="Java 运行时数据区域"></a>Java 运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
<h4 id="元数据（方法区）"><a href="#元数据（方法区）" class="headerlink" title="元数据（方法区）"></a>元数据（方法区）</h4><p>各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是元数据的一部分，用于存放编译器生成的各种字面量和符号引用。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时数据的一部分。JDK1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存的限制。也可能导致<code>OutOfMemoryError</code>出现。</p>
<h3 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot虚拟机对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。</p>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>并不是必然存在，仅仅起着占位符的作用。</p>
<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>Java对象需要通过栈上的reference数据来操作堆上的具体对象。对象的具体访问方式取决于虚拟机的实现。主流的访问方式有使用句柄和直接指针两种。</p>
<h4 id="使用句柄访问对象"><a href="#使用句柄访问对象" class="headerlink" title="使用句柄访问对象"></a>使用句柄访问对象</h4><p><img src="/images/handle-visit-object.png" alt></p>
<h4 id="使用直接指针访问对象"><a href="#使用直接指针访问对象" class="headerlink" title="使用直接指针访问对象"></a>使用直接指针访问对象</h4><p><img src="/images/direct-pointer-visit-object.png" alt></p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p><strong>栈帧</strong>是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接（dynamic linking）、方法返回值和异常分派（dispatch exception）。</p>
<p>栈帧随着方法调用而创建，随着方法结束而销毁。栈帧的存储空间<br>由创建它的线程分配在Java虚拟机栈之中。每一个栈帧都有一个本地变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>每个栈帧内部都包含一组称为局部变量表的变量列表。</p>
<p>一个局部变量表可以保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress的数据，两个局部变量可以保存一个类型为long或double的数据。</p>
<p>局部变量使用索引来进行定位访问，首个局部变量的索引值为0。</p>
<p>Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用类方法时，它的参数将会依次传递到局部变量表中从0开始的连续位置上。当调用实例对象方法时，第0个局部变量一定会用来存储该实例方法所在对象的引用（即this关键字）。后续的其他参数将会传递至局部变量表中从1开始的连续位置上。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每个栈帧内部包含一个称为<strong>操作数栈</strong>的后进先出栈。</p>
<p>随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>在class文件里，一个方法若想调用其他方法，或者访问成员变量，则需要通过符号引用（symbolic reference）来表示，动态链接的作用就是将这些以符号引用所表示的方法转换为对实际方法的直接引用。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之MySQL</title>
    <url>/2019/10/20/interview-mysql/</url>
    <content><![CDATA[<h3 id="MySQL范式与反模式"><a href="#MySQL范式与反模式" class="headerlink" title="MySQL范式与反模式"></a>MySQL范式与反模式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p><strong>每列都保持原子性。</strong></p>
<p>举个例子，活动表（活动编码，活动名称，活动地址），假设这个场景中，活动地址可以细分为国家、省份、城市、市区、位置，那么就没有达到第一范式。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><strong>非主属性不部分依赖于候选码。</strong></p>
<p>举个例子，版本表（版本编码，版本名称，产品编码，产品名称），其中主键是（版本编码，产品编码），这个场景中，数据库设计并不符合第二范式，因为产品名称只依赖于产品编码。存在部分依赖。所以，为了使其满足第二范式，可以改造成两个表：版本表（版本编码，产品编码）和产品表（产品编码，产品名称）。</p>
<a id="more"></a>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p><strong>非主属性不传递依赖于候选码。</strong></p>
<p>举个例子，订单表（订单编码，顾客编码，顾客名称），其中主键是（订单编码），这个场景中，顾客编码、顾客名称都完全依赖于主键，因此符合第二范式，但是顾客名称依赖于顾客编码，从而间接依赖于主键，所以不能满足第三范式。为了使其满足第三范式，可以拆分两个表：订单表（订单编码，顾客编码）和顾客表（顾客编码，顾客名称），拆分后的数据库设计，就可以完全满足第三范式的要求了。</p>
<p>值得注意的是，第二范式的侧重点是非主键列是否完全依赖于主键，还是依赖于主键的一部分。第三范式的侧重点是非主键列是直接依赖于主键，还是直接依赖于非主键列。</p>
<h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><p>范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。</p>
<p>然而，通过数据库范式化设计，将导致数据库业务涉及的表变多，并且可能需要将涉及的业务表进行多表连接查询，这样将导致性能变差，且不利于分库分表。因此，出于性能优先的考量，可能在数据库的结构中需要使用反模式的设计，即空间换取时间，采取数据冗余的方式避免表之间的关联查询。至于数据一致性问题，因为难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。</p>
<p>需要谨慎使用反模式设计数据库。一般情况下，尽可能使用范式化的数据库设计，因为范式化的数据库设计能让产品更加灵活，并且能在数据库层保持数据完整性。</p>
<p>有的时候，提升性能最好的方法是在同一表中保存冗余数据，如果能容许少量的脏数据，创建一张完全独立的汇总表或缓存表是非常好的方法。举个例子，设计一张“下载次数表”来缓存下载次数信息，可使在海量数据的情况下，提高查询总数信息的速度。</p>
<p>另外一个比较典型的场景，出于扩展性考虑，可能会使用 BLOB 和 TEXT 类型的列存储 JSON 结构的数据，这样的好处在于可以在任何时候，将新的属性添加到这个字段中，而不需要更改表结构。但是，这个设计的缺点也比较明显，就是需要获取整个字段内容进行解码来获取指定的属性，并且无法进行索引、排序、聚合等操作。因此，如果需要考虑更加复杂的使用场景，更加建议使用 MongoDB 这样的文档型数据库。</p>
<h3 id="MySQL-中-VARCHAR-与-CHAR-的区别？VARCHAR-50-中的-50-代表的涵义？"><a href="#MySQL-中-VARCHAR-与-CHAR-的区别？VARCHAR-50-中的-50-代表的涵义？" class="headerlink" title="MySQL 中 VARCHAR 与 CHAR 的区别？VARCHAR(50) 中的 50 代表的涵义？"></a>MySQL 中 <code>VARCHAR</code> 与 <code>CHAR</code> 的区别？<code>VARCHAR(50)</code> 中的 50 代表的涵义？</h3><ul>
<li>CHAR 是一种固定长度的类型，如果插入长度小于定义长度，则用空格填充</li>
<li>CARCHAR 则是一种可变长度的类型，如果插入长度小于定于长度，还是按照实际长度存储。</li>
<li>VARCHAR(50) 中 50 的涵义最多存放 50 个字符。VARCHAR(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 ORDER BY col 采用 fixed_length 计算 col 长度(memory引擎也一样)。</li>
</ul>
<h3 id="INT-11-中的-11-代表什么涵义？"><a href="#INT-11-中的-11-代表什么涵义？" class="headerlink" title="INT(11) 中的 11 代表什么涵义？"></a><code>INT(11)</code> 中的 11 代表什么涵义？</h3><p><code>INT(11)</code> 中的 11 ，不影响字段存储的范围，<strong>代表字符的显示宽度</strong>。</p>
<h3 id="索引的类型（InnoDB）有哪些？"><a href="#索引的类型（InnoDB）有哪些？" class="headerlink" title="索引的类型（InnoDB）有哪些？"></a>索引的类型（InnoDB）有哪些？</h3><p>索引，都是实现在存储引擎层的。主要有六种类型：</p>
<ul>
<li>主键索引</li>
<li>外键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ul>
<h3 id="MySQL语句中需要注意走不走索引的一些情况"><a href="#MySQL语句中需要注意走不走索引的一些情况" class="headerlink" title="MySQL语句中需要注意走不走索引的一些情况"></a>MySQL语句中需要注意走不走索引的一些情况</h3><h4 id="不走索引"><a href="#不走索引" class="headerlink" title="不走索引"></a>不走索引</h4><ul>
<li>在 WHERE 子句中使用 表达式 比如 <code>WHERE id % 2=0</code></li>
<li>LIKE 查询 前 %</li>
<li>联合索引不满足前缀原则</li>
</ul>
<h4 id="有可能走索引，有可能不走，MySQL会比较怎执行效率高"><a href="#有可能走索引，有可能不走，MySQL会比较怎执行效率高" class="headerlink" title="有可能走索引，有可能不走，MySQL会比较怎执行效率高"></a>有可能走索引，有可能不走，MySQL会比较怎执行效率高</h4><ul>
<li>在 WHERE 子句中使用 <code>!=</code> </li>
<li>在 WHERE 子句中使用 <code>&lt;&gt;</code></li>
<li>在 WHERE 子句中使用 <code>OR</code> </li>
<li>在 WHERE 子句中使用 <code>IN</code></li>
</ul>
<h3 id="什么是索引的最左匹配特性？"><a href="#什么是索引的最左匹配特性？" class="headerlink" title="什么是索引的最左匹配特性？"></a>什么是索引的最左匹配特性？</h3><p>当 B+Tree 的数据项是复合的数据结构，比如索引 (name, age, sex) 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。</p>
<ul>
<li><p>比如当 (张三, 20, F) 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。</p>
</li>
<li><p>但当 (20, F) 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</p>
</li>
<li><p>比如当 (张三, F) 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。<br>这个是非常重要的性质，即索引的最左匹配特性。</p>
</li>
</ul>
<h3 id="事务的特性？"><a href="#事务的特性？" class="headerlink" title="事务的特性？"></a>事务的特性？</h3><ol>
<li>原子性 Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>一致性 Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>隔离性 Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性 Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="事务的并发问题有哪些？"><a href="#事务的并发问题有哪些？" class="headerlink" title="事务的并发问题有哪些？"></a>事务的并发问题有哪些？</h3><p>实际场景下，事务并不是串行的，所以会带来如下三个问题：</p>
<ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<h3 id="MySQL-事务隔离级别会产生的并发问题？"><a href="#MySQL-事务隔离级别会产生的并发问题？" class="headerlink" title="MySQL 事务隔离级别会产生的并发问题？"></a>MySQL 事务隔离级别会产生的并发问题？</h3><p>事务定义了四种事务隔离级别，不同数据库在实现时，产生的并发问题是不同的。</p>
<blockquote>
<p>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。</p>
</blockquote>
<ul>
<li>READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其他事务也都是可见的。<blockquote>
<p><strong>会导致脏读</strong></p>
</blockquote>
</li>
<li>READ COMMITTED（读提交）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。<blockquote>
<p><strong>会导致不可重复读</strong>。这个隔离级别，也可以叫做“不可重复读”。</p>
</blockquote>
</li>
<li>REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。<blockquote>
<p><strong>会导致幻读</strong></p>
</blockquote>
</li>
<li>SERIALIZABLE（串行化）：强制事务串行执行。<blockquote>
<p>不会产生上述问题</p>
</blockquote>
</li>
</ul>
<h3 id="MySQL-查询执行顺序？"><a href="#MySQL-查询执行顺序？" class="headerlink" title="MySQL 查询执行顺序？"></a>MySQL 查询执行顺序？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)     SELECT</span><br><span class="line">(<span class="number">2</span>)     DISTINCT &lt;select_list&gt;</span><br><span class="line">(<span class="number">3</span>)     FROM &lt;left_table&gt;</span><br><span class="line">(<span class="number">4</span>)     &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(<span class="number">5</span>)     ON &lt;join_condition&gt;</span><br><span class="line">(<span class="number">6</span>)     WHERE &lt;where_condition&gt;</span><br><span class="line">(<span class="number">7</span>)     GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">8</span>)     HAVING &lt;having_condition&gt;</span><br><span class="line">(<span class="number">9</span>)     ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(<span class="number">10</span>)    LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h3><ul>
<li>通过事务隔离级别和MVCC，保证没有脏读和不可重复读</li>
<li>InnoDB默认使用行锁</li>
<li>一般情况的查询，我们基本使用<strong>快照读</strong>，即不加锁读。</li>
<li><code>UPDATE</code>语句和<code>DELETE</code>语句执行的时候，使用的是<strong>当前读</strong>，即加锁。</li>
</ul>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>多版本并发控制（MVCC），是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<h3 id="索引原理（InnoDB）"><a href="#索引原理（InnoDB）" class="headerlink" title="索引原理（InnoDB）"></a>索引原理（InnoDB）</h3><p>InnoDB索引底层数据结构是基于B+树实现的。</p>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>MySQL面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java虚拟机</title>
    <url>/2019/10/19/interview-java-jvm/</url>
    <content><![CDATA[<h3 id="什么是Java虚拟机？"><a href="#什么是Java虚拟机？" class="headerlink" title="什么是Java虚拟机？"></a>什么是Java虚拟机？</h3><p>Java虚拟机是一个可以执行Java字节码（Java 源文件被编译成能被 Java 虚拟机执行的字节码文件( .class )）的虚拟机进程。</p>
<p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<p>但是，跨平台的是 Java 程序(包括字节码文件)，，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 。</p>
<a id="more"></a>
<h3 id="JVM内存区域模型"><a href="#JVM内存区域模型" class="headerlink" title="JVM内存区域模型"></a>JVM内存区域模型</h3><p>JVM 内存区域基本上由4个区域组成：</p>
<ul>
<li>类加载器：在JVM启动时或者类运行时，将需要的class加载到JVM中。</li>
<li>运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块。</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。</li>
<li>本地方法调用：执行C/C++实现的本地方法的代码，并返回结果。</li>
</ul>
<p><img src="/images/jvm-composition.png" alt></p>
<h3 id="Java-运行时数据区域"><a href="#Java-运行时数据区域" class="headerlink" title="Java 运行时数据区域"></a>Java 运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
<h4 id="元数据（方法区）"><a href="#元数据（方法区）" class="headerlink" title="元数据（方法区）"></a>元数据（方法区）</h4><p>各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是元数据的一部分，用于存放编译器生成的各种字面量和符号引用。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时数据的一部分。JDK1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存的限制。也可能导致<code>OutOfMemoryError</code>出现。</p>
<p>JVM内存区域的详细介绍可以看这篇<a href="https://iisheng.cn/2019/10/22/java-memory-area/">深入理解JVM之Java内存区域</a></p>
<h4 id="Java-内存堆和栈区别？"><a href="#Java-内存堆和栈区别？" class="headerlink" title="Java 内存堆和栈区别？"></a>Java 内存堆和栈区别？</h4><ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 java.lang.StackOverFlowError 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 java.lang.OutOfMemoryError 错误。</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。-Xss 选项设置栈内存的大小，-Xms 选项可以设置堆的开始时的大小。<br>当然，如果你记不住这个些，只要记住如下即可：</li>
</ul>
<blockquote>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
</blockquote>
<h4 id="Java-对象创建过程？"><a href="#Java-对象创建过程？" class="headerlink" title="Java 对象创建过程？"></a>Java 对象创建过程？</h4><p>JAVA 对象创建的过程，如下图所示：<br><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/06.png" alt></p>
<h4 id="有哪些-OutOfMemoryError-异常？"><a href="#有哪些-OutOfMemoryError-异常？" class="headerlink" title="有哪些 OutOfMemoryError 异常？"></a>有哪些 OutOfMemoryError 异常？</h4><ul>
<li>Java 堆溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>元数据的内存溢出</li>
<li>运行时常量池溢出</li>
</ul>
<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><h4 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h4><h4 id="垃圾收集器有哪些？"><a href="#垃圾收集器有哪些？" class="headerlink" title="垃圾收集器有哪些？"></a>垃圾收集器有哪些？</h4><h4 id="判断对象死亡的2种常用方法？"><a href="#判断对象死亡的2种常用方法？" class="headerlink" title="判断对象死亡的2种常用方法？"></a>判断对象死亡的2种常用方法？</h4><h4 id="什么是新生代-GC-和老年代-GC？"><a href="#什么是新生代-GC-和老年代-GC？" class="headerlink" title="什么是新生代 GC 和老年代 GC？"></a>什么是新生代 GC 和老年代 GC？</h4><h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><h4 id="JDK-的命令行工具有哪些可以监控虚拟机？"><a href="#JDK-的命令行工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的命令行工具有哪些可以监控虚拟机？"></a>JDK 的命令行工具有哪些可以监控虚拟机？</h4><h4 id="JDK-的可视化工具有哪些可以监控虚拟机？"><a href="#JDK-的可视化工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的可视化工具有哪些可以监控虚拟机？"></a>JDK 的可视化工具有哪些可以监控虚拟机？</h4><h4 id="如何排查线程-Full-GC-频繁的问题？"><a href="#如何排查线程-Full-GC-频繁的问题？" class="headerlink" title="如何排查线程 Full GC 频繁的问题？"></a>如何排查线程 Full GC 频繁的问题？</h4><h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><h4 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h4><p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(.java 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(.class 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。</p>
<ul>
<li>每个这样的实例用来表示一个 Java 类。通过此实例的 Class#newInstance(…) 方法，就可以创建出该类的一个对象。</li>
<li>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</li>
</ul>
<h4 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h4><h4 id="什么是双亲委派模型（Parent-Delegation-Model）？"><a href="#什么是双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="什么是双亲委派模型（Parent Delegation Model）？"></a>什么是双亲委派模型（Parent Delegation Model）？</h4><h4 id="类的加载机制是什么？"><a href="#类的加载机制是什么？" class="headerlink" title="类的加载机制是什么？"></a>类的加载机制是什么？</h4>]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java并发</title>
    <url>/2019/10/18/interview-java-concurrency/</url>
    <content><![CDATA[<h4 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h4><p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li><p>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
</li>
<li><p>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h3><p>线程一共有五个状态，分别如下：</p>
<ul>
<li>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1 = new Thread() 。</li>
<li>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：t1.start() 。</li>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（#run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<ul>
<li>自然终止：正常运行完 #run()方法，终止。</li>
<li>异常终止：调用 #stop() 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>堵塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
<ul>
<li>正在睡眠：调用 <code>#sleep(long t)</code> 方法，可使线程进入睡眠方式。</li>
<li>正在等待：调用 <code>#wait()</code> 方法。调用 <code>notify()</code> 方法，回到就绪状态。</li>
<li>被另一个线程所阻塞：调用 <code>#suspend()</code> 方法。（调用 <code>#resume()</code> 方法，就可以恢复。）</li>
</ul>
</li>
</ul>
<p>整体如下图所示：</p>
<p><img src="http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c" alt></p>
<ul>
<li>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</li>
<li>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。</li>
</ul>
<h3 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h3><ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li>使用方式一<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread#currentThread() 方法，直接使用 this 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li>使用方式二、或方式三<ul>
<li>优点：<ul>
<li>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li><strong>可以使用线程池。</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>编程稍微复杂，如果要访问当前线程，则必须使用Thread#currentThread() 方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h3><h3 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h3><p><strong>1）sleep 方法</strong></p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有synchronized 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 synchronized)，一个线程优先级为MAX_PRIORITY ，另一个为 MIN_PRIORITY 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 #sleep(5000) 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p><strong>2）yield 方法</strong></p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p><strong>3）join 方法</strong></p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 中。B运行完后，A才会继续执行。示例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 t 完成为止。然而，如果它加入的线程 t 没有存活，则当前线程不需要停止。</li>
</ul>
<h3 id="sleep-0-有什么用途？"><a href="#sleep-0-有什么用途？" class="headerlink" title="sleep(0) 有什么用途？"></a>sleep(0) 有什么用途？</h3><p><code>Thread#sleep(0)</code> 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 <code>Thread#sleep(0)</code> 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。<code>Thread#sleep(0)</code> 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个<strong>让位动作</strong></p>
<h3 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</h3><blockquote>
<p>考点，就是 join 方法。</p>
</blockquote>
<p>我们可以使用 Thread 类的 <code>#join()</code> 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h3 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h3><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h3><p><strong>1）线程同步</strong><br>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：<br>事件<ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p><strong>2）线程互斥</strong><br>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<h3 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h3><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<h3 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a>synchronized 的原理是什么?</h3><h3 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h3><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败</p>
<h3 id="死锁和活锁的区别？"><a href="#死锁和活锁的区别？" class="headerlink" title="死锁和活锁的区别？"></a>死锁和活锁的区别？</h3><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，聪慧的胖友是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</li>
</ul>
<h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</li>
<li>在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</li>
</ul>
<h3 id="乐观锁的实现方式有哪些"><a href="#乐观锁的实现方式有哪些" class="headerlink" title="乐观锁的实现方式有哪些"></a>乐观锁的实现方式有哪些</h3><ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h3 id="什么是Java-Lock-接口？"><a href="#什么是Java-Lock-接口？" class="headerlink" title="什么是Java Lock 接口？"></a>什么是Java Lock 接口？</h3><h3 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h3><p>已经获取到锁的对象，再次申请获取锁，也可以申请成功，就是可重入锁。</p>
<h3 id="synchronized-和-ReentrantLock-异同？"><a href="#synchronized-和-ReentrantLock-异同？" class="headerlink" title="synchronized 和 ReentrantLock 异同？"></a>synchronized 和 ReentrantLock 异同？</h3><p>相同点：</p>
<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
<p>不同点：</p>
<ul>
<li>同步实现机制不同<ul>
<li>synchronized 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li>synchronized 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 volatile state 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li>synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 finally 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li>synchronized 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li>synchronized 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 synchronized 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 synchronized 。</p>
</blockquote>
<blockquote>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。</p>
</blockquote>
<h3 id="ReadWriteLock-是什么"><a href="#ReadWriteLock-是什么" class="headerlink" title="ReadWriteLock 是什么"></a>ReadWriteLock 是什么</h3><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<h3 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h3><p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/01.png" alt></p>
<h3 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ol>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ol>
<p><strong>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</strong> </p>
<h3 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h3><h3 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><ul>
<li><p>SynchronizedMap</p>
<ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li><p>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</p>
</li>
<li><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h3><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<h3 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h3><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<blockquote>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
</blockquote>
<p><strong>1）普通线程池</strong></p>
<ul>
<li><code>#newFixedThreadPool(int nThreads)</code> 方法，创建一个固定长度的线程池。<ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
<li><code>#newCachedThreadPool()</code> 方法，创建一个可缓存的线程池。<ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
<li><code>#newSingleThreadExecutor()</code> 方法，创建一个单线程的线程池。<ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
<p><strong>2）定时任务线程池</strong></p>
<ul>
<li><code>#newScheduledThreadPool(int corePoolSize)</code> 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li><code>#newSingleThreadExecutor()</code> 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
<h3 id="ThreadPoolExecutor-有哪些拒绝策略？"><a href="#ThreadPoolExecutor-有哪些拒绝策略？" class="headerlink" title="ThreadPoolExecutor 有哪些拒绝策略？"></a>ThreadPoolExecutor 有哪些拒绝策略？</h3><p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy() ，直接抛出异常 RejectedExecutionException 。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy() ，直接调用 run 方法并且阻塞执行。</li>
<li>ThreadPoolExecutor.DiscardPolicy() ，直接丢弃后来的任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy() ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。</p>
<h3 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h3><p><strong>1）Callable</strong></p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<blockquote>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
</blockquote>
<p><strong>2）Future</strong></p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p><strong>3）FutureTask</strong></p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h3 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h3><h3 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<p>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程<br>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 </p>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Spring MVC</title>
    <url>/2019/10/17/interview-spring-mvc/</url>
    <content><![CDATA[<h3 id="Spring-MVC-各组件以及功能"><a href="#Spring-MVC-各组件以及功能" class="headerlink" title="Spring MVC 各组件以及功能"></a>Spring MVC 各组件以及功能</h3><ul>
<li>MultipartResolver：内容类型( Content-Type )为 <code>multipart/*</code> 的请求的解析器接口</li>
<li>LocaleResolver：本地化( 国际化 )解析器接口</li>
<li>ThemeResolver：主题解析器接口(例如，从请求头 User-Agent ，判断使用 PC 端，还是移动端的主题)</li>
<li>HandlerMapping：处理器匹配接口，根据请求( handler )获得其的处理器( handler )和拦截器们( HandlerInterceptor 数组 )</li>
<li>HandlerAdapter：处理器适配器接口</li>
<li>HandlerExceptionResolver：处理器异常解析器接口，将处理器( handler )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果</li>
<li>RequestToViewNameTranslator：请求到视图名的转换器接口</li>
<li>ViewResolver：实体解析器接口，根据视图名和国际化，获得最终的视图 View 对象</li>
<li>FlashMapManager：FlashMap 管理器接口，负责重定向时，保存参数到临时存储中</li>
</ul>
<a id="more"></a>
<h3 id="DispatcherServlet-的工作流程"><a href="#DispatcherServlet-的工作流程" class="headerlink" title="DispatcherServlet 的工作流程"></a>DispatcherServlet 的工作流程</h3><ol>
<li>发送请求：用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器 DispatcherServlet 捕获。</li>
<li>映射处理器：DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回。</li>
<li>处理器适配：DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 #preHandler(…) 方法）。Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象</li>
<li>解析视图：根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</li>
<li>渲染视图 + 响应请求</li>
</ol>
<h3 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h3><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中加载配置文件，完成初始化 Spring MVC 组件的工作。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<h4 id="Spring-MVC-运行流程图"><a href="#Spring-MVC-运行流程图" class="headerlink" title="Spring MVC 运行流程图"></a>Spring MVC 运行流程图</h4><p><img src="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png" alt></p>
<h3 id="Spring-MVC拦截器"><a href="#Spring-MVC拦截器" class="headerlink" title="Spring MVC拦截器"></a>Spring MVC拦截器</h3><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandlerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并且，只有该处理器 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一共有三个方法，分别为：<ul>
<li><code>#preHandle(...)</code> 方法，调用 Controller 方法之前执行。</li>
<li><code>#postHandle(...)</code> 方法，调用 Controller 方法之后执行。</li>
<li><code>#afterCompletion(...)</code> 方法，处理完 Controller 方法返回结果之后执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>如何充分利用你的24小时</title>
    <url>/2019/10/09/time-mgt/</url>
    <content><![CDATA[<p><strong>如果你对 “如何充分利用你的24小时”感兴趣，我推荐你读《时间管理 如何充分利用你的24小时》漫画版。</strong></p>
<p>以下是我个人从书中学到的以及一些自己的体会。</p>
<h3 id="意识到自己的时间花费在什么地方"><a href="#意识到自己的时间花费在什么地方" class="headerlink" title="意识到自己的时间花费在什么地方"></a>意识到自己的时间花费在什么地方</h3><p>每天睡觉之前的时间，可以总结一下当天都做什么事情，分别花费了多少时间。画一个如下类似的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间段</th>
<th style="text-align:center">内容</th>
<th style="text-align:center">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">02:30-12:00</td>
<td style="text-align:center">睡觉</td>
<td style="text-align:center">9.5小时</td>
</tr>
<tr>
<td style="text-align:center">14:00-20:00</td>
<td style="text-align:center">打王者荣耀</td>
<td style="text-align:center">6小时</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">19:00-22:00</td>
<td style="text-align:center">看电视剧</td>
<td style="text-align:center">5小时</td>
</tr>
<tr>
<td style="text-align:center">23:00-24:00</td>
<td style="text-align:center">定外卖吃饭</td>
<td style="text-align:center">3小时</td>
</tr>
</tbody>
</table>
<p>这样可以清晰看到自己在某件事情上花费的时间，可以根据自己的情况在计划表中减少或者增加。</p>
<a id="more"></a>
<h3 id="确定自己的目标"><a href="#确定自己的目标" class="headerlink" title="确定自己的目标"></a>确定自己的目标</h3><p>找自己喜欢的方式给自己制定明确的计划表，比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01:00-08:00</td>
<td style="text-align:center">睡觉</td>
</tr>
<tr>
<td style="text-align:center">08:30-09:00</td>
<td style="text-align:center">吃早餐</td>
</tr>
<tr>
<td style="text-align:center">09:00-12:00</td>
<td style="text-align:center">学习数据结构</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">23:00-24:00</td>
<td style="text-align:center">洗澡、做当天总结、做第二天计划</td>
</tr>
</tbody>
</table>
<p>对比自己的计划表和实际花费的时间表，总结自己的行为，改进自己的时间管理。</p>
<h3 id="选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情"><a href="#选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情" class="headerlink" title="选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情"></a>选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情</h3><h4 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h4><ul>
<li>闹钟响起，立即下床</li>
<li>上午时间，学习数据结构与算法相关</li>
<li>规律、健康的饮食和运动</li>
<li>快速做抉择</li>
<li>快速阅读</li>
<li>利用碎片时间，地铁上、等外卖、排队的时候，可以看公众号、极客时间<br>、知识星球</li>
<li>不拖延，按照计划表去做。大任务，分解成小任务，放到计划表中。</li>
<li>拒绝杂乱无章，物应各有其所，亦应各在其所</li>
<li>每周对自己的时间花费行为进行总结，每月也要总结，已经制定下月计划</li>
</ul>
<h4 id="时间管理技巧"><a href="#时间管理技巧" class="headerlink" title="时间管理技巧"></a>时间管理技巧</h4><ul>
<li>利用好碎片时间</li>
<li>做事前花特定时间思考，思考时间过后开始行动</li>
<li>做事专注</li>
<li>做事不半途而废，做完之后，不再打开</li>
<li>注意在重要的事情上多花费时间</li>
<li>注意优先顺序，在精力充沛的时间，做当天最困难的事情</li>
<li>保似水之心</li>
<li>拒绝杂乱无章</li>
<li>总结、制定计划</li>
<li>规律、健康的饮食和运动</li>
</ul>
]]></content>
      <categories>
        <category>😮心得体会</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java集合</title>
    <url>/2019/10/02/interview-java-collection/</url>
    <content><![CDATA[<h3 id="Java集合框架都有哪些？"><a href="#Java集合框架都有哪些？" class="headerlink" title="Java集合框架都有哪些？"></a>Java集合框架都有哪些？</h3><h4 id="实现Collection接口的，存放特定元素的集合的对象"><a href="#实现Collection接口的，存放特定元素的集合的对象" class="headerlink" title="实现Collection接口的，存放特定元素的集合的对象"></a>实现<code>Collection</code>接口的，存放特定元素的集合的对象</h4><p><img src="https://static001.geekbang.org/resource/image/67/c7/675536edf1563b11ab7ead0def1215c7.png" alt></p>
<a id="more"></a>
<h4 id="实现Map接口的，将键映射到值的对象"><a href="#实现Map接口的，将键映射到值的对象" class="headerlink" title="实现Map接口的，将键映射到值的对象"></a>实现<code>Map</code>接口的，将键映射到值的对象</h4><p><img src="https://static001.geekbang.org/resource/image/26/7c/266cfaab2573c9777b1157816784727c.png" alt></p>
<h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。（）</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li>HashMap：HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
</ul>
<p>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</p>
<ul>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ul>
<h4 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h4><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。可以用下标遍历或者迭代器遍历。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。只能用迭代器遍历。</li>
</ul>
<h4 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h5 id="适用场景分析："><a href="#适用场景分析：" class="headerlink" title="适用场景分析："></a>适用场景分析：</h5><ul>
<li>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</li>
<li>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</li>
</ul>
<h4 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h4><p>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。</p>
<h4 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h4><ul>
<li>HashSet底层用HashMap实现的</li>
<li>TreeSet底层用TreeMap实现的</li>
</ul>
<h4 id="HashMap-和-TreeMap-的区别？"><a href="#HashMap-和-TreeMap-的区别？" class="headerlink" title="HashMap 和 TreeMap 的区别？"></a>HashMap 和 TreeMap 的区别？</h4><ul>
<li>HashMap底层实现是数组+链表或者红黑树，TreeMap底层实现是红黑树</li>
<li>Map 中插入、删除和定位元素这类操作，HashMap 比较适合</li>
<li>假如你需要对一个有序的 key 集合进行遍历， TreeMap 更适合。</li>
</ul>
<h4 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h4><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。</p>
<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个<strong>链表散列</strong>。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0017/7479/3f05dd61-955e-3eb2-bf8e-31da8a361148.jpg" alt></p>
<h4 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h4><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 % 取余的操作来实现。但是，重点来了：</p>
<ul>
<li>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 <code>hash % length == hash &amp; (length - 1)</code> 的前提是 length 是 2 的 n 次方；）。</li>
<li>并且，采用二进制位操作 &amp;，相对于 % 能够提高运算效率，<br>这就解释了 HashMap 的长度为什么是 2 的幂次方。</li>
</ul>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 <code>#remove(Object Obj)</code> 方法删除，可以通过迭代器的 <code>#remove()</code> 方法删除。</p>
<h4 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h4><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h4 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h4><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 <code>java.util</code> 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 <code>ConcurrentModification</code> 异常。在 <code>java.util.concurrent</code> 包下的全是安全失败的。</li>
</ul>
<h4 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h4><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h3><ul>
<li>Comparable 接口，<code>在 java.lang</code> 包下，用于当前对象和其它对象的比较，所以它有一个 <code>#compareTo(Object obj)</code> 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 <code>java.util</code> 包下，用于传入的两个对象的比较，所以它有一个 <code>#compare(Object obj1, Object obj2)</code> 方法用来排序，该方法有两个参数。</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java基础</title>
    <url>/2019/09/24/interview-java-basic/</url>
    <content><![CDATA[<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向过程</strong>是分析出实现需求所需要的步骤，通过函数一步一步实现这些步骤，然后依次调用。<strong>将实现步骤化</strong>。</p>
<p><strong>面向对象</strong>是把整个需求按照特点、功能划分，将这些存在共性的部分封装成对象。创建对象不是为了完成某一个步骤，而是描述某个事物在解决问题中的行文。<strong>将实现行为化</strong>。</p>
<h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><ul>
<li>封装：隐藏对象内部的特性和行为。</li>
<li>继承：子类继承父类的特性和行为。</li>
<li>多态：不同类的对象，对同一消息，做出不同响应。</li>
<li>抽象：把一类事物共有的属性和行为提出来，形成一个模板。</li>
</ul>
<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul>
<li>重写 override<ul>
<li>方法名、参数、返回值相同</li>
<li>方法被定义为final 不能被重写</li>
<li>存在于父类和子类之间</li>
</ul>
</li>
<li>重载 overload<ul>
<li>参数类型、个数、顺序至少有一个不同</li>
<li>不能重载只有返回值不同的方法名</li>
<li>存在于父类和子类、同类中</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h4><blockquote>
<p>衍生问题，Java 是编译执行的语言，还是解释执行的语言。</p>
</blockquote>
<ul>
<li>编译型语言：在被执行之前需要一个专门的编译过程，把程序编译为机器语言的文件，比如windows下的exe文件。下次不需要再编译，可以直接在机器上运行。效率比较高。编译型语言有C、C++等。</li>
<li>解释型语言：不需要编译。在运行时翻译成机器识别的机器语言。每次执行都需要一次翻译的过程。效率比较低。解释型语言有C#、Python等。</li>
</ul>
<p>Java中引入虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机转化为特定系统的机器码执行。在Java中这种虚拟机理解的代码叫做<strong>字节码（即扩展名为.class的文件）</strong>，它不面向任何的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的。但是实现的虚拟机是相同的。Java源程序经过编译器编译后编程字节码，字节码由虚拟机解释器执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就解释了Java的编译与解释并存的特点。</strong></p>
<h3 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h3><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<ul>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
</ul>
<h3 id="对Object-对象中-hashCode-和-equals-方法的理解"><a href="#对Object-对象中-hashCode-和-equals-方法的理解" class="headerlink" title="对Object 对象中 hashCode 和 equals 方法的理解"></a>对Object 对象中 hashCode 和 equals 方法的理解</h3><ul>
<li>equals 方法，用于比较对象的内容是否相等。当子类覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</li>
<li>hashCode 方法，大多在集合中用到。如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<p>hashCode 方法的重写，可以看看 <a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">《科普：为什么 String hashCode 方法选择数字31作为乘子》</a>方法。</p>
<h3 id="讲讲类的实例化顺序"><a href="#讲讲类的实例化顺序" class="headerlink" title="讲讲类的实例化顺序"></a>讲讲类的实例化顺序</h3><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><p>Java IO 相关的类在<code>java.io</code>包下，具体操作分成面向字节（Byte）和面向字符（Character）两种方式，如下图所示。</p>
<p><img src="/images/java-io.png" alt></p>
<h4 id="Java提供了哪些IO方式？-NIO如何实现多路复用？"><a href="#Java提供了哪些IO方式？-NIO如何实现多路复用？" class="headerlink" title="Java提供了哪些IO方式？ NIO如何实现多路复用？"></a>Java提供了哪些IO方式？ NIO如何实现多路复用？</h4><p>首先，传统的 <code>java.io</code> 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p><code>java.io</code> 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 <code>java.net</code> 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java  1.4 中引入了 NIO 框架（<code>java.nio</code> 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<h3 id="Error和Exception区别"><a href="#Error和Exception区别" class="headerlink" title="Error和Exception区别"></a>Error和Exception区别</h3><ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/ac/00/accba531a365e6ae39614ebfa3273900.png" alt></p>
<h3 id="反射的用途以及实现"><a href="#反射的用途以及实现" class="headerlink" title="反射的用途以及实现"></a>反射的用途以及实现</h3><p>反射主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象</li>
<li>调用类的成员变量和方法</li>
<li>生成动态代理</li>
</ul>
<h4 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h4><p>动态代理是设计模式中代理模式的一个分类。代理模式分为静态代理和动态代理。</p>
<p>详细介绍你可以看这篇<a href="https://iisheng.cn/2019/08/14/proxy-pattern/">设计模式之代理模式</a></p>
<h3 id="Java对象创建的方式"><a href="#Java对象创建的方式" class="headerlink" title="Java对象创建的方式"></a>Java对象创建的方式</h3><ol>
<li>使用<code>new</code>关键字创建对象</li>
<li>使用<code>Class</code>类的<code>newIntance</code>方法（反射机制）</li>
<li>使用 <code>Constructor</code> 类的 <code>newInstance</code> 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
<h3 id="强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？"><a href="#强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？"></a>强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？</h3><p>不同的引用类型，主要提现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p>
<ul>
<li><p>强引用（Strong Reference）<br>是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将对应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li><p>软引用（Sort Reference）<br>是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集。只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>弱引用（Weak Reference）<br>并不能使对象豁免垃圾收集，仅仅是提供一种在弱引用状态下对象的访问途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重新实例化。它同样是很多缓存实现的选择。</p>
</li>
<li><p>虚引用，也叫幻象引用<br>你不能通过它访问对象。虚引用仅仅是提供一种确保对象被finalize以后，做某些事情的机智，比如，通常用来做所谓的Post-Mortem清理机智，也有人利用虚引用监控对象的创建和销毁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之贪心算法</title>
    <url>/2019/09/17/greedy/</url>
    <content><![CDATA[<h3 id="贪心算法思想"><a href="#贪心算法思想" class="headerlink" title="贪心算法思想"></a>贪心算法思想</h3><p><strong>贪心算法</strong>就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说<strong>它总是做出局部最优的选择，寄希望这样的选择导致全局最优解。</strong></p>
<blockquote>
<p>贪心算法并不保证得到最优解，但很多问题确实可以求得最优解。</p>
</blockquote>
<h3 id="我们可以按如下步骤设计贪心算法："><a href="#我们可以按如下步骤设计贪心算法：" class="headerlink" title="我们可以按如下步骤设计贪心算法："></a>我们可以按如下步骤设计贪心算法：</h3><ol>
<li>将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。</li>
<li>证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。</li>
<li>证明做出选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。</li>
</ol>
<a id="more"></a>
<h3 id="贪心算法与动态规划的区别"><a href="#贪心算法与动态规划的区别" class="headerlink" title="贪心算法与动态规划的区别"></a>贪心算法与动态规划的区别</h3><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>一个正在抢劫商店的小偷，发现了n个商品，第i个商品价值v<sub>i</sub>美元，重w<sub>i</sub>磅，v<sub>i</sub>和w<sub>i</sub>都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳W磅重的商品，W是一个整数。他应该拿哪些商品？（我们称这个问题为0-1背包问题，因为对每个商品，小偷要么把他完整拿走，要么把他留下；他不能只拿走商品的一部分，或者把一个商品拿走多次。）</p>
<h4 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h4><p>设定与0-1背包问题一样的，但对每个商品，小偷可以拿走其一部分。你可以将0-1背包中的商品想象为金锭，而分数背包问题中的商品更像金砂。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>我们可以用<strong>贪心策略解决分数背包问题</strong>。我们首先计算每个商品的每磅价值v<sub>i</sub>/w<sub>i</sub>。遵循贪心策略，小偷首先尽量多的拿走每磅价值最高的商品。如果此商品已经全部拿走而背包未满，他继续尽量多的拿走每磅价值第二高的商品，依此类推，直到达到重量上限W。</p>
<p>对于分数背包问题，上述贪心策略首先拿走每磅价值最大的商品，是可以生成最优解的。该策略对0-1背包无效是因为小偷<strong>无法装满背包，空闲空间降低了方案的有效每磅价值</strong>。</p>
<p>在0-1背包问题中，当我们考虑是否将一个商品加入背包时，<strong>必须比较包含此商品的子问题的解与不包含它的子问题的解</strong>，然后才能做出选择。<strong>这会导致大量的重叠子问题–动态规划的标识</strong>。这种问题就适合用动态规划去做。</p>
<h4 id="分糖果问题"><a href="#分糖果问题" class="headerlink" title="分糖果问题"></a>分糖果问题</h4><p><a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">leetcode 135. Candy</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy2</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = candies[ratings.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = candies[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            candies[i] = Math.max(candies[i], temp);</span><br><span class="line">            result += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之动态规划</title>
    <url>/2019/09/10/dp/</url>
    <content><![CDATA[<h4 id="动态规划算法思想"><a href="#动态规划算法思想" class="headerlink" title="动态规划算法思想"></a>动态规划算法思想</h4><p>动态规划（dynamic programming）与分治方法相似，都是通过组合子问题的解来求解原问题（在这里，programming 指的是一种表格法）。分治法将问题划分为互不相交的子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即<strong>不同的子问题具有公共的子问题</strong>（子问题的求解释递归进行的，将其划分为更小的子子问题）。在这种情况下，分治法会做许多不必要的工作，它会反复求解那些公共子问题。而动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子问题时都重新计算，避免了这种不必要的计算工作。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>动态规划方法通常用来求解<strong>最优化问题</strong>。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解（an optimal solution），而不是最优解（the optimal solution），因为可能有多个解都达到最优值。</p>
<a id="more"></a>
<h4 id="设计动态规划算法的步骤"><a href="#设计动态规划算法的步骤" class="headerlink" title="设计动态规划算法的步骤"></a>设计动态规划算法的步骤</h4><p>我们通常按如下4个步骤来设计一个动态规划算法：</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
<p>步骤1~3是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4.如果确实要做步骤4，有时就需要步骤3的过程中维护一些额外信息，以便用来构造一个最优解。</p>
<h4 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h4><p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">leetcode 583. Delete Operation for Two Strings</a></p>
<p>基本解法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二维数组可用 一位数组 + 临时一位数组 替换掉</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = word1.charAt(<span class="number">0</span>) == word2.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span> || word1.charAt(i) == word2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][j - <span class="number">1</span>] == <span class="number">1</span> || word1.charAt(<span class="number">0</span>) == word2.charAt(j)) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 此处赋值语句可优化</span></span><br><span class="line">                <span class="comment">// dp[i - 1][j - 1] + 1 &gt;=  Math.max(dp[i - 1][j], dp[i][j - 1])</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(dp[i]));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len1 - dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>] + len2 - dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>优化解法：</p>
<ul>
<li>借用临时数组temp，将二维dp数组降维</li>
<li>优化赋值判断逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistanceDpQuick</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">       <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用一维数组</span></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">           <span class="comment">// 借用临时数组temp，将二维dp数组降维</span></span><br><span class="line">           <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">               <span class="comment">// 优化基本解法的 赋值逻辑</span></span><br><span class="line">               <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">                   temp[j + <span class="number">1</span>] = Math.max(temp[j + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   temp[j + <span class="number">1</span>] = Math.max(dp[j + <span class="number">1</span>], temp[j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           dp = temp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> len1 - dp[len2] + len2 - dp[len2];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h4><p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">leetcode 718. Maximum Length of Repeated Subarray</a></p>
<p>基本解法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] == B[i]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[<span class="number">0</span>][i] &gt; result) &#123;</span><br><span class="line">                    result = dp[<span class="number">0</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][<span class="number">0</span>] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(dp[i]));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>优化解法：使用倒序遍历的方式将一维数组降维<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthDpQuick</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l1 = A.length;</span><br><span class="line">       <span class="keyword">int</span> l2 = B.length;</span><br><span class="line">       <span class="keyword">if</span> (l1 == <span class="number">0</span> || l2 == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l2 + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = l2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                   dp[j + <span class="number">1</span>] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">if</span> (dp[j + <span class="number">1</span>] &gt; max) &#123;</span><br><span class="line">                       max = dp[j + <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   dp[j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之分治算法</title>
    <url>/2019/09/03/divide-conquer/</url>
    <content><![CDATA[<h4 id="分治法思想"><a href="#分治法思想" class="headerlink" title="分治法思想"></a>分治法思想</h4><p>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
<h4 id="分治模式在每层递归时都有三个步骤："><a href="#分治模式在每层递归时都有三个步骤：" class="headerlink" title="分治模式在每层递归时都有三个步骤："></a>分治模式在每层递归时都有三个步骤：</h4><ul>
<li><strong>分解</strong>原问题为若干个子问题，这些子问题是原问题规模较小的实例。</li>
<li><strong>解决</strong>这些子问题，递归地求解各子问题。然而，若子问题规模足够小，则直接求解。</li>
<li><strong>合并</strong>这些子问题的解成原问题的解。</li>
</ul>
<h4 id="归并排序中的分治模式"><a href="#归并排序中的分治模式" class="headerlink" title="归并排序中的分治模式"></a>归并排序中的分治模式</h4><ol>
<li><strong>分解</strong>：分解待排序的n个元素的序列成各具n/2各元素的两个子序列。</li>
<li><strong>解决</strong>：使用归并排序递归地排序两个子序列。</li>
<li><strong>合并</strong>：合并两个已排序的子序列以产生已排序的答案。</li>
</ol>
<a id="more"></a>
<p>我们用代码实现一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写一个归并排序-</span></span><br><span class="line"><span class="comment"> * 归并排序遵循 归并模式</span></span><br><span class="line"><span class="comment"> * 分解：将n个元素的数组分解为2个 n/2个元素的数组</span></span><br><span class="line"><span class="comment"> * 解决：分别对2个子数组排序</span></span><br><span class="line"><span class="comment"> * 合并：合并2个已经排序的子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将两个数组 合并 [min, mid] [mid+1, max]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">        array[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"排序前数组"</span> + Arrays.toString(array));</span><br><span class="line">    mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"排序后数组"</span> + Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h4><p>当一个算法包含对其自身的递归调用时，我们往往可以用<strong>递归方程</strong>或<strong>递归式</strong>来描述其运行时间，该方程根据在较小上的运行时间来描述在规模为n的问题上的总运行时间。</p>
<h4 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h4><p>给一个数组，找出一个具有最大和的连续子数组，返回最大和。</p>
<p> <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode 53. Maximum Subarray</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路</span></span><br><span class="line"><span class="comment"> * 分解：将数组分为2个 子数组</span></span><br><span class="line"><span class="comment"> * 解决：两个子数组的 最大和 可以直接求得， 包含中间点 的 最大和 经过特殊计算一下</span></span><br><span class="line"><span class="comment"> * 合并：返回两个子数组 最大和 中 最大的一个 或者 返回 包含中间点 的最大和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calcMaxSubarray(nums, <span class="number">0</span>, (nums.length - <span class="number">1</span>) / <span class="number">2</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算最大子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcMaxSubarray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left &gt;= right 跳出递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左面子数组 最大值</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = calcMaxSubarray(array, left, (left + mid) / <span class="number">2</span>, mid);</span><br><span class="line">    <span class="comment">// 右面子数组 最大值</span></span><br><span class="line">    <span class="keyword">int</span> rightMax = calcMaxSubarray(array, mid + <span class="number">1</span>, (mid + <span class="number">1</span> + right) / <span class="number">2</span>, right);</span><br><span class="line">    <span class="comment">// 包含中间点的 两个子数组 的最大值 初始值 设为 中点的值</span></span><br><span class="line">    <span class="keyword">int</span> midMax = array[mid], temp = midMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        temp += array[i];</span><br><span class="line">        midMax = Math.max(temp, midMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = midMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        temp += array[i];</span><br><span class="line">        midMax = Math.max(temp, midMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(midMax, Math.max(leftMax, rightMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式</title>
    <url>/2019/08/16/factory-method-pattern/</url>
    <content><![CDATA[<h3 id="什么是工厂方法模式"><a href="#什么是工厂方法模式" class="headerlink" title="什么是工厂方法模式"></a>什么是工厂方法模式</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/factory-method-pattern.png" alt></p>
<a id="more"></a>
<h3 id="工厂方法模式简单代码实现"><a href="#工厂方法模式简单代码实现" class="headerlink" title="工厂方法模式简单代码实现"></a>工厂方法模式简单代码实现</h3><h4 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:36:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 产品类的公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:37:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂类"><a href="#抽象工厂类" class="headerlink" title="抽象工厂类"></a>抽象工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:38:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体工厂类"><a href="#具体工厂类" class="headerlink" title="具体工厂类"></a>具体工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:40:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = (Product) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2019/08/14/proxy-pattern/</url>
    <content><![CDATA[<h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>代理模式（委托模式）就是：<strong>为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/proxy-pattern.png" alt></p>
<a id="more"></a>
<h3 id="代理模式简单代码实现"><a href="#代理模式简单代码实现" class="headerlink" title="代理模式简单代码实现"></a>代理模式简单代码实现</h3><p>代理主题接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:21:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的主题类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:21:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Real Subject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理主题类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:23:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造一个真实的主题对象</span></span><br><span class="line">        RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过真实主题对象构造一个代理对象</span></span><br><span class="line">        ProxySubject proxy = <span class="keyword">new</span> ProxySubject(real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理的相关方法</span></span><br><span class="line">        proxy.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h3><p>代理模式大致可以分为两大部分，一是静态代理，二是动态代理。</p>
<ul>
<li>静态代理：代理者的代码提前已经写好了，然后再对其进行编译。也就是说在代码运行前，class编译文件就已经存在。</li>
<li>与静态代理相反，代码执行前我们并不知道要代理谁，而是通过反射机制在运行时动态的生成代理者的对象。</li>
</ul>
<h3 id="Java中动态代理代码实现"><a href="#Java中动态代理代码实现" class="headerlink" title="Java中动态代理代码实现"></a>Java中动态代理代码实现</h3><p>实现InvocationHandler接口，重写invoke()方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:37:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(proxy, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java实现动态代理的代码"><a href="#Java实现动态代理的代码" class="headerlink" title="Java实现动态代理的代码"></a>Java实现动态代理的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:40:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造真实的对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个动态代理</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取真实对象的lassLoader</span></span><br><span class="line">        ClassLoader classLoader = realSubject.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态构造一个 代理对象</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, dynamicProxy);</span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2019/07/20/strategy-pattern/</url>
    <content><![CDATA[<h3 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h3><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以相互互换。</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/images/strategy-pattern.png" alt></p>
<a id="more"></a>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><h4 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:09:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="策略具体实现1"><a href="#策略具体实现1" class="headerlink" title="策略具体实现1"></a>策略具体实现1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:09:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"策略1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:10:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/2019/07/05/queue/</url>
    <content><![CDATA[<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>队列（queue）</strong>是一种线性集合，其元素从一端进入，从另一端删除。队列元素是按照<strong>先进先出（First In First Out, FIFO）</strong>方式处理的。从队列删除元素的次序，与往队列放置元素的次序是一样的。</p>
<h3 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/30 23:11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列末端添加一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列前端删除一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列最前端的元素，但不移出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果队列为空返回true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列中元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列字符串表示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="用链表实现队列"><a href="#用链表实现队列" class="headerlink" title="用链表实现队列"></a>用链表实现队列</h3><p><code>LinearNode&lt;T&gt;</code>是链表一个节点的实现，<a href="https://github.com/iisheng/java-algorithm/blob/master/src/main/java/cn/iisheng/common/LinearNode.java" target="_blank" rel="noopener">点击查看源码</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.iisheng.common.LinearNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/31 08:07:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearNode&lt;T&gt; head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        LinearNode&lt;T&gt; node = <span class="keyword">new</span> LinearNode(element);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.setNext(node);</span><br><span class="line">        &#125;</span><br><span class="line">        tail = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T result = head.getElement();</span><br><span class="line">        head = head.getNext();</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.getElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用数组实现队列"><a href="#用数组实现队列" class="headerlink" title="用数组实现队列"></a>用数组实现队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/09/02 21:39:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, rear, count;</span><br><span class="line">    <span class="keyword">private</span> T[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        front = rear = count = <span class="number">0</span>;</span><br><span class="line">        queue = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == queue.length) &#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue[rear] = element;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % queue.length;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T result = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % queue.length;</span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T[] larger = (T[]) <span class="keyword">new</span> Object[queue.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            larger[i] = queue[front];</span><br><span class="line">            front = (front + <span class="number">1</span>) % queue.length;</span><br><span class="line">        &#125;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = count;</span><br><span class="line">        queue = larger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层序遍历（level-order-travelsal）"><a href="#二叉树的层序遍历（level-order-travelsal）" class="headerlink" title="二叉树的层序遍历（level-order travelsal）"></a>二叉树的层序遍历（level-order travelsal）</h3><p>从根节点开始，访问每一层的所有节点，一次一层。</p>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode 102. Binary Tree Level Order Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentRes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 当前队列的大小就是上一层节点个数，依次出队</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode current = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currentRes.add(current.val);</span><br><span class="line">                <span class="comment">// 左子树和右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(current.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(current.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(currentRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之栈</title>
    <url>/2019/06/24/stack/</url>
    <content><![CDATA[<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>栈</strong>是一种线性集合，栈的元素是按照后进先出(LIFO)(Last in, first out)的方法进行处理的，最后进入栈中的元素最先被移出。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:17:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回且不移除栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果栈里面没有元素返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈中元素的总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个代表当前栈的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="用数组实现栈"><a href="#用数组实现栈" class="headerlink" title="用数组实现栈"></a>用数组实现栈</h3><p>栈的数组实现可以通过4个假设来设计：</p>
<ul>
<li>该数组是一个对象引用的数组（其数据类型在栈实例化的时候确定）</li>
<li>栈底总是在数组的索引0处</li>
<li>栈的元素是按照顺序并连续地存储在数组中</li>
<li>有一个整数变量top，该变量保存了紧跟栈顶元素后的数组索引号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:18:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素下一个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储栈元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认容量创建一个空栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        stack = (T[]) (<span class="keyword">new</span> Object[DEFAULT_CAPACITY]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用指定容量创建一个空栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        stack = (T[]) (<span class="keyword">new</span> Object[initialCapacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     * 确保 该数组不是满的</span></span><br><span class="line"><span class="comment">     * 把数组的top引用设置为要加入到栈中的对象</span></span><br><span class="line"><span class="comment">     * 增加top的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == stack.length) &#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        stack[top] = element;</span><br><span class="line">        top++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = Arrays.copyOf(stack, stack.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回栈顶元素</span></span><br><span class="line"><span class="comment">     * 确保 栈不为空</span></span><br><span class="line"><span class="comment">     * 减小top计数器</span></span><br><span class="line"><span class="comment">     * 设置一个临时引用等于stack[top]的元素</span></span><br><span class="line"><span class="comment">     * 设置stack[top]为空</span></span><br><span class="line"><span class="comment">     * 返回该临时引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">        T result = stack[top];</span><br><span class="line">        stack[top] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回且不移除栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果栈为空返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回代表栈的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表实现栈"><a href="#用链表实现栈" class="headerlink" title="用链表实现栈"></a>用链表实现栈</h3><p><code>LinearNode&lt;T&gt;</code>是链表一个节点的实现，<a href="https://github.com/iisheng/java-algorithm/blob/master/src/main/java/cn/iisheng/common/LinearNode.java" target="_blank" rel="noopener">点击查看源码</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.iisheng.common.LinearNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:32:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在栈中存储元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向栈顶的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinearNode&lt;T&gt; top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        top = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        LinearNode&lt;T&gt; temp = <span class="keyword">new</span> LinearNode&lt;&gt;(element);</span><br><span class="line"></span><br><span class="line">        temp.setNext(top);</span><br><span class="line">        top = temp;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T result = top.getElement();</span><br><span class="line">        top = top.getNext();</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.getElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈来计算后缀表达式"><a href="#使用栈来计算后缀表达式" class="headerlink" title="使用栈来计算后缀表达式"></a>使用栈来计算后缀表达式</h3><p><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">leetcode 224. Basic Calculator</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> operand = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// For the on-going result</span></span><br><span class="line">       <span class="keyword">int</span> sign = <span class="number">1</span>;  <span class="comment">// 1 means positive, -1 means negative</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Forming operand, since it could be more than one digit</span></span><br><span class="line">               operand = <span class="number">10</span> * operand + (<span class="keyword">int</span>) (ch - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Evaluate the expression to the left,</span></span><br><span class="line">               <span class="comment">// with result, sign, operand</span></span><br><span class="line">               result += sign * operand;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Save the recently encountered '+' sign</span></span><br><span class="line">               sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset operand</span></span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'-'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               result += sign * operand;</span><br><span class="line">               sign = -<span class="number">1</span>;</span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Push the result and sign on to the stack, for later</span></span><br><span class="line">               <span class="comment">// We push the result first, then sign</span></span><br><span class="line">               stack.push(result);</span><br><span class="line">               stack.push(sign);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset operand and result, as if new evaluation begins for the new sub-expression</span></span><br><span class="line">               sign = <span class="number">1</span>;</span><br><span class="line">               result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Evaluate the expression to the left</span></span><br><span class="line">               <span class="comment">// with result, sign and operand</span></span><br><span class="line">               result += sign * operand;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// ')' marks end of expression within a set of parenthesis</span></span><br><span class="line">               <span class="comment">// Its result is multiplied with sign on top of stack</span></span><br><span class="line">               <span class="comment">// as stack.pop() is the sign before the parenthesis</span></span><br><span class="line">               result *= stack.pop();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Then add to the next operand on the top.</span></span><br><span class="line">               <span class="comment">// as stack.pop() is the result calculated before this parenthesis</span></span><br><span class="line">               <span class="comment">// (operand on stack) + (sign on stack * (result from parenthesis))</span></span><br><span class="line">               result += stack.pop();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset the operand</span></span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result + (sign * operand);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈来遍历树"><a href="#使用栈来遍历树" class="headerlink" title="使用栈来遍历树"></a>使用栈来遍历树</h3><h4 id="二叉树的前序遍历（preorder-travelsal）"><a href="#二叉树的前序遍历（preorder-travelsal）" class="headerlink" title="二叉树的前序遍历（preorder travelsal）"></a>二叉树的前序遍历（preorder travelsal）</h4><p>从根节点开始，访问每一个节点及其孩子。（根 -&gt; 左 -&gt; 右）</p>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">leetcode 144. Binary Tree Preorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">       <span class="comment">// 根节点 最先入栈</span></span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           <span class="comment">// 遍历 根节点</span></span><br><span class="line">           result.add(root.val);</span><br><span class="line">           <span class="comment">// 右节点先入栈 后遍历</span></span><br><span class="line">           <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左节点后入栈 先遍历</span></span><br><span class="line">           <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的中序遍历（inorder-travelsal）"><a href="#二叉树的中序遍历（inorder-travelsal）" class="headerlink" title="二叉树的中序遍历（inorder travelsal）"></a>二叉树的中序遍历（inorder travelsal）</h4><p>从根节点开始，访问节点的左孩子，然后是该节点，再然后是任何剩余节点。（左 -&gt; 根 -&gt; 右）</p>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">leetcode 94. Binary Tree Inorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversalWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 根先进 左孩子后进 左孩子先出 根后出</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            <span class="comment">// 根 出  右孩子 进</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的后序遍历（inorder-travelsal）"><a href="#二叉树的后序遍历（inorder-travelsal）" class="headerlink" title="二叉树的后序遍历（inorder travelsal）"></a>二叉树的后序遍历（inorder travelsal）</h4><p>从根节点开始，访问节点的孩子，然后是该节点。（左 -&gt; 右 -&gt; 根）</p>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">leetcode 145. Binary Tree Postorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversalWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">      <span class="comment">// 根先进</span></span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          <span class="comment">// 插在list第0位</span></span><br><span class="line">          result.add(<span class="number">0</span>, root.val);</span><br><span class="line">          <span class="comment">// 左孩子 先进 后出 最后插在 第0位</span></span><br><span class="line">          <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(root.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 右孩子 后进 先出 先插在第0位</span></span><br><span class="line">          <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(root.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈计算直方图最大面积"><a href="#使用栈计算直方图最大面积" class="headerlink" title="使用栈计算直方图最大面积"></a>使用栈计算直方图最大面积</h3><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">leetcode 84. Largest Rectangle in Histogram</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> maxArea = <span class="number">0</span>, n = heights.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; heights[st.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">               <span class="keyword">int</span> area = heights[st.pop()] * (st.isEmpty() ? i : i - st.peek() - <span class="number">1</span>);</span><br><span class="line">               maxArea = Math.max(maxArea, area);</span><br><span class="line">           &#125;</span><br><span class="line">           st.push(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> area = heights[st.pop()] * (st.isEmpty() ? n : n - st.peek() - <span class="number">1</span>);</span><br><span class="line">           maxArea = Math.max(maxArea, area);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2019/06/18/singleton-pattern/</url>
    <content><![CDATA[<h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/singleton-pattern.png" alt></p>
<a id="more"></a>
<h3 id="普通单例模式代码"><a href="#普通单例模式代码" class="headerlink" title="普通单例模式代码"></a>普通单例模式代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 通过该方法获取实例对象</span></span><br><span class="line"><span class="comment">//    public static synchronized LazySingleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">//        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">//            singleton = new LazySingleton();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return singleton;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton singleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法总结</title>
    <url>/2019/05/13/sort/</url>
    <content><![CDATA[<h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><p>临近的数字两两进行比较，按照从小到大或者从大到小的顺序交换，这样一趟后，最大或者最小的数字被交换到最后一位。<br>然后再从头开始两两进行比较交换，直到排序完成。</p>
<p>　　交换数组中两个元素的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap=arr[i];</span><br><span class="line">	arr[i]=arr[j];</span><br><span class="line">	arr[j]=swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>冒泡排序算法代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">		swap(arr, j + <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3><p>直接从待选择排序数组里面选择一个最小（或者最大）的数字，与第一个位置的数交换。<br>然后再在剩下的数中选择最小（或者最大）的数字，与第二个位置的数字交换，如此循环到只剩下一个数字为止。</p>
<p>选择排序代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> min = arr[i];</span><br><span class="line">		<span class="keyword">int</span> min_index = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">				min = arr[j];</span><br><span class="line">				min_index = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, min_index, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><p>　　每一步将一个待排序数据按其大小插入到已经排序的数组中的适当位置，直到全部插入完毕。<br>　　插入排序代码实现：<br>　　<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">			arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h3><p>选择一个基本元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，另一部分大于或等于基准元素。<br>这一趟扫描结束后，该基准就处于序列的中间位置。然后再用同样的方法递归的排序划分这两部分。</p>
<p>快速排序代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	recursion(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">		recursion(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">		recursion(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 基数 在数组 中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</span><br><span class="line">			--high;</span><br><span class="line">		arr[low] = arr[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt; pivot)</span><br><span class="line">			++low;</span><br><span class="line">		arr[high] = arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UML九种图关系总结</title>
    <url>/2019/05/06/uml/</url>
    <content><![CDATA[<h3 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h3><p>UML是Unified Model Language的缩写，是一种建模语言。通过使用UML使得在软件开发之前，<br>对整个软件设计有更好的可读性，可理解性，从而降低开发风险。同时，也能方便各个开发人员之间的交流。</p>
<h3 id="UML九种图"><a href="#UML九种图" class="headerlink" title="UML九种图"></a>UML九种图</h3><p>如下图所示，UML图分为，用例图、静态图、交互图、行为图、实现图。静态图包括类图和对象图，<br>交互图包括序列图和协作图，行为图包括状态图和活动图，实现图包括构件图和部署图。</p>
<h4 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h4><pre><code>【概念】描述用户的需求，从用户的角度描述系统的功能
【描述方式】椭圆表示某个用例，人形符号表示角色
【目的】帮助开发团队以一种可视化的方式理解系统的功能需求
</code></pre><a id="more"></a>
<p><img src="/images/use-case-diagram.png" alt="image"></p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><pre><code>【概念】根据用例图抽象成类，描述类的内部结构和类与类之间的关系
【描述方式】矩形表示类或者接口，之间的关系使用箭头、三角形和虚线或者实线表示
【目的】显示系统的静态结构，表示不同的实体是如何关联的
 在UML关系中，常见的有一下几种关系。泛化（Generalization）,实现（Realization）,关联（Association）,聚合（Aggregation）,组合（Composition）,依赖（Dependency）
</code></pre><h5 id="【泛化关系】-是一种继承关系，表示子类继承父类的所有特征和行为。"><a href="#【泛化关系】-是一种继承关系，表示子类继承父类的所有特征和行为。" class="headerlink" title="【泛化关系】:是一种继承关系，表示子类继承父类的所有特征和行为。"></a>【泛化关系】:是一种继承关系，表示子类继承父类的所有特征和行为。</h5><h5 id="【箭头指向】-带三角箭头的实现线，箭头指向父类。"><a href="#【箭头指向】-带三角箭头的实现线，箭头指向父类。" class="headerlink" title="【箭头指向】:带三角箭头的实现线，箭头指向父类。"></a>【箭头指向】:带三角箭头的实现线，箭头指向父类。</h5><p><img src="/images/generalization.png" alt="image"></p>
<h5 id="【实现关系】-是一种类与接口的关系，表示类是接口所有特征和行为的实现。"><a href="#【实现关系】-是一种类与接口的关系，表示类是接口所有特征和行为的实现。" class="headerlink" title="【实现关系】:是一种类与接口的关系，表示类是接口所有特征和行为的实现。"></a>【实现关系】:是一种类与接口的关系，表示类是接口所有特征和行为的实现。</h5><h5 id="【箭头指向】-带三角箭头的虚线，箭头指向接口。"><a href="#【箭头指向】-带三角箭头的虚线，箭头指向接口。" class="headerlink" title="【箭头指向】:带三角箭头的虚线，箭头指向接口。"></a>【箭头指向】:带三角箭头的虚线，箭头指向接口。</h5><p><img src="/images/realization.png" alt="image"></p>
<h5 id="【关联关系】-是一种拥有关系，它使得一个类知道另一个类的属性和方法。"><a href="#【关联关系】-是一种拥有关系，它使得一个类知道另一个类的属性和方法。" class="headerlink" title="【关联关系】:是一种拥有关系，它使得一个类知道另一个类的属性和方法。"></a>【关联关系】:是一种拥有关系，它使得一个类知道另一个类的属性和方法。</h5><h5 id="【代码体现】-成员变量"><a href="#【代码体现】-成员变量" class="headerlink" title="【代码体现】:成员变量"></a>【代码体现】:成员变量</h5><h5 id="【箭头指向】-带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。"><a href="#【箭头指向】-带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。" class="headerlink" title="【箭头指向】:带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。"></a>【箭头指向】:带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。</h5><p><img src="/images/association.png" alt="image"></p>
<h5 id="【聚合关系】-是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关机。"><a href="#【聚合关系】-是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关机。" class="headerlink" title="【聚合关系】:是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关机。"></a>【聚合关系】:是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关机。</h5><h5 id="【代码体现】-成员变量-1"><a href="#【代码体现】-成员变量-1" class="headerlink" title="【代码体现】:成员变量"></a>【代码体现】:成员变量</h5><h5 id="【箭头指向】-带空心菱形和普通箭头的实线，空心菱形指向整体，普通箭头指向部分。"><a href="#【箭头指向】-带空心菱形和普通箭头的实线，空心菱形指向整体，普通箭头指向部分。" class="headerlink" title="【箭头指向】:带空心菱形和普通箭头的实线，空心菱形指向整体，普通箭头指向部分。"></a>【箭头指向】:带空心菱形和普通箭头的实线，空心菱形指向整体，普通箭头指向部分。</h5><p><img src="/images/aggregation.png" alt="image"></p>
<h5 id="【组合关系】-是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。"><a href="#【组合关系】-是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。" class="headerlink" title="【组合关系】:是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。"></a>【组合关系】:是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。</h5><h5 id="【代码体现】-成员变量-2"><a href="#【代码体现】-成员变量-2" class="headerlink" title="【代码体现】:成员变量"></a>【代码体现】:成员变量</h5><h5 id="【箭头指向】-带实心菱形和普通箭头的实线，实心菱形指向整体，普通箭头指向部分。"><a href="#【箭头指向】-带实心菱形和普通箭头的实线，实心菱形指向整体，普通箭头指向部分。" class="headerlink" title="【箭头指向】:带实心菱形和普通箭头的实线，实心菱形指向整体，普通箭头指向部分。"></a>【箭头指向】:带实心菱形和普通箭头的实线，实心菱形指向整体，普通箭头指向部分。</h5><p><img src="/images/composition.png" alt="image"></p>
<h5 id="【依赖关系】-是一种使用关系，即一个类的实现需要另一个类的协助。"><a href="#【依赖关系】-是一种使用关系，即一个类的实现需要另一个类的协助。" class="headerlink" title="【依赖关系】:是一种使用关系，即一个类的实现需要另一个类的协助。"></a>【依赖关系】:是一种使用关系，即一个类的实现需要另一个类的协助。</h5><h5 id="【箭头指向】-带普通箭头的虚线，普通箭头指向被使用者。"><a href="#【箭头指向】-带普通箭头的虚线，普通箭头指向被使用者。" class="headerlink" title="【箭头指向】:带普通箭头的虚线，普通箭头指向被使用者。"></a>【箭头指向】:带普通箭头的虚线，普通箭头指向被使用者。</h5><p><img src="/images/dependency.png" alt="image"></p>
<h4 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h4><pre><code>【概念】类图的一个实例，描述系统在具体时间点上所包含的对象以及各个对象之间的关系
【描述方式】由对象（Object）和链(Link)组成
【目的】显示系统的静态结构，表示不同的实例是如何关联的
</code></pre><p><img src="/images/object-diagram.png" alt="image"></p>
<h4 id="序列图-也叫-时序图-顺序图"><a href="#序列图-也叫-时序图-顺序图" class="headerlink" title="序列图 也叫 时序图 顺序图"></a>序列图 也叫 时序图 顺序图</h4><pre><code>【概念】描述对象之间的交互顺序，主要提现对象间消息传递的时间先后顺序（时间）
【描述方式】
【目的】显示流程中不同对象之间的调用关系
</code></pre><p><img src="/images/sequence-diagram.png" alt="image"></p>
<h4 id="协作图-也叫作通讯图"><a href="#协作图-也叫作通讯图" class="headerlink" title="协作图 也叫作通讯图"></a>协作图 也叫作通讯图</h4><pre><code>【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系（空间）
【描述方式】
【目的】显示空间中不同对象的调用关系
</code></pre><p><img src="/images/communication-diagram.png" alt="image"></p>
<h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><pre><code>【概念】描述对象的所有状态以及事件发生而引起的状态之间的转移
【描述方式】
【目的】表示某个类所处的不同状态以及该类在这些状态中的转换过程
</code></pre><p><img src="/images/state-machine-diagram.png" alt="iamge"></p>
<h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><pre><code>【概念】描述满足用例要求所要进行的活动以及活动时间的约束关系
【描述方式】表示两个或者多个对象之间在处理某个活动时的过程控制流程
【目的】
</code></pre><p><img src="/images/activity-diagram.png" alt="iamge"></p>
<h4 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h4><pre><code>【概念】描述代码构建的物理结构以及各结构之间的依赖关系
【描述方式】
【目的】提供系统的物理视图，根据系统的代码构建显示系统代码的整个物理结构
</code></pre><p><img src="/images/component-diagram.png" alt="iamge"></p>
<h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><pre><code>【概念】系统中硬件的物理体系结构
【描述方式】
【目的】显示系统的硬件和软件的物理结构
</code></pre><p><img src="/images/deployment-diagram.png" alt="iamge"></p>
]]></content>
      <categories>
        <category>🙄设计思想</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识</title>
    <url>/2019/04/29/redis/</url>
    <content><![CDATA[<h3 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h3><h4 id="Binary-safe-strings"><a href="#Binary-safe-strings" class="headerlink" title="Binary-safe strings"></a>Binary-safe strings</h4><p>string 类型是二进制安全的.意思是redis的string可以包含任意数据,比如jgp图片或者已经序列化的的对象.</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>实质是每一个都是string类型的双向链表,push和pop的命令算法的时间复杂度都是O(1),list还会记录链表的长度,所以llen操作也是O(1).</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>是string类型的无序集合.set是通过 hash table实现的,所以添加,查找,删除的复杂度都是O(1),hash table 会随着添加或者删除自动调整大小.</p>
<h4 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h4><p>sorted sets 也是string类型元素的集合,不同的是每个元素都会关联一个double类型的score,元素顺序有score决定.sorted sets的实现是skip list和hash table的混合体.</p>
<a id="more"></a>
<h4 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h4><p>是string类型的field和value的映射表.它的添加和删除都是O(1).hash特别适合用于存储对象</p>
<h4 id="Bit-arrays"><a href="#Bit-arrays" class="headerlink" title="Bit arrays"></a>Bit arrays</h4><p>可以用特殊的命令,处理string的value,像处理一个位数组一样</p>
<h4 id="HyperLogLogs"><a href="#HyperLogLogs" class="headerlink" title="HyperLogLogs"></a>HyperLogLogs</h4><p>它是一个概率数据库.(用于估算集合的基数)</p>
<h3 id="Redis-基本命令"><a href="#Redis-基本命令" class="headerlink" title="Redis 基本命令"></a>Redis 基本命令</h3><h4 id="操作string的命令"><a href="#操作string的命令" class="headerlink" title="操作string的命令"></a>操作string的命令</h4><ul>
<li>set key value</li>
<li>get key value</li>
<li>mset key1 value1 key2 value2</li>
<li><p>mget key1 key2</p>
</li>
<li><p>incr key 对值做加加,返回新的值(对不存在的key返回1,对非intkey会报错)</p>
</li>
<li>decr key 对值做减减,返回新的值(对不存在的key返回1,对非intkey会报错)</li>
<li>incrby key integer 加指定值(key不存在会认为,原来的value为0)</li>
<li>decrby key integer 减指定值(key不存在会认为,原来的value为0)</li>
<li>append key value 给指定key的字符串追加value</li>
<li>substr key start end 返回截取过的key的字符串值,注意并不修改key,下标从0开始,区间前闭后闭</li>
</ul>
<h4 id="操作list的命令"><a href="#操作list的命令" class="headerlink" title="操作list的命令"></a>操作list的命令</h4><ul>
<li>lpush key string 在key对应的头部添加字符串元素,返回1代表成功,返回0表示key存在且不是list类型</li>
<li>rpush key string 在key对应的尾部添加字符串元素,返回1代表成功</li>
<li>lpop key 从list的头部删除元素,并返回删除的元素,如果list不存在或为空返回nil,如果不是list返回错误</li>
<li>rpop key 同上,但是从尾部删除</li>
<li>llen key 返回key对应list的长度,key不存在返回0,如果key对应的不是list返回错误</li>
<li>lrange key start end 返回指定区间内的元素,下标从0开始,负值表示从后面计算,-1表示倒数第一个元素,key不存在返回空列表</li>
<li>ltrim key start end 截取list,保留指定区间内元素,成功返回1,key不存在返回错误</li>
<li>lset key index value 设置list中指定下标的元素值,成功返回1,key或者下标不存在返回错误</li>
<li>linsert key before value value2在值value前插入值value2</li>
</ul>
<h4 id="操作sets的命令"><a href="#操作sets的命令" class="headerlink" title="操作sets的命令"></a>操作sets的命令</h4><ul>
<li>saad key value 添加一个string元素到key对应的set集合,成功返回1,如果元素已经在元素中返回0,可以对应的set不存在返回错误</li>
<li>srem key value 从key对应set中移除给定元素,成功返回1,如果value在集合中不存在或者key不存在返回0,key对应的不是set类型返回错误</li>
<li>spop 删除并返回set中一个随机元素,如果set是空或者key不存在返回nil</li>
<li>srandommembe key 同 spop,但是不删除元素</li>
</ul>
<h4 id="操作sorted-sets的命令"><a href="#操作sorted-sets的命令" class="headerlink" title="操作sorted sets的命令"></a>操作sorted sets的命令</h4><ul>
<li>zadd key score member 添加元素到集合,当member已存在,更新score</li>
<li>zrem key member 删除指定元素,1表示成功,如果不成功返回0</li>
</ul>
<h4 id="操作hashes的命令"><a href="#操作hashes的命令" class="headerlink" title="操作hashes的命令"></a>操作hashes的命令</h4><ul>
<li>hset key field value 设置hash field 为指定值,如果key不存在则先创建</li>
<li>hget key field 获取指定hash的hash field</li>
</ul>
<h3 id="Redis高级特性"><a href="#Redis高级特性" class="headerlink" title="Redis高级特性"></a>Redis高级特性</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>设置redis密码,可以配置redis.conf也可以直接在redis-cli中设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config set requirepass ******</span><br></pre></td></tr></table></figure></p>
<p>查看redis是否设置密码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>Redis主从复制过程:</p>
<ul>
<li>slave和master建立连接,发送sync同步命令</li>
<li>master会启动一个后台线程,将数据库线程保存到文件中,同时master主线程会开始收集新的写命令缓存.</li>
<li>后台完成保存后,就将此文件发送给slave</li>
<li>slave将此文件保存到硬盘上</li>
</ul>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><ul>
<li><p>redis对事务的支持比较简单,redis只能保证一个client发起的事务中的命令可以连续执行,而中间不会插入其他的client命令.当一个client在发出multi命令时,这个连接会进入一个事务的上下文,连续后续命令不会立即执行,而是先放到一个队列中,当执行exec命令时,redis会顺序执行队列中的所有命令.</p>
</li>
<li><p>redis在事务中发生错误不会回滚.</p>
</li>
</ul>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>redis提供了一系列不同的持久化选项:</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照.</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存.</li>
</ul>
<h4 id="发布订阅消息"><a href="#发布订阅消息" class="headerlink" title="发布订阅消息"></a>发布订阅消息</h4><p>发布订阅（pub/sub）是一种消息通知模式，主要的目的是截除消息发布者和消息订阅者之间的耦合，Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道（channel）.当发布者通过publish命令向redis server发送特定类型的信息时，订阅该信息类型的全部client都会收到此消息.</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>Redis的虚拟内存与操作系统的虚拟内存不是一回事，但是思路和目的都是相同的.就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据.尤其是对于redis这样的内存数据库，内存总是不够用的.除了可以将数据分割到多个redis server外.另外能够提高数据库容量的办法就是使用虚拟内存把那些不经常访问的数据交换到磁盘上.</p>
<h3 id="Redis集成Spring-Boot"><a href="#Redis集成Spring-Boot" class="headerlink" title="Redis集成Spring Boot"></a>Redis集成Spring Boot</h3><p>pom文件添加redis依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- redis --&gt;  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>application.properties增加redis相关属性<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#redis  </span><br><span class="line">spring.redis.hostName=goodgoodstate.me</span><br><span class="line">spring.redis.port=<span class="number">6379</span>    </span><br><span class="line">spring.redis.password=xxx  </span><br><span class="line">spring.redis.pool.maxActive=<span class="number">8</span>    </span><br><span class="line">spring.redis.pool.maxWait=-<span class="number">1</span>    </span><br><span class="line">spring.redis.pool.maxIdle=<span class="number">8</span>    </span><br><span class="line">spring.redis.pool.minIdle=<span class="number">0</span>    </span><br><span class="line">spring.redis.timeout=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>配置类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value =&#123; StringRedisTemplate.class, RedisTemplate.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h3><p>设置Redis中String类型的键值对,600秒自动失效<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"key"</span>, <span class="string">"value"</span>, <span class="number">600</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p>
<p>获取Redis中String类型的value<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String value = (String) redisTemplate.opsForValue().get(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取操作Hash对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashOperations&lt;String, String, String&gt; hashOperations = redisTemplate.opsForHash();</span><br></pre></td></tr></table></figure></p>
<p>put一个map对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashOperations.putAll(key, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure></p>
<p>获取一个hash里面的maspKey对应的值<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String value = hashOperations.get(<span class="string">"key"</span>, <span class="string">"mapKey"</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>😏中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 语句学习总结</title>
    <url>/2019/04/22/mysql/</url>
    <content><![CDATA[<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>修改MySQL登录设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf  在最后加一句  skip-grant-tables</span><br></pre></td></tr></table></figure></p>
<p>重启MySQL<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt;update mysql.user set authentication_string=password(<span class="string">"新密码"</span>);</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>（1）第一范式（每列都保持原子性)<br>（2）第二范式（非主属性不部分依赖于候选码）<br>（3）第三范式（非主属性不传递依赖于候选码）<br>（4）BC范式（任何属性不部分依赖与候选码，不传递依赖与候选码）</p>
<h3 id="创建表SQL"><a href="#创建表SQL" class="headerlink" title="创建表SQL"></a>创建表SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">        <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">        <span class="string">`age`</span> <span class="built_in">INT</span> ,</span><br><span class="line">        PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="更新表中数据SQL"><a href="#更新表中数据SQL" class="headerlink" title="更新表中数据SQL"></a>更新表中数据SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> user.name = <span class="string">"lisheng"</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询表中数据的SQL"><a href="#查询表中数据的SQL" class="headerlink" title="查询表中数据的SQL"></a>查询表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name , user.age <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<h3 id="插入表中数据的SQL"><a href="#插入表中数据的SQL" class="headerlink" title="插入表中数据的SQL"></a>插入表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span> ,<span class="keyword">name</span> ,age) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"lisheng"</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name ,good.name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">join</span> good <span class="keyword">on</span> user.id = good.user_id;</span><br></pre></td></tr></table></figure>
<h3 id="删除表中数据的SQL"><a href="#删除表中数据的SQL" class="headerlink" title="删除表中数据的SQL"></a>删除表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p dbname &gt; dbname.sql   <span class="comment">// 在/usr/local/mysql/bin目录执行</span></span><br></pre></td></tr></table></figure>
<h3 id="导入sql数据库"><a href="#导入sql数据库" class="headerlink" title="导入sql数据库"></a>导入sql数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source /home/abc/abc.sql;  // 登录到数据库内执行</span><br></pre></td></tr></table></figure>
<h3 id="查看数据库表的编码格式"><a href="#查看数据库表的编码格式" class="headerlink" title="查看数据库表的编码格式"></a>查看数据库表的编码格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">table</span>-<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
<h3 id="设置字段默认值"><a href="#设置字段默认值" class="headerlink" title="设置字段默认值"></a>设置字段默认值</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ALTER</span>  <span class="keyword">COLUMN</span> <span class="keyword">name</span> <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="string">""</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字段"><a href="#修改表字段" class="headerlink" title="修改表字段"></a>修改表字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> address <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> city <span class="built_in">CHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h3 id="增加一个表的一个字段"><a href="#增加一个表的一个字段" class="headerlink" title="增加一个表的一个字段"></a>增加一个表的一个字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> wechat_auth <span class="keyword">ADD</span> user_id <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br></pre></td></tr></table></figure>
<h3 id="时间日期格式化"><a href="#时间日期格式化" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  DATE_FORMAT(t1.create_time,'%Y-%c-%d %h:%i:%s') </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 创建索引</span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tbl_name</span><br></pre></td></tr></table></figure>
<h3 id="导入cvs文件"><a href="#导入cvs文件" class="headerlink" title="导入cvs文件"></a>导入cvs文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> [<span class="keyword">TABLE</span>]；  </span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>   </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>   </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span>；</span><br></pre></td></tr></table></figure>
<h3 id="导出cvs文件"><a href="#导出cvs文件" class="headerlink" title="导出cvs文件"></a>导出cvs文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'[FILE]'</span>；  </span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>   </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>   </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span>；</span><br></pre></td></tr></table></figure>
<h3 id="查询指定字段重复的记录"><a href="#查询指定字段重复的记录" class="headerlink" title="查询指定字段重复的记录"></a>查询指定字段重复的记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> mobile <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(mobile)&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="当数据库中不存在该记录的时候插入"><a href="#当数据库中不存在该记录的时候插入" class="headerlink" title="当数据库中不存在该记录的时候插入"></a>当数据库中不存在该记录的时候插入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`table`</span> (value1, value2)</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">'stuff for value1'</span>,</span><br><span class="line">    <span class="string">'stuff for value2'</span></span><br><span class="line">  <span class="keyword">FROM</span> DUAL</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> *</span><br><span class="line">                   <span class="keyword">FROM</span> <span class="string">`table`</span></span><br><span class="line">                   <span class="keyword">WHERE</span> value1 = <span class="string">'stuff for value1'</span> <span class="keyword">AND</span> value2 = <span class="string">'stuff for value2'</span>)</span><br><span class="line">  <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>例子<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_test`</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">'isheng'</span></span><br><span class="line">  <span class="keyword">FROM</span> DUAL</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> *</span><br><span class="line">                   <span class="keyword">FROM</span> <span class="string">`t_test`</span></span><br><span class="line">                   <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'iisheng'</span>)</span><br><span class="line">  <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="给表中两个字段添加唯一性约束"><a href="#给表中两个字段添加唯一性约束" class="headerlink" title="给表中两个字段添加唯一性约束"></a>给表中两个字段添加唯一性约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> <span class="keyword">ADD</span> <span class="keyword">unique</span> <span class="keyword">unique</span>-<span class="keyword">name</span> (column1,column2);</span><br></pre></td></tr></table></figure>
<h3 id="删除唯一性约束"><a href="#删除唯一性约束" class="headerlink" title="删除唯一性约束"></a>删除唯一性约束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP KEY 约束名;</span><br></pre></td></tr></table></figure>
<h3 id="inner-join-和left-join区别"><a href="#inner-join-和left-join区别" class="headerlink" title="inner join 和left join区别"></a>inner join 和left join区别</h3><p>left join (左连接) 返回包括左表中所有记录和右表中连接字段相等的记录<br><br>right join (右连接) 返回包括右表中所有记录和左表中连接字段相等的记录<br><br>inner join (等值连接) 只返回两个表中连接字段相等的记录</p>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><ol>
<li>查询 seeker_job  去掉 seeker_job_suggest  关联</li>
<li>优化模糊查询 改用单 like% reverse函数建立反向索引</li>
<li>范围模糊查询 自增id优于uuid  使用count(1)也是自增id更好</li>
<li>在适当的地方添加索引   （MySQL仅能对索引最左边的前缀进行有效的查找）</li>
<li>where语句后面的顺序 以及 建立 索引的顺序  （最左前缀匹配原则）</li>
<li>（尽量选择区分度高的列作为索引。）( = 和 in 可以乱序)</li>
<li>（尽量扩展索引，少去新建索引）</li>
<li>不以通配符开头的sql语句 like “%aaa” ALL 全表扫描 like “aaaa%” range 索引</li>
<li>尽量避免 null值判断 应该使用 0 默认值的 方法</li>
<li>避免 select * </li>
<li>order by语句后面跟索引   排序的顺序 很重要 很重要</li>
<li>提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉</li>
<li>能用DISTINCT的就不用GROUP BY</li>
</ol>
<h3 id="查看编码"><a href="#查看编码" class="headerlink" title="查看编码"></a>查看编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">'%char%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看表编码"><a href="#查看表编码" class="headerlink" title="查看表编码"></a>查看表编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show create table &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">例：show create table user;</span><br></pre></td></tr></table></figure>
<h3 id="查看字段编码"><a href="#查看字段编码" class="headerlink" title="查看字段编码"></a>查看字段编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show full columns from &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">例： show full column from user;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库编码格式"><a href="#修改数据库编码格式" class="headerlink" title="修改数据库编码格式"></a>修改数据库编码格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter database &lt;数据库名&gt; character set utf8mb4;</span><br><span class="line">例：alter database db_user character set utf8mb4;</span><br></pre></td></tr></table></figure>
<h3 id="修改表编码"><a href="#修改表编码" class="headerlink" title="修改表编码"></a>修改表编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table &lt;表名&gt; character set utf8mb4;</span><br><span class="line">例：alter table user character set utf8mb4;</span><br></pre></td></tr></table></figure>
<h3 id="修改字段编码"><a href="#修改字段编码" class="headerlink" title="修改字段编码"></a>修改字段编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; MODIFY COLUMN &lt;字段名&gt; &lt;字段类型&gt; CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line">例：<span class="function">ALTER TABLE comment MODIFY COLUMN content <span class="title">VARCHAR</span><span class="params">(<span class="number">512</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询sql不走缓存"><a href="#查询sql不走缓存" class="headerlink" title="查询sql不走缓存"></a>查询sql不走缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM users;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字符集和校对集"><a href="#修改表字符集和校对集" class="headerlink" title="修改表字符集和校对集"></a>修改表字符集和校对集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER  TABLE user</span><br><span class="line">CHARACTER SET utf8mb4</span><br><span class="line">COLLATE utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库字符集和校对集"><a href="#修改数据库字符集和校对集" class="headerlink" title="修改数据库字符集和校对集"></a>修改数据库字符集和校对集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE mydata</span><br><span class="line">CHARACTER SET utf8mb4</span><br><span class="line">COLLATE utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字段相关信息"><a href="#修改表字段相关信息" class="headerlink" title="修改表字段相关信息"></a>修改表字段相关信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `job_auth_record` CHANGE `id` `id` VARCHAR(<span class="number">32</span>) CHARACTER SET utf8mb4 NOT NULL COMMENT <span class="string">'主键id'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Mysql-ASC-和-DESC-索引-怎么走的-？？？"><a href="#Mysql-ASC-和-DESC-索引-怎么走的-？？？" class="headerlink" title="Mysql ASC 和 DESC 索引 怎么走的 ？？？"></a>Mysql ASC 和 DESC 索引 怎么走的 ？？？</h3><h3 id="分组差查询数量-超级吊"><a href="#分组差查询数量-超级吊" class="headerlink" title="分组差查询数量  超级吊"></a>分组差查询数量  超级吊</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  company_id,</span><br><span class="line">  count(*) AS counts</span><br><span class="line">FROM seeker_job</span><br><span class="line"><span class="function">WHERE company_id <span class="title">IN</span> <span class="params">(<span class="string">"8a9c889c5dcbe37c015dcf16e284001f"</span>, <span class="string">"04be17537c5e4b299c135eeaadb5e131"</span>)</span></span></span><br><span class="line"><span class="function">GROUP BY company_id</span>;</span><br></pre></td></tr></table></figure>
<h3 id="修改校验集"><a href="#修改校验集" class="headerlink" title="修改校验集"></a>修改校验集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE insurance_insured CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER  TABLE insurance_insured CHARACTER SET utf8mb4;</span><br><span class="line"></span><br><span class="line">ALTER TABLE `insurance_insured` CHANGE `name` `name`  varchar(<span class="number">64</span>) COLLATE utf8mb4_general_ci DEFAULT NULL;</span><br></pre></td></tr></table></figure>
<h3 id="忽略某个索引"><a href="#忽略某个索引" class="headerlink" title="忽略某个索引"></a>忽略某个索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * <span class="function">FROM seeker_job IGNORE <span class="title">INDEX</span><span class="params">(idx_modify_time)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="DISTINCT-COUNT"><a href="#DISTINCT-COUNT" class="headerlink" title="DISTINCT COUNT"></a>DISTINCT COUNT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT  <span class="title">count</span><span class="params">(DISTINCT j1.job_id,j1.agent_company_id)</span></span></span><br><span class="line"><span class="function">FROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id </span>= j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ;</span><br></pre></td></tr></table></figure>
<h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT  DISTINCT j1.job_id,j1.agent_company_id</span><br><span class="line">FROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id = j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ;</span><br></pre></td></tr></table></figure>
<h4 id="查找重复字段记录"><a href="#查找重复字段记录" class="headerlink" title="查找重复字段记录"></a>查找重复字段记录</h4><p><a href="https://www.cnblogs.com/jiangxiaobo/p/6589541.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxiaobo/p/6589541.html</a></p>
<h3 id="修改表编码个字符集"><a href="#修改表编码个字符集" class="headerlink" title="修改表编码个字符集"></a>修改表编码个字符集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ALTER  TABLE apply_stencil CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="function">ALTER TABLE apply_stencil MODIFY COLUMN id <span class="title">VARCHAR</span><span class="params">(<span class="number">32</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ALTER TABLE apply_stencil MODIFY COLUMN apply_id <span class="title">VARCHAR</span><span class="params">(<span class="number">32</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询一个库里面有多少表"><a href="#查询一个库里面有多少表" class="headerlink" title="查询一个库里面有多少表"></a>查询一个库里面有多少表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(*)</span> TABLES, table_schema FROM information_schema.TABLES  WHERE table_schema </span>= <span class="string">'goabroad'</span></span><br></pre></td></tr></table></figure>
<h3 id="时间相关格式化函数"><a href="#时间相关格式化函数" class="headerlink" title="时间相关格式化函数"></a>时间相关格式化函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create_time时间格式</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%u'</span>)</span> weeks,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY weeks</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%m%d'</span>)</span> days,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY days</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%m'</span>)</span> months,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY months</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">create_time时间戳格式</span></span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%u'</span>)</span> weeks,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY weeks</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%m%d'</span>)</span> days,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY days</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%m'</span>)</span> months,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY months</span></span><br></pre></td></tr></table></figure>
<h3 id="回收表"><a href="#回收表" class="headerlink" title="回收表"></a>回收表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table name engine=innodb</span><br></pre></td></tr></table></figure>
<h3 id="left-和-length-函数"><a href="#left-和-length-函数" class="headerlink" title="left() 和 length()函数"></a>left() 和 length()函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UPDATE seeker_job SET country_id = left(country_id,<span class="number">6</span>) <span class="function">WHERE <span class="title">length</span><span class="params">(country_id)</span> &gt; 6</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看mysql版本号"><a href="#查看mysql版本号" class="headerlink" title="查看mysql版本号"></a>查看mysql版本号</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">version</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😶数据库</category>
      </categories>
      <tags>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习</title>
    <url>/2019/04/15/vim/</url>
    <content><![CDATA[<h4 id="Vim学习笔记"><a href="#Vim学习笔记" class="headerlink" title="Vim学习笔记"></a>Vim学习笔记</h4><h4 id="Vim三种模式"><a href="#Vim三种模式" class="headerlink" title="Vim三种模式"></a>Vim三种模式</h4><p>基本上vi分为三种模式，分别是一般模式、编辑模式与命令行模式</p>
<h5 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h5><p>打开一个文件默认就进入到一般模式（这是默认的模式）。在这个模式中你可以使用上下左右了来移动光标，你可以删除字符或者删除整行，也可以复制粘贴你的文件数据。</p>
<h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><p>在vi一般模式下，不能进行编辑。等到按下a、s、i、o、c之后，就会进入编辑模式。左下方会出现INSERT或REPLAC的字样，此时才可以进行编辑。若想要退出编辑模式，需要按ESC。</p>
<h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><p>在一般模式中输入，“:、/、？”3个中的任何一个按钮，就可以将光标移动到最下面那一行。</p>
<a id="more"></a>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hjkl 左下上右</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctrl+f  pagedown 向下翻页</span><br><span class="line">ctrl+b  pageup 向上翻页</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  home  移动到当前行最前</span><br><span class="line">n 空格  移动n个字符</span><br><span class="line">$  end  移动到当前行最后</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G 移动到文件最末行</span><br><span class="line">nG 移动到第n行</span><br><span class="line">gg 首行</span><br><span class="line">n+enter  向下移动n行</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">:n1,n2s/word1/word2/g     在n1到n2之间找到word1，并将wor1替换为word2</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/g       在第一行到最后一行查找word1，并替换为word2</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x,X     x向前删除   X向后删除</span><br><span class="line">nx      n为数字     连续向后删除n个字符</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dd 删除光标所在的整行</span><br><span class="line">ndd 删除所在的向下的几行</span><br><span class="line">d1G 删除光标所在到第一行的所有数据</span><br><span class="line">dg  删除从光标所在到最后一行的所有数据</span><br><span class="line">d$  删除从光标所在处到该行的最后一个字符</span><br><span class="line">d0  删除从光标所在出到该行的最前面一个字符</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yy  复制光标所在的那一行</span><br><span class="line">nyy  复制光标所在的向下n行</span><br><span class="line">p,P   p将已复制的数据在光标下一行粘贴，P将已复制的数据在光标上一行粘贴</span><br><span class="line">y1G   复制光标所在行到第一行的所有数据</span><br><span class="line">yG   复制光标所在行到最后一行的所有数据</span><br><span class="line">y0   复制光标所在的那个字符到该行行首的所有数据</span><br><span class="line">y$   复制光标所在的那个字符到该行行尾的所有数据</span><br></pre></td></tr></table></figure>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常规模式  /   进行搜索</span><br><span class="line">u撤销刚才得到动作</span><br><span class="line">ctrl+r是撤销刚才撤销的动作</span><br><span class="line">ctrl+u 删除当前行</span><br><span class="line">yy复制当前行</span><br><span class="line">dd删除当前行</span><br><span class="line">p粘贴</span><br><span class="line">u撤销</span><br><span class="line">查找 </span><br><span class="line">/pattern  往后查找</span><br><span class="line">?pattern  向前查找</span><br><span class="line">n下一个</span><br><span class="line">N上一个</span><br><span class="line">ggVG 全选 gg到起始行</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL工具学习</title>
    <url>/2019/04/08/curl/</url>
    <content><![CDATA[<h3 id="CURL是什么"><a href="#CURL是什么" class="headerlink" title="CURL是什么"></a>CURL是什么</h3><p>CURL (Command Line URL viewer)是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在“标准输出”（stdout）上面。</p>
<h4 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h4><p>直接在curl后面加上网址，就可以看到网页源码。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span><br><span class="line">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果要保存这个网页，可以使用 -o 参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -o fileName iisheng.cn</span><br></pre></td></tr></table></figure></p>
<h4 id="自动跳转"><a href="#自动跳转" class="headerlink" title="自动跳转"></a>自动跳转</h4><p>有的网页是自动跳转的。使用 -L 参数，curl就会跳转到新的网址。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -L iisheng.cn</span><br></pre></td></tr></table></figure></p>
<p>键入上面命令，就会直接跳转到<a href="https://iisheng.cn">https://iisheng.cn</a></p>
<h4 id="显示头信息"><a href="#显示头信息" class="headerlink" title="显示头信息"></a>显示头信息</h4><p>-i 参数可以显示http response 的头信息，连同网页代码一起。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -i iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line">Server: Tengine</span><br><span class="line">Date: Sat, <span class="number">13</span> Apr <span class="number">2019</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">26</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">278</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https:<span class="comment">//iisheng.cn/</span></span><br><span class="line">Via: kunlun8.cn314[,<span class="number">0</span>]</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: ca6cf99c15551457264052744e</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span><br><span class="line">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="显示通信过程"><a href="#显示通信过程" class="headerlink" title="显示通信过程"></a>显示通信过程</h4><p>-v 参数可以显一次http通信的整个过程，包括端口连接和http request 头信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -v iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Rebuilt URL to: iisheng.cn/</span><br><span class="line">*   Trying <span class="number">202.108</span>.249.197...</span><br><span class="line">* Connected to iisheng.cn (202.108.249.197) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: iisheng.cn</span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.47</span>.0</span><br><span class="line">&gt; Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&lt; HTTP/1.1 301 Moved Permanently</span></span><br><span class="line"><span class="comment">&lt; Server: Tengine</span></span><br><span class="line"><span class="comment">&lt; Date: Sat, 13 Apr 2019 08:57:09 GMT</span></span><br><span class="line"><span class="comment">&lt; Content-Type: text/html</span></span><br><span class="line"><span class="comment">&lt; Content-Length: 278</span></span><br><span class="line"><span class="comment">&lt; Connection: keep-alive</span></span><br><span class="line"><span class="comment">&lt; Location: https://iisheng.cn/</span></span><br><span class="line"><span class="comment">&lt; Via: kunlun8.cn314[,0]</span></span><br><span class="line"><span class="comment">&lt; Timing-Allow-Origin: *</span></span><br><span class="line"><span class="comment">&lt; EagleId: ca6cf99c15551458295975589e</span></span><br><span class="line"><span class="comment">&lt; </span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body bgcolor="white"&gt;</span></span><br><span class="line"><span class="comment">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">* Connection #0 to host iisheng.cn left intact</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上面的信息还不够，可以使用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --trace output.txt</span><br></pre></td></tr></table></figure></p>
<p>运行后，打开output.txt 查看</p>
<h4 id="发送表单信息"><a href="#发送表单信息" class="headerlink" title="发送表单信息"></a>发送表单信息</h4><p>GET请求<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure></p>
<p>POST请求<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST --data <span class="string">"data=xxx"</span> example.com/form.cgi</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h4><p>curl默认动词是GET，使用 -X 参数 可以支持其他参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT iisheng.cn</span><br></pre></td></tr></table></figure>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -T file.txt url</span><br></pre></td></tr></table></figure>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --referer http:<span class="comment">//www.example.com http://www.example.com</span></span><br></pre></td></tr></table></figure>
<h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User Agent"></a>User Agent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --user-agent <span class="string">"[User Agent]"</span> [URL]</span><br></pre></td></tr></table></figure>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --cookie <span class="string">"name=xxx"</span> www.example.com</span><br></pre></td></tr></table></figure>
<h3 id="增加头信息"><a href="#增加头信息" class="headerlink" title="增加头信息"></a>增加头信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --header <span class="string">"Content-Type:application/json"</span> http:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title>RestFul API设计指南</title>
    <url>/2019/04/01/restful/</url>
    <content><![CDATA[<h3 id="RESTful是什么"><a href="#RESTful是什么" class="headerlink" title="RESTful是什么"></a>RESTful是什么</h3><p>REST（Representational State Transfe）是一种架构风格，遵循REST原则的架构我们就称为RESTful架构。Representational State Transfe 直译过来就是【表现层状态转化】，其实它省略了主语，表现层指的是【资源】的表现层，通俗的讲就是：资源在网络中以某种形式进行状态转移。</p>
<h3 id="为什么要用RESTful"><a href="#为什么要用RESTful" class="headerlink" title="为什么要用RESTful"></a>为什么要用RESTful</h3><p>RESTful 给人的感觉是优雅、规范、易懂，一个结构清晰、易于理解的API完全可以省略许多无意义的沟通和文档。大家都使用相同的标准，有利于团队的整体效率。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>一般接口就是增删改查，RESTful API就像通用的模板，我们以文章（Article）举例，那么基础的URL就有一下几种：</p>
<ul>
<li><code>GET /articles:</code> 文章列表</li>
<li><code>GET /articles/id:</code> 文章详情</li>
<li><code>POST /articles:</code> 创建文章</li>
<li><code>PUT /articles/id:</code> 修改文章</li>
<li><code>DELETE /articles/id:</code> 删除文章</li>
</ul>
<p>RESTful 中使用GET、POST、PUT和DELETE来分别表示资源的查询、创建、更新和删除，并且除了POST其他三种都具备幂等性（多次请求效果相同），POST和PUT最大的区别就是幂等性，所以PUT也可以用于创建，只要在创建前就确定好资源的id。</p>
<a id="more"></a>
<p>将id放到URL中而不是Query Param的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的URL应该是这样的：</p>
<ul>
<li><code>GET /articles/aid/comments:</code> 某篇文章的评论列表</li>
<li><code>GET /comments/cid:</code> 获取某文章的某评论详情</li>
<li><code>POST /articles/aid/comments:</code> 在某篇文章中创建评论</li>
<li><code>PUT /comments/cid:</code> 修改评论</li>
<li><code>PUT /comments/cid:</code> 删除评论</li>
</ul>
<p>这里有一点比较特殊，永远去使用可以指向资源的最短URL路径，也就是说既然<code>/comments/cid:</code>已经可以指向一条评论了，就不需要<code>/articles/id/comments/cid:</code>特意的指出所属的文章了。</p>
<ul>
<li><code>GET /articles/id/like:</code> 查看文章是否被点赞</li>
<li><code>PUT /articles/id/like:</code> 点赞文章</li>
<li><code>DELETE /articles/id/like:</code> 取消点赞</li>
</ul>
<h3 id="接口版本"><a href="#接口版本" class="headerlink" title="接口版本"></a>接口版本</h3><p>随着业务的调整，可能老接口不能再满足业务需求。这个时候我们尽可能加字段，或者新加接口。例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">api.github.com/v1/users</span><br></pre></td></tr></table></figure></p>
<h3 id="Token和Sign"><a href="#Token和Sign" class="headerlink" title="Token和Sign"></a>Token和Sign</h3><p>API需要设计成无状态的，所以客户端在某些请求中需要带上token或者sign。</p>
<ul>
<li>Token 用于监听请求所属用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或者重置TOKEN生存时间（类似于缓存的机制），另一种是TOKEN的生存时长固定不变。</li>
<li>Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后加密作为Sign传给服务端，这样即使被抓包了，对方修改参数而无法生成对应Sign也会被识破。</li>
</ul>
<h3 id="业务参数"><a href="#业务参数" class="headerlink" title="业务参数"></a>业务参数</h3><p>搜索<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?query=iisheng</span><br></pre></td></tr></table></figure></p>
<p>过滤<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?gender=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="统计参数"><a href="#统计参数" class="headerlink" title="统计参数"></a>统计参数</h3><p>这个一般可能的实现方案，是在行为接口后面添加参数像，业务参数一样，还有一种实现方案是单独写一个接口，只做统计用，我感觉这种方式更好一些。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?offset=<span class="number">10</span>&amp;limit=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/articles/?cursor=<span class="number">2015</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">15</span>:<span class="number">20</span>:<span class="number">30</span>&amp;limit=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?page=<span class="number">2</span>&amp;pre_page=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h3><ol>
<li>Json比Xml可视化更好，也更省流量所以尽量使用Json。</li>
<li>创建和修改成功后需要返回该资源的全部信息。</li>
<li>返回数据不需要和客户端界面耦合。不要在API设计的时候就考虑少返回几个字段，少一次查询（比如用join）能带来多大性能提升。一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回。而是让客户端分别请求多个接口（也可以使用一个单独的服务（API网关），内部RPC调用基础服务，构造客户端需要的数据，返回给客户端，这样，客户端可以只调用少量接口）</li>
</ol>
]]></content>
      <categories>
        <category>🙄设计思想</category>
      </categories>
      <tags>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet源码解析</title>
    <url>/2019/03/25/servlet/</url>
    <content><![CDATA[<h3 id="一个简单的Servlet请求"><a href="#一个简单的Servlet请求" class="headerlink" title="一个简单的Servlet请求"></a>一个简单的Servlet请求</h3><ol>
<li>新建HelloController继承HttpServlet</li>
<li>在web.xml中，注册HelloController，或者使用@WebServlet注解注册HelloController</li>
<li>重写doGet()，doPost()或者其他doXxx()方法</li>
</ol>
<h3 id="Servlet请求参数"><a href="#Servlet请求参数" class="headerlink" title="Servlet请求参数"></a>Servlet请求参数</h3><p>HttpServletRequest和HttpServletResponse是doXxx()方法的默认参数。</p>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest代表浏览器发送给服务器的请求报文。该对象由web服务器创建（如Tomcat），最终作为参数传递到doXxx()或者其他方法中，我们可以在doXxx()方法中直接使用</p>
<ol>
<li><p>获取用户发送的请求参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParmater(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取项目的名字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getContextPath();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>作为一个域对象，在不同的web资源之间共享数据。</li>
<li>请求和转发<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"target.html"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>HttpServletResponse代表服务器发送给浏览器的响应报文。该对象由web服务器创建（如Tomcat），最终将作为参数传递到doXxx()方法中，我们可以在doXxx()方法中直接使用。</p>
<ol>
<li><p>响应给浏览器一个网页或者Json数据等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter printWriter = response.getWriter();</span><br><span class="line">printWriter.writer(Hello Servlet~);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求的重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"target.html"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">转发</th>
<th style="text-align:right">重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求的次数</td>
<td style="text-align:center">1</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td>发生的位置</td>
<td style="text-align:center">服务器内部</td>
<td style="text-align:right">浏览器</td>
</tr>
<tr>
<td>浏览器地址</td>
<td style="text-align:center">不改变</td>
<td style="text-align:right">改变</td>
</tr>
</tbody>
</table>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>通过实现Filter接口，完成我们自定义的过滤器功能。过滤器有以下功能：</p>
<ol>
<li>HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest</li>
<li>根据需要检查HttpServletRequest，也可以修改HttpServletRequest的头和数据</li>
<li>在HttpservletResponse到达客户端之前，拦截HttpServletResponse</li>
<li>根据需要检查HttpServletResponse，也可以修改HttpServletReponse的头和数据</li>
</ol>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器可以监听客户端的请求，服务端的操作，通过监听自动激发一些操作。监听器主要有以下几种：</p>
<ol>
<li>ServletContextListener:对应所有用户</li>
<li>ServletSessionListener:对应于一个用户</li>
<li>ServletRequestListener:对应用一个请求<br>我们可以实现上面的接口，去完成监听事件。</li>
</ol>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ol>
<li>通过调用init()方法初始化Servlet实例</li>
<li>调用service()方法处理请求</li>
<li>调用相应的请求方式的方法比如post请求，调用doPost()方法</li>
<li>停止服务的时候，调用destroy()方法</li>
</ol>
<h3 id="HttpServlet类图关系"><a href="#HttpServlet类图关系" class="headerlink" title="HttpServlet类图关系"></a>HttpServlet类图关系</h3><p><img src="/images/servlet-class-diagram.png" alt="image"></p>
<h3 id="Servlet工作流程"><a href="#Servlet工作流程" class="headerlink" title="Servlet工作流程"></a>Servlet工作流程</h3><p><img src="/images/http-request-sequence-diagram.png" alt="image"></p>
<ol>
<li>浏览器发出Http请求到Servlet容器</li>
<li>Servlet容器生成HttpServletRequest和HttpServletResponse</li>
<li>Servlet将HttpServletRequest和HttpServletResponse参数传递给Filter,Filter处理过滤请求</li>
<li>Filter将HttpServletRequest和HttpServletResponse传递给Servlet,Servlet处理请求</li>
<li>Servlet处理完请求后,将数据返回给Filter,Filter返回给Servlet容器,Servlet容器再返回给浏览器</li>
</ol>
]]></content>
      <categories>
        <category>😤源码</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK源码解析之ArrayList</title>
    <url>/2019/03/18/arraylist/</url>
    <content><![CDATA[<p>JDK版本 JDK 8</p>
<h3 id="ArrayList类图"><a href="#ArrayList类图" class="headerlink" title="ArrayList类图"></a>ArrayList类图</h3><p>ArrayList继承AbstractList，实现了List，Collection接口。</p>
<p><img src="/images/arraylist-class-diagram.png" alt></p>
<a id="more"></a>
<h3 id="ArrayList属性以及方法图"><a href="#ArrayList属性以及方法图" class="headerlink" title="ArrayList属性以及方法图"></a>ArrayList属性以及方法图</h3><p><img src="/images/arraylist.png" alt></p>
<h3 id="ArrayList属性字段介绍"><a href="#ArrayList属性字段介绍" class="headerlink" title="ArrayList属性字段介绍"></a>ArrayList属性字段介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">long</span> serialVersionUID  <span class="comment">// 序列化UID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DEFAULT_CAPACITY  <span class="comment">// 默认容量</span></span><br><span class="line"></span><br><span class="line">Object[] EMPTY_ELEMENTDATA  <span class="comment">// 空数组,空的实例对象共享该空数组</span></span><br><span class="line"></span><br><span class="line">DEFAULTCObject[] APACITY_EMPTY_ELEMENTDATA  <span class="comment">// 对于空的默认size的实例对象,共享DEFAULTCAPACITY_EMPTY_ELEMENTDATA该空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size   <span class="comment">// 数组元素size(它包含的元素的数量)</span></span><br></pre></td></tr></table></figure>
<h3 id="ArrayList方法介绍"><a href="#ArrayList方法介绍" class="headerlink" title="ArrayList方法介绍"></a>ArrayList方法介绍</h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li>public ArrayList(int initialCapacity) // 带默认容量参数的构造方法</li>
<li>public ArrayList() // 无参构造方法</li>
<li>public ArrayList(Collection&lt;? extends E&gt; c) // 参数是一个Collection的构造方法</li>
</ol>
<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加ArrayList实例的容量</span></span><br><span class="line"><span class="comment"> * 确保至少能装下参数值的数量的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if real element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for empty table. It's already supposed to be</span></span><br><span class="line">        <span class="comment">// at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量确保至少能装下参数值数量的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在list末尾添加新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在特定的位置插入新的元素</span></span><br><span class="line"><span class="comment"> * 将在右面位置的元素右移一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除特定位置的元素</span></span><br><span class="line"><span class="comment"> * 将在右面位置的元素左移一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除第一个出现的特定的元素值</span></span><br><span class="line"><span class="comment"> * 不存在返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="序列化方法"><a href="#序列化方法" class="headerlink" title="序列化方法"></a>序列化方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将ArrayLisy实例的状态保存到一个流里面</span></span><br><span class="line"><span class="comment"> * 就是序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照顺序写入所有的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一个流(参数)重新生成一个ArrayList</span></span><br><span class="line"><span class="comment"> * 就是反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h3><p>ArrayList是List接口可调整数组大小的实现。实现了所有的List操作，允许包括null在内的所有元素。ArrayList是非线程同步的。扩容是按照原来容量的1.5倍。ArrayList继承AbstractList，通过<br>modCount记录修改次数。</p>
]]></content>
      <categories>
        <category>😤源码</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch学习总结</title>
    <url>/2019/03/11/elasticsearch/</url>
    <content><![CDATA[<h3 id="ElasticSearch-基本概念"><a href="#ElasticSearch-基本概念" class="headerlink" title="ElasticSearch 基本概念"></a>ElasticSearch 基本概念</h3><h4 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h4><p>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是有一个名字标识。</p>
<h4 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h4><p>一个索引就是一个拥有几个相似特征的文档集合。索引由一个名字来标识（必须全部小写字母）。</p>
<h4 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h4><p>在一个索引中你可以定义一种或多种类型。一个类型是你逻辑上的分类/分区。</p>
<h4 id="文档（document）"><a href="#文档（document）" class="headerlink" title="文档（document）"></a>文档（document）</h4><p>一个文档是可被索引的基本信息单元，文档以JSON格式来表示。</p>
<a id="more"></a>
<h4 id="分片和复制（shards-amp-replicas）"><a href="#分片和复制（shards-amp-replicas）" class="headerlink" title="分片和复制（shards &amp; replicas）"></a>分片和复制（shards &amp; replicas）</h4><p>一个索引可以存储超过单个节点硬件限制的大量数据。ElasticSearch提供了将索引划分成多份的能力<br>，这些份就叫做分片。当创建一个索引的时候，可以指定分片的数量。每个分片本身也是一个功能完善，并且独立的索引，这个索引可以被放置到集群中的任何节点上。</p>
<p>分片之所以重要，主要有以下两点：（1）允许水平分割/扩展内容容量（2）允许在分片之上进行分布式的并行的操作，进而提高性能、吞吐量。</p>
<p>在一个网络环境里失败随时可能发生，在某个分片或者节点不知道怎么就处于离线状态，或者任何原因消失了，这种情况下有一种故障转移机制是非常有用并且强烈推荐的。因此，EleasticSearch可以创建一份或者多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
<p>复制之所以重要，主要有以下两点：</p>
<ol>
<li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原始分片置于同一节点上是非常重要的</li>
<li>扩展了搜索量/吞吐量，因为搜索可以在所有的复制上并行。</li>
</ol>
<h3 id="ElasticSearch-常用curl"><a href="#ElasticSearch-常用curl" class="headerlink" title="ElasticSearch 常用curl"></a>ElasticSearch 常用curl</h3><h5 id="增加索引mapping新字段"><a href="#增加索引mapping新字段" class="headerlink" title="增加索引mapping新字段"></a>增加索引mapping新字段</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPUT http:<span class="comment">//127.0.0.1:9201/job_index_v6/_mapping/b2b -d '&#123;"properties":&#123;"new_field_name":&#123;"type":"string"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="查看集群是否健康"><a href="#查看集群是否健康" class="headerlink" title="查看集群是否健康"></a>查看集群是否健康</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/health?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="列出所有索引"><a href="#列出所有索引" class="headerlink" title="列出所有索引"></a>列出所有索引</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/indices?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="获取集群的节点列表"><a href="#获取集群的节点列表" class="headerlink" title="获取集群的节点列表"></a>获取集群的节点列表</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/nodes?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X DELETE <span class="number">127.0</span>.0.1:<span class="number">9201</span>/agent_job_index</span><br></pre></td></tr></table></figure>
<h5 id="给索引设置别名"><a href="#给索引设置别名" class="headerlink" title="给索引设置别名"></a>给索引设置别名</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="number">127.0</span>.0.1:<span class="number">9201</span>/job_index_v6/_alias/job_index</span><br></pre></td></tr></table></figure>
<h5 id="查看指定索引的mapping"><a href="#查看指定索引的mapping" class="headerlink" title="查看指定索引的mapping"></a>查看指定索引的mapping</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">"http://127.0.0.1:9201/job_index_v6/_mapping?pretty"</span></span><br></pre></td></tr></table></figure>
<h5 id="清除指定索引-数据"><a href="#清除指定索引-数据" class="headerlink" title="清除指定索引 数据"></a>清除指定索引 数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;"query":&#123;"match_all":&#123;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="根据查询删除"><a href="#根据查询删除" class="headerlink" title="根据查询删除"></a>根据查询删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;"query":&#123;"term":&#123;"userId":"1017"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"term":&#123;"indexStatus":"1"&#125;&#125;&#125;' | python -m json.tool</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"bool":&#123;"filter":[&#123;"match":&#123;"is2CJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"isAgentJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"switchStatus":&#123;"query":2&#125;&#125;&#125;]&#125;&#125;&#125;' | python -m json.tool</span></span><br></pre></td></tr></table></figure>
<h5 id="搜索最大值"><a href="#搜索最大值" class="headerlink" title="搜索最大值"></a>搜索最大值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPUT http:<span class="comment">//127.0.0.1:9200/job_index_v6/_settings -d '&#123; "index" : &#123; "max_result_window" : 20000&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -POST <span class="number">127.0</span>.0.1:<span class="number">9201</span>/job_index_v6/job/_update_by_query -d <span class="string">'&#123;"script":&#123;"lang":"painless","inline":"if (ctx._source.is2CJob == null) &#123;ctx._source.is2CJob= '</span><span class="keyword">true</span><span class="string">'&#125;"&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="添加一条数据"><a href="#添加一条数据" class="headerlink" title="添加一条数据"></a>添加一条数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9201/job_index_v6/job/22c3cade5f5a4f189f6145cb0b15b737?pretty'</span> -d<span class="string">'&#123;"id":"22c3cade5f5a4f189f6145cb0b15b737","sourceId":"22c3cade5f5a4f189f6145cb0b15b737","label":0,"userId":"8a1026775d16fbb2015d17a4771a0348","name":"1231231","operatorName":null,"refuseReason":null,"description":"2","workAddress":"韩国","countryId":[513114,513100,510000],"countryNames":["韩国"],"salary":3000,"salaryHigh":4000,"listPrice":2222,"channelPrice":0,"status":2,"indexStatus":2,"is2CJob":true,"deposit":500,"modifyTime":1546593027000,"createTime":1546593027000,"refreshTime":1546593027000,"companyId":"8a1026775981103b01598110cee70004","heat":0,"praise":0,"applyment":0,"comment":0,"browseNumber":0,"postName":["建筑","电工"],"post":[111200,110000,111220],"tagName":[],"tag":[],"systemTag":[],"allTag":[2215],"businessLine":237,"score":63393027,"newOldFlag":1,"switchStatus":0,"agentQuantity":0,"company.name":"北京走出趣科技发展有限公司","company.shortName":"走出趣","company.tag":[2215],"company.location":[110000,110100,110108],"company.status":1&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="查看-索引-设置"><a href="#查看-索引-设置" class="headerlink" title="查看 索引 设置"></a>查看 索引 设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">"http://zcq-product2:9200/job_index_v6/_settings?pretty"</span></span><br></pre></td></tr></table></figure>
<h4 id="查看ElasticSearch状态"><a href="#查看ElasticSearch状态" class="headerlink" title="查看ElasticSearch状态"></a>查看ElasticSearch状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201'</span> | python -m json.tool</span><br></pre></td></tr></table></figure>
<h5 id="按照排序搜索"><a href="#按照排序搜索" class="headerlink" title="按照排序搜索"></a>按照排序搜索</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -POST http:<span class="comment">//test2.51zouchuqu.com:9201/job_rcmd_score_index/score/_search -d '&#123;"from":0,"size":1000,"query":&#123;"bool":&#123;"disable_coord":false,"adjust_pure_negative":true,"boost":1&#125;&#125;,"explain":false,"sort":[&#123;"score":&#123;"order":"desc"&#125;&#125;]&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="ElasticSearch-备份、导入、导出"><a href="#ElasticSearch-备份、导入、导出" class="headerlink" title="ElasticSearch 备份、导入、导出"></a>ElasticSearch 备份、导入、导出</h3><h4 id="es-数据导入导出"><a href="#es-数据导入导出" class="headerlink" title="es 数据导入导出"></a>es 数据导入导出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install elasticdump</span><br><span class="line">./bin/elasticdump</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index-&gt;index:</span><br><span class="line">elasticdump --input=http:<span class="comment">//localhost:9200/test --output=http://localhost:9200/test</span></span><br><span class="line">index-&gt;file:</span><br><span class="line">elasticdump --input=http:<span class="comment">//localhost:9200/test --output=./json.log</span></span><br><span class="line">file-&gt;index:</span><br><span class="line">elasticdump --input=./json.log --output=http:<span class="comment">//localhost:9200/test</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😏中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令速查笔记</title>
    <url>/2019/03/04/git/</url>
    <content><![CDATA[<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>git clone url  将远程git仓库克隆到本地</p>
<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>git init 在当前目录新建一个git仓库</p>
<h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>打开git仓库图形界面</p>
<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>显示所有变更信息</p>
<h3 id="git-clean-fd"><a href="#git-clean-fd" class="headerlink" title="git clean -fd"></a>git clean -fd</h3><p>删除所有Untracked files</p>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>将未add到Stage区的文件，暂时存储起来</p>
<a id="more"></a>
<h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h3><p>将git stash 暂时存储起来的文件，恢复，然后就可以继续add到Stash区</p>
<h3 id="git-fetch-remote"><a href="#git-fetch-remote" class="headerlink" title="git fetch remote"></a>git fetch remote</h3><p>下载远程仓库的所有更新</p>
<h3 id="git-pull-romote-branch-name"><a href="#git-pull-romote-branch-name" class="headerlink" title="git pull romote branch-name"></a>git pull romote branch-name</h3><p>下载远程仓库的所有更新，并且Merge</p>
<h3 id="git-config-配置"><a href="#git-config-配置" class="headerlink" title="git config 配置"></a>git config 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global gui.encoding=utf-<span class="number">8</span>  配置git图形界面编码为utf-<span class="number">8</span></span><br><span class="line">git config --global user.name name  设置提交代码时的用户名</span><br><span class="line">git config --global user.email email  设置提交代码时的邮箱</span><br></pre></td></tr></table></figure>
<h3 id="git-remote-远程仓库操作"><a href="#git-remote-远程仓库操作" class="headerlink" title="git remote 远程仓库操作"></a>git remote 远程仓库操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git remote -v  显示所有远程仓库</span><br><span class="line">git remote add name url  增加一个新的远程仓库</span><br></pre></td></tr></table></figure>
<h3 id="git-add-添加文件到Stage区"><a href="#git-add-添加文件到Stage区" class="headerlink" title="git add 添加文件到Stage区"></a>git add 添加文件到Stage区</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add --all   添加所有的修改到Stage区</span><br><span class="line">git add file   添加指定文件到Stage区</span><br><span class="line">git add file1 file2   添加多个修改的文件到Stage区</span><br><span class="line">git add dir   添加修改的目录到Stage区</span><br><span class="line">git add   添加当前目录的所有修改到Stage区</span><br><span class="line">git add src/main*   添加所有src目录下main开头的所有文件到Stage区</span><br></pre></td></tr></table></figure>
<h3 id="git-commit-提交Stage区的代码到本地仓库"><a href="#git-commit-提交Stage区的代码到本地仓库" class="headerlink" title="git commit 提交Stage区的代码到本地仓库"></a>git commit 提交Stage区的代码到本地仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"message"</span>   提交Stage区的代码到本地仓库区</span><br><span class="line">git commit file1 file2 -m <span class="string">"message"</span>  提交Stage中在指定文件到本地仓库区</span><br><span class="line">git commit --amend -m <span class="string">"message"</span>  使用新的一次commit，来代替上一次commit，新的message也会替换上一次message</span><br></pre></td></tr></table></figure>
<h3 id="git-branch-分支"><a href="#git-branch-分支" class="headerlink" title="git branch 分支"></a>git branch 分支</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git branch   列出本地所有分支</span><br><span class="line">git branch -r  列出远程所有分支</span><br><span class="line">git branch branch-name  新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch -d branch-name   删除分支</span><br><span class="line">git branch --set-upstream-to origin/feature/company feature/company   设置分支上游</span><br></pre></td></tr></table></figure>
<h3 id="git-checkout-切换-撤销"><a href="#git-checkout-切换-撤销" class="headerlink" title="git checkout   切换/撤销"></a>git checkout   切换/撤销</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git checkout -b 本地分支名x origin/远程分支名x   创建本地分之并关联远程分支</span><br><span class="line">git checkout -b branch-name   新建一个分支，且切换到新分支</span><br><span class="line">git checkout branch-name   切换到另一个分支</span><br><span class="line">git checkout commit-file  撤销工作区文件的修改，跟上次Commit一样</span><br></pre></td></tr></table></figure>
<h3 id="git-push-向远程服务器推代码"><a href="#git-push-向远程服务器推代码" class="headerlink" title="git push  向远程服务器推代码"></a>git push  向远程服务器推代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin :master   删除远程分支</span><br><span class="line">git push origin --delete tag &lt;tagname&gt;   删除远程分支</span><br><span class="line">git push reomte branch-name   上传本地仓库到远程分支</span><br><span class="line">git push reomte branch-name --force  强行推送当前分支到远程分支</span><br><span class="line">git push remote --all  推送所有分支到远程仓库</span><br><span class="line">git push --tags   推送所有标签</span><br><span class="line">git push origin tag-name  推送指定标签</span><br><span class="line">git push origin :refs/tags/tag-name   删除远程标签（需要先删除本地标签）</span><br></pre></td></tr></table></figure>
<h3 id="git-reset-重置-回退"><a href="#git-reset-重置-回退" class="headerlink" title="git reset  重置/回退"></a>git reset  重置/回退</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset HEAD *  将上次add 到Stage区的文件 删除</span><br><span class="line">git reset --hard  重置Stage区和工作区的所有文件和上次Commit的一样</span><br><span class="line">git reset --hard origin/master   重置Commit代码和远程分支代码一样</span><br><span class="line">git reset --hard HEAD^         回退到上个版本</span><br><span class="line">git reset --hard HEAD~<span class="number">3</span>        回退到前<span class="number">3</span>次提交之前，以此类推，回退到n次提交之前</span><br><span class="line">git reset --hard commit-id     退到/进到 指定commit的sha码</span><br></pre></td></tr></table></figure>
<h3 id="git-tag-标签"><a href="#git-tag-标签" class="headerlink" title="git tag 标签"></a>git tag 标签</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git tag -a v1.4 -m <span class="string">'my version 1.4'</span>  创建带有说明的标签</span><br><span class="line">git tag tag-name  打标签</span><br><span class="line">git tag 查看所有标签</span><br><span class="line">git tag tag-name commit-id   给指定commit打标签</span><br><span class="line">git tag -d tag-name   删除标签</span><br></pre></td></tr></table></figure>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git diff file-name  查看文件在工作区和暂存区区别，也可查看工作区修改前后的区别</span><br><span class="line">git diff branch-name file-name  查看文件和另一个分支的区别</span><br><span class="line">git diff --cached  file-name  查看暂存区和本地仓库区别</span><br><span class="line">fid diff commit-id commit-id  本地仓库两次提交区别</span><br></pre></td></tr></table></figure>
<p>感觉还是idea好用啊。</p>
<h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git show tag-name  查看指定标签的提交信息</span><br><span class="line">git show commit-id  查看具体的某次改动</span><br></pre></td></tr></table></figure>
<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline 文件名     查看该文件的改动历史</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit   格式化查看历史提交</span><br><span class="line">git log --pretty=<span class="string">'%aN'</span> | sort | uniq -c | sort -k1 -n -r | head -n <span class="number">5</span>  统计仓库提交排名前<span class="number">5</span></span><br><span class="line">git log --author=<span class="string">"goodgoodstate"</span> --pretty=tformat: --numstat | gawk <span class="string">'&#123; add += $1 ; subs += $2 &#125; END &#123; printf "added lines: %s removed lines : %s \n",add,subs &#125;'</span></span><br><span class="line">查看指定用户添加代码行数，和删除代码行数</span><br></pre></td></tr></table></figure>
<h3 id="git-merge-合并代码，自动创建合并commit"><a href="#git-merge-合并代码，自动创建合并commit" class="headerlink" title="git merge 合并代码，自动创建合并commit"></a>git merge 合并代码，自动创建合并commit</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git merge branch-name  将指定分支合并到当前分支</span><br></pre></td></tr></table></figure>
<h3 id="git-rebase-合并代码，不会创建合并commit"><a href="#git-rebase-合并代码，不会创建合并commit" class="headerlink" title="git rebase  合并代码，不会创建合并commit"></a>git rebase  合并代码，不会创建合并commit</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git merge branch-name  将指定分支合并到当前分支</span><br></pre></td></tr></table></figure>
<p>rebase 操作比较危险，因为它重写了commit历史，但是rebase可以得到干净的commit历史（个人很推荐）。</p>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令速查笔记</title>
    <url>/2019/02/25/linux/</url>
    <content><![CDATA[<h3 id="cd-进入指定目录"><a href="#cd-进入指定目录" class="headerlink" title="cd  进入指定目录"></a>cd  进入指定目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd dir          <span class="comment">// 进入当前目录的子目录</span></span><br><span class="line">cd ..           <span class="comment">// 进入当前目录的上一级目录</span></span><br><span class="line">cd /            <span class="comment">// 进入系统根目录</span></span><br><span class="line">cd ~            <span class="comment">// 进入当前用户主目录</span></span><br><span class="line">cd /usr/local   <span class="comment">// 进入特定目录</span></span><br></pre></td></tr></table></figure>
<h3 id="ls-列出当前目录文件"><a href="#ls-列出当前目录文件" class="headerlink" title="ls 列出当前目录文件"></a>ls 列出当前目录文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ls -a   <span class="comment">// 列出当前目录所有文件，包含隐藏文件</span></span><br><span class="line">ls -l   <span class="comment">// 列出长数据串，包含文件的权限和属性 相当于 ll</span></span><br><span class="line">ls -i   <span class="comment">// 显示文件节点索引号</span></span><br><span class="line">ls -t   <span class="comment">// 按照修改时间，降序显示</span></span><br><span class="line">ls -rt  <span class="comment">// 按照修改时间，升序显示</span></span><br><span class="line">ls -alht  <span class="comment">// 按照修改时间，降序显示 h显示文件大小</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">个人感觉 ll -h 比较好用</font>

<h3 id="mv-修改文件名字或移动位置"><a href="#mv-修改文件名字或移动位置" class="headerlink" title="mv  修改文件名字或移动位置"></a>mv  修改文件名字或移动位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv file newname         <span class="comment">// 更改文件名字</span></span><br><span class="line">mv /dir/file /otherdir  <span class="comment">// 移动文件位置</span></span><br></pre></td></tr></table></figure>
<h3 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a>rm 删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rm -rf dir  <span class="comment">// 递归删除指定目录中的所有文件</span></span><br><span class="line">rm file     <span class="comment">// 删除指定文件</span></span><br><span class="line">rm -rf *    <span class="comment">// 递归删除当前目录中的所有文件</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cp -r /dir /other-dir    <span class="comment">// 将dir目录下所有文件，移动到other-dir目录中</span></span><br><span class="line">cp fileA fileB           <span class="comment">// 备份A文件，并改名</span></span><br></pre></td></tr></table></figure>
<h3 id="kill-杀进程"><a href="#kill-杀进程" class="headerlink" title="kill 杀进程"></a>kill 杀进程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -<span class="number">9</span>  PID   <span class="comment">// 将PID进程结束</span></span><br><span class="line">kill -<span class="number">17</span> PID   <span class="comment">// 将PID进程暂停</span></span><br></pre></td></tr></table></figure>
<h3 id="chown-修改文件所属用户或用户组"><a href="#chown-修改文件所属用户或用户组" class="headerlink" title="chown 修改文件所属用户或用户组"></a>chown 修改文件所属用户或用户组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chown -R root:root /tmp    <span class="comment">// 修改 tmp 目录所属用户为 root，用户组为 root</span></span><br><span class="line">chown iisheng file  <span class="comment">// 将file的所有者设置为iisheng</span></span><br></pre></td></tr></table></figure>
<h3 id="chmod-给文件设置别人访问权限"><a href="#chmod-给文件设置别人访问权限" class="headerlink" title="chmod 给文件设置别人访问权限"></a>chmod 给文件设置别人访问权限</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">766</span> file <span class="comment">// 给某个文件别人访问权限</span></span><br><span class="line">chmod <span class="number">777</span> * <span class="comment">// 当前文件夹所有文件所有用户都可以读写</span></span><br></pre></td></tr></table></figure>
<h3 id="cat-查看文件或写到指定文件内容"><a href="#cat-查看文件或写到指定文件内容" class="headerlink" title="cat  查看文件或写到指定文件内容"></a>cat  查看文件或写到指定文件内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat file                                  <span class="comment">// 显示整个文件内容</span></span><br><span class="line">cat -n file                               <span class="comment">// 显示整个文件内容，并由1开始对行数编号</span></span><br><span class="line">cat file &gt; newFile                        <span class="comment">// 将文件的内容写到新文件里面</span></span><br><span class="line">cat file | head -n <span class="number">3000</span> | tail -n +<span class="number">1000</span>   <span class="comment">// 查看文件的1000-3000行</span></span><br><span class="line">cat /proc/PID/status                      <span class="comment">// 查看指定进程的相关信息</span></span><br></pre></td></tr></table></figure>
<h3 id="scp-终端远程下载上传文件"><a href="#scp-终端远程下载上传文件" class="headerlink" title="scp 终端远程下载上传文件"></a>scp 终端远程下载上传文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scp  root<span class="meta">@iisheng</span>.cn:/path/filename ./                              <span class="comment">// 文件下载到本地当前目录</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  /home/jdk.tar.gz   root<span class="meta">@iisheng</span>.cn:/root/jdk.tar.gz  <span class="comment">// 上传文件</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  -r /home/jdk/ root<span class="meta">@isheng</span>.me                        <span class="comment">// 上传文件目录</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  -r /home/jdk/ root<span class="meta">@isheng</span>.me                        <span class="comment">// 使用IPV6寻址上传文件目录</span></span><br></pre></td></tr></table></figure>
<h3 id="netstat-打印网络信息状态"><a href="#netstat-打印网络信息状态" class="headerlink" title="netstat  打印网络信息状态"></a>netstat  打印网络信息状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netstat -at                <span class="comment">// 列出所有TCP端口</span></span><br><span class="line">netstat -au                <span class="comment">// 列出所有UDP端口</span></span><br><span class="line">netstat -lt                <span class="comment">// 列出所有监听TCP的端口</span></span><br><span class="line">netstat -lu                <span class="comment">// 列出所有监听UDP的端口</span></span><br><span class="line">netstat -r                 <span class="comment">// 显示核心路由信息</span></span><br><span class="line">netstat -anl | grep <span class="number">8888</span>   <span class="comment">// 查看相关端口号信息</span></span><br></pre></td></tr></table></figure>
<h3 id="top-实时系统的查看系统运行情况"><a href="#top-实时系统的查看系统运行情况" class="headerlink" title="top  实时系统的查看系统运行情况"></a>top  实时系统的查看系统运行情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top              <span class="comment">// 动态查看系统的整体运行情况</span></span><br><span class="line">top -p PID       <span class="comment">// 查看指定进程的运行情况</span></span><br><span class="line">top -u user      <span class="comment">// 查看指定用户的相关进程的运行情况</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">htop 和top类似功能</font>

<h3 id="sed-处理文件并在控制台打印"><a href="#sed-处理文件并在控制台打印" class="headerlink" title="sed  处理文件并在控制台打印"></a>sed  处理文件并在控制台打印</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/book/books/'</span> file   <span class="comment">// s 替换指定 字符，将book替换为books</span></span><br><span class="line">sed -i <span class="string">'s/book/books/g'</span> file  <span class="comment">// g 替换文本中内容 -i 直接编辑文本选项 匹配文件中第一个book替换为books</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">这个东西很多功能的，暂时不详细学习</font>

<h3 id="less-从头查看日志"><a href="#less-从头查看日志" class="headerlink" title="less 从头查看日志"></a>less 从头查看日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shift+g 跳转到文件底部</span><br><span class="line">按f键,是向前(下)查看  forword</span><br><span class="line">按b键,是向后(上)查看  backword</span><br><span class="line">q  退出</span><br></pre></td></tr></table></figure>
<h3 id="more-从头查看日志"><a href="#more-从头查看日志" class="headerlink" title="more 从头查看日志"></a>more 从头查看日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">more file</span><br><span class="line">按ctrl+f键,是向前(下)查看  forword</span><br><span class="line">按ctrl+b键,是向后(上)查看 backword</span><br></pre></td></tr></table></figure>
<h3 id="tail-动态查看文件尾部内容"><a href="#tail-动态查看文件尾部内容" class="headerlink" title="tail 动态查看文件尾部内容"></a>tail 动态查看文件尾部内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tail -<span class="number">500f</span> file  <span class="comment">// 动态查看文件尾部500行</span></span><br></pre></td></tr></table></figure>
<h3 id="head-显示文件开头内容"><a href="#head-显示文件开头内容" class="headerlink" title="head 显示文件开头内容"></a>head 显示文件开头内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">head -<span class="number">100f</span> file  <span class="comment">// 查看文件前100行</span></span><br></pre></td></tr></table></figure>
<h3 id="rar-解压rar文件或压缩为rar文件"><a href="#rar-解压rar文件或压缩为rar文件" class="headerlink" title="rar 解压rar文件或压缩为rar文件"></a>rar 解压rar文件或压缩为rar文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rar x -ep2 filename    <span class="comment">// 将Windows rar文件 解压 utf-8编码的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="unzip-解压zip文件或压缩为zip文件"><a href="#unzip-解压zip文件或压缩为zip文件" class="headerlink" title="unzip 解压zip文件或压缩为zip文件"></a>unzip 解压zip文件或压缩为zip文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unzip -d fileDir file.zip   <span class="comment">// zip 文件 解压</span></span><br><span class="line">unzip fileName <span class="comment">// 文件解压缩到当前目录</span></span><br><span class="line">unzip -O cp936 file.zip <span class="comment">//将Windows文件以utf-8编码解压缩</span></span><br></pre></td></tr></table></figure>
<h3 id="service-启动查看进程状态"><a href="#service-启动查看进程状态" class="headerlink" title="service 启动查看进程状态"></a>service 启动查看进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service sshd status        <span class="comment">// 查看sshd的运行状态</span></span><br><span class="line">service sshd start        <span class="comment">// 启动服务</span></span><br></pre></td></tr></table></figure>
<h3 id="systemctl-启动查看进程状态"><a href="#systemctl-启动查看进程状态" class="headerlink" title="systemctl 启动查看进程状态"></a>systemctl 启动查看进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl status httpd.service <span class="comment">// 查看httpd服务状态</span></span><br><span class="line">systemctl enable httpd.service <span class="comment">// 启动服务</span></span><br></pre></td></tr></table></figure>
<h3 id="安装、卸载软件"><a href="#安装、卸载软件" class="headerlink" title="安装、卸载软件"></a>安装、卸载软件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo agt-get install git  <span class="comment">// 安装git</span></span><br><span class="line">sudo apt-get --purge remove git  <span class="comment">// 卸载git</span></span><br></pre></td></tr></table></figure>
<h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i *.deb    <span class="comment">// 安装.deb文件的软件</span></span><br><span class="line">sudo dpkg -P *.deb    <span class="comment">// 卸载.deb文件的软件</span></span><br></pre></td></tr></table></figure>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shutdown -h now    <span class="comment">// 关机</span></span><br><span class="line">shutdown -r now    <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">df -lh   <span class="comment">// 查看系统硬盘使用情况</span></span><br></pre></td></tr></table></figure>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">du -sh     <span class="comment">// 查看文件目录大小</span></span><br><span class="line">du -ah     <span class="comment">// 查看文件目录下面各个文件大小</span></span><br><span class="line">du -h --max-depth=<span class="number">1</span> ./  <span class="comment">// 查看当前目录大小</span></span><br></pre></td></tr></table></figure>
<h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.c"</span> | xargs grep -H <span class="string">"intern("</span>  <span class="comment">// 查找当前目录指定文件后缀包含指定字符的结果</span></span><br><span class="line">find /home -name <span class="string">'*.md'</span> <span class="comment">// 查找指定目录包含指定字符串 的文件名路径</span></span><br></pre></td></tr></table></figure>
<h3 id="grep-全面搜索正则表达式并把行打印出来"><a href="#grep-全面搜索正则表达式并把行打印出来" class="headerlink" title="grep 全面搜索正则表达式并把行打印出来"></a>grep 全面搜索正则表达式并把行打印出来</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grep -rn <span class="string">"hello,world!"</span> *  <span class="comment">// 在当前目录查找 hello,world 字符串</span></span><br><span class="line">grep <span class="string">'model name'</span> /proc/cpuinfo | wc -l  <span class="comment">// 查看系统有几个CPU</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">一般配合别的命令一起使用效果很强大</font>

<h3 id="ps-显示当前进程状态"><a href="#ps-显示当前进程状态" class="headerlink" title="ps  显示当前进程状态"></a>ps  显示当前进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx     <span class="comment">// 根据名字查找进程</span></span><br><span class="line">ps -ef | grep elastic   <span class="comment">// 根据名字查找进程</span></span><br></pre></td></tr></table></figure>
<h3 id="lsof-查看进程打开的端口，查看打开文件的进程"><a href="#lsof-查看进程打开的端口，查看打开文件的进程" class="headerlink" title="lsof  查看进程打开的端口，查看打开文件的进程"></a>lsof  查看进程打开的端口，查看打开文件的进程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lsof -i:<span class="number">8888</span>      <span class="comment">// 根据端口号查看相关进程信息</span></span><br></pre></td></tr></table></figure>
<h3 id="iconv-转换文件编码"><a href="#iconv-转换文件编码" class="headerlink" title="iconv  转换文件编码"></a>iconv  转换文件编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconv -f gb2312 file -o newFile  <span class="comment">// 将Windows文件转换为Linux识别的文件</span></span><br><span class="line">iconv -f gbk -t utf8 file &gt; bewFile  <span class="comment">// 将Windows文件转换为Linux识别的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="curl-文本传输工具"><a href="#curl-文本传输工具" class="headerlink" title="curl 文本传输工具"></a>curl 文本传输工具</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> https:<span class="comment">//api.github.com -s | python -m json.tool  // GET请求</span></span><br><span class="line">curl -X PUT <span class="number">127.0</span>.0.1:<span class="number">9200</span>/job_index/_mapping/job -d <span class="string">'&#123;"properties":&#123;"new_field":&#123;"type":"integer"&#125;&#125;&#125;'</span>  <span class="comment">// PUT请求</span></span><br><span class="line">curl -X DELETE <span class="number">127.0</span>.0.1:<span class="number">9200</span>/agent_job_index  <span class="comment">// DELETE请求</span></span><br><span class="line">curl -X POST <span class="number">127.0</span>.0.1:<span class="number">9200</span>/job_index/job/_search -d <span class="string">'&#123;"query":&#123;"term":&#123;"id":"1"&#125;&#125;&#125;'</span> <span class="comment">// POST请求</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
</search>
