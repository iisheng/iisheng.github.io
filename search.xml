<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[时间管理：如何充分利用你的24小时]]></title>
    <url>%2F2019%2F10%2F09%2Ftime-mgt%2F</url>
    <content type="text"><![CDATA[如果你对 “如何充分利用你的24小时”感兴趣，我推荐你读《时间管理 如何充分利用你的24小时》漫画版。 以下是我个人从书中学到的以及一些自己的体会。 意识到自己的时间花费在什么地方每天睡觉之前的时间，可以总结一下当天都做什么事情，分别花费了多少时间。画一个如下类似的表格： 时间段 内容 时间 02:30-12:00 睡觉 9.5小时 14:00-20:00 打王者荣耀 6小时 … … … 19:00-22:00 看电视剧 5小时 23:00-24:00 定外卖吃饭 3小时 这样可以清晰看到自己在某件事情上花费的时间，可以根据自己的情况在计划表中减少或者增加。 确定自己的目标找自己喜欢的方式给自己制定明确的计划表，比如： 时间 内容 01:00-08:00 睡觉 08:30-09:00 吃早餐 09:00-12:00 学习数据结构 … … 23:00-24:00 洗澡、做当天总结、做第二天计划 对比自己的计划表和实际花费的时间表，总结自己的行为，改进自己的时间管理。 选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情习惯养成 闹钟响起，立即下床 上午时间，学习数据结构与算法相关 规律、健康的饮食和运动 快速做抉择 快速阅读 利用碎片时间，地铁上、等外卖、排队的时候，可以看公众号、极客时间、知识星球 不拖延，按照计划表去做。大任务，分解成小任务，放到计划表中。 拒绝杂乱无章，物应各有其所，亦应各在其所 每周对自己的时间花费行为进行总结，每月也要总结，已经制定下月计划 时间管理技巧 利用好碎片时间 做事前花特定时间思考，思考时间过后开始行动 做事专注 做事不半途而废，做完之后，不再打开 注意在重要的事情上多花费时间 注意优先顺序，在精力充沛的时间，做当天最困难的事情 保似水之心 拒绝杂乱无章 总结、制定计划 规律、健康的饮食和运动]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法总结]]></title>
    <url>%2F2019%2F05%2F13%2Fsort%2F</url>
    <content type="text"><![CDATA[一、冒泡排序临近的数字两两进行比较，按照从小到大或者从大到小的顺序交换，这样一趟后，最大或者最小的数字被交换到最后一位。然后再从头开始两两进行比较交换，直到排序完成。 交换数组中两个元素的方法：12345public static void swap(int[] arr,int i,int j)&#123; int swap=arr[i]; arr[i]=arr[j]; arr[j]=swap;&#125; 冒泡排序算法代码实现 123456789public static void bubbleSort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) swap(arr, j + 1, j); &#125; &#125;&#125; 二、选择排序直接从待选择排序数组里面选择一个最小（或者最大）的数字，与第一个位置的数交换。然后再在剩下的数中选择最小（或者最大）的数字，与第二个位置的数字交换，如此循环到只剩下一个数字为止。 选择排序代码实现： 1234567891011121314public static void selectSort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; int min = arr[i]; int min_index = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; min) &#123; min = arr[j]; min_index = j; &#125; &#125; swap(arr, min_index, i); &#125;&#125; 三、插入排序 每一步将一个待排序数据按其大小插入到已经排序的数组中的适当位置，直到全部插入完毕。 插入排序代码实现： 1234567891011public static void insertSort(int[] arr) &#123; int len = arr.length; int j = 0; for (int i = 0; i &lt; len; i++) &#123; int temp = arr[i]; for (j = i; j &gt; 0 &amp;&amp; temp &lt; arr[j - 1]; j--) &#123; arr[j] = arr[j - 1]; &#125; arr[j] = temp; &#125;&#125; 四、快速排序选择一个基本元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，另一部分大于或等于基准元素。这一趟扫描结束后，该基准就处于序列的中间位置。然后再用同样的方法递归的排序划分这两部分。 快速排序代码实现： 123456789101112131415161718192021222324public static void quickSort(int[] arr) &#123; recursion(arr, 0, arr.length - 1);&#125;public static void recursion(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int pivot = partition(arr, low, high); recursion(arr, low, pivot - 1); recursion(arr, pivot + 1, high); &#125;&#125;//返回 基数 在数组 中的位置public static int partition(int[] arr, int low, int high) &#123; int pivot = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high; arr[low] = arr[high]; while (low &lt; high &amp;&amp; arr[low] &lt; pivot) ++low; arr[high] = arr[low]; &#125; arr[low] = pivot; return low;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML九种图关系总结]]></title>
    <url>%2F2019%2F05%2F06%2Fuml%2F</url>
    <content type="text"><![CDATA[什么是UMLUML是Unified Model Language的缩写，是一种建模语言。通过使用UML使得在软件开发之前，对整个软件设计有更好的可读性，可理解性，从而降低开发风险。同时，也能方便各个开发人员之间的交流。 UML九种图如下图所示，UML图分为，用例图、静态图、交互图、行为图、实现图。静态图包括类图和对象图，交互图包括序列图和协作图，行为图包括状态图和活动图，实现图包括构件图和部署图。 用例图【概念】描述用户的需求，从用户的角度描述系统的功能 【描述方式】椭圆表示某个用例，人形符号表示角色 【目的】帮助开发团队以一种可视化的方式理解系统的功能需求 类图【概念】根据用例图抽象成类，描述类的内部结构和类与类之间的关系 【描述方式】矩形表示类或者接口，之间的关系使用箭头、三角形和虚线或者实线表示 【目的】显示系统的静态结构，表示不同的实体是如何关联的 在UML关系中，常见的有一下几种关系。泛化（Generalization）,实现（Realization）,关联（Association）,聚合（Aggregation）,组合（Composition）,依赖（Dependency） 【泛化关系】:是一种继承关系，表示子类继承父类的所有特征和行为。【箭头指向】:带三角箭头的实现线，箭头指向父类。 【实现关系】:是一种类与接口的关系，表示类是接口所有特征和行为的实现。【箭头指向】:带三角箭头的虚线，箭头指向接口。 【关联关系】:是一种拥有关系，它使得一个类知道另一个类的属性和方法。【代码体现】:成员变量【箭头指向】:带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。 【聚合关系】:是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关机。【代码体现】:成员变量【箭头指向】:带空心菱形和普通箭头的实线，空心菱形指向整体，普通箭头指向部分。 【组合关系】:是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。 【代码体现】:成员变量【箭头指向】:带实心菱形和普通箭头的实线，实心菱形指向整体，普通箭头指向部分。【依赖关系】:是一种使用关系，即一个类的实现需要另一个类的协助。【箭头指向】:带普通箭头的虚线，普通箭头指向被使用者。 对象图【概念】类图的一个实例，描述系统在具体时间点上所包含的对象以及各个对象之间的关系 【描述方式】由对象（Object）和链(Link)组成 【目的】显示系统的静态结构，表示不同的实例是如何关联的 序列图 也叫 时序图 顺序图【概念】描述对象之间的交互顺序，主要提现对象间消息传递的时间先后顺序（时间） 【描述方式】 【目的】显示流程中不同对象之间的调用关系 协作图 也叫作通讯图【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系（空间） 【描述方式】 【目的】显示空间中不同对象的调用关系 状态图【概念】描述对象的所有状态以及事件发生而引起的状态之间的转移 【描述方式】 【目的】表示某个类所处的不同状态以及该类在这些状态中的转换过程 活动图【概念】描述满足用例要求所要进行的活动以及活动时间的约束关系 【描述方式】表示两个或者多个对象之间在处理某个活动时的过程控制流程 【目的】 构建图【概念】描述代码构建的物理结构以及各结构之间的依赖关系 【描述方式】 【目的】提供系统的物理视图，根据系统的代码构建显示系统代码的整个物理结构 部署图【概念】系统中硬件的物理体系结构 【描述方式】 【目的】显示系统的硬件和软件的物理结构]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础知识]]></title>
    <url>%2F2019%2F04%2F29%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis基本数据类型Binary-safe stringsstring 类型是二进制安全的.意思是redis的string可以包含任意数据,比如jgp图片或者已经序列化的的对象. Lists实质是每一个都是string类型的双向链表,push和pop的命令算法的时间复杂度都是O(1),list还会记录链表的长度,所以llen操作也是O(1). Sets是string类型的无序集合.set是通过 hash table实现的,所以添加,查找,删除的复杂度都是O(1),hash table 会随着添加或者删除自动调整大小. Sorted setssorted sets 也是string类型元素的集合,不同的是每个元素都会关联一个double类型的score,元素顺序有score决定.sorted sets的实现是skip list和hash table的混合体. Hashes是string类型的field和value的映射表.它的添加和删除都是O(1).hash特别适合用于存储对象 Bit arrays可以用特殊的命令,处理string的value,像处理一个位数组一样 HyperLogLogs它是一个概率数据库.(用于估算集合的基数) Redis 基本命令操作string的命令 set key value get key value mset key1 value1 key2 value2 mget key1 key2 incr key 对值做加加,返回新的值(对不存在的key返回1,对非intkey会报错) decr key 对值做减减,返回新的值(对不存在的key返回1,对非intkey会报错) incrby key integer 加指定值(key不存在会认为,原来的value为0) decrby key integer 减指定值(key不存在会认为,原来的value为0) append key value 给指定key的字符串追加value substr key start end 返回截取过的key的字符串值,注意并不修改key,下标从0开始,区间前闭后闭 操作list的命令 lpush key string 在key对应的头部添加字符串元素,返回1代表成功,返回0表示key存在且不是list类型 rpush key string 在key对应的尾部添加字符串元素,返回1代表成功 lpop key 从list的头部删除元素,并返回删除的元素,如果list不存在或为空返回nil,如果不是list返回错误 rpop key 同上,但是从尾部删除 llen key 返回key对应list的长度,key不存在返回0,如果key对应的不是list返回错误 lrange key start end 返回指定区间内的元素,下标从0开始,负值表示从后面计算,-1表示倒数第一个元素,key不存在返回空列表 ltrim key start end 截取list,保留指定区间内元素,成功返回1,key不存在返回错误 lset key index value 设置list中指定下标的元素值,成功返回1,key或者下标不存在返回错误 linsert key before value value2在值value前插入值value2 操作sets的命令 saad key value 添加一个string元素到key对应的set集合,成功返回1,如果元素已经在元素中返回0,可以对应的set不存在返回错误 srem key value 从key对应set中移除给定元素,成功返回1,如果value在集合中不存在或者key不存在返回0,key对应的不是set类型返回错误 spop 删除并返回set中一个随机元素,如果set是空或者key不存在返回nil srandommembe key 同 spop,但是不删除元素 操作sorted sets的命令 zadd key score member 添加元素到集合,当member已存在,更新score zrem key member 删除指定元素,1表示成功,如果不成功返回0 操作hashes的命令 hset key field value 设置hash field 为指定值,如果key不存在则先创建 hget key field 获取指定hash的hash field Redis高级特性安全性设置redis密码,可以配置redis.conf也可以直接在redis-cli中设置1config set requirepass ****** 查看redis是否设置密码1config get requirepass 主从复制Redis主从复制过程: slave和master建立连接,发送sync同步命令 master会启动一个后台线程,将数据库线程保存到文件中,同时master主线程会开始收集新的写命令缓存. 后台完成保存后,就将此文件发送给slave slave将此文件保存到硬盘上 事务处理 redis对事务的支持比较简单,redis只能保证一个client发起的事务中的命令可以连续执行,而中间不会插入其他的client命令.当一个client在发出multi命令时,这个连接会进入一个事务的上下文,连续后续命令不会立即执行,而是先放到一个队列中,当执行exec命令时,redis会顺序执行队列中的所有命令. redis在事务中发生错误不会回滚. 持久化redis提供了一系列不同的持久化选项: RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照. AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存. 发布订阅消息发布订阅（pub/sub）是一种消息通知模式，主要的目的是截除消息发布者和消息订阅者之间的耦合，Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道（channel）.当发布者通过publish命令向redis server发送特定类型的信息时，订阅该信息类型的全部client都会收到此消息. 虚拟内存Redis的虚拟内存与操作系统的虚拟内存不是一回事，但是思路和目的都是相同的.就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据.尤其是对于redis这样的内存数据库，内存总是不够用的.除了可以将数据分割到多个redis server外.另外能够提高数据库容量的办法就是使用虚拟内存把那些不经常访问的数据交换到磁盘上. Redis集成Spring Bootpom文件添加redis依赖12345&lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; application.properties增加redis相关属性123456789#redis spring.redis.hostName=goodgoodstate.mespring.redis.port=6379 spring.redis.password=xxx spring.redis.pool.maxActive=8 spring.redis.pool.maxWait=-1 spring.redis.pool.maxIdle=8 spring.redis.pool.minIdle=0 spring.redis.timeout=0 配置类12345678910111213@Configurationpublic class RedisConfiguration &#123;@Bean@ConditionalOnMissingBean(value =&#123; StringRedisTemplate.class, RedisTemplate.class&#125;)public StringRedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException &#123;StringRedisTemplate template = new StringRedisTemplate();template.setConnectionFactory(redisConnectionFactory);return template;&#125;&#125; Java操作Redis设置Redis中String类型的键值对,600秒自动失效1redisTemplate.opsForValue().set("key", "value", 600, TimeUnit.SECONDS); 获取Redis中String类型的value1String value = (String) redisTemplate.opsForValue().get("key"); 获取操作Hash对象1HashOperations&lt;String, String, String&gt; hashOperations = redisTemplate.opsForHash(); put一个map对象1hashOperations.putAll(key, new HashMap&lt;&gt;()); 获取一个hash里面的maspKey对应的值1String value = hashOperations.get("key", "mapKey");]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句学习总结]]></title>
    <url>%2F2019%2F04%2F22%2Fmysql%2F</url>
    <content type="text"><![CDATA[启动1service mysql start 范式（1）第一范式（每列都保持原子性)（2）第二范式（非主属性不部分依赖于候选码）（3）第三范式（非主属性不传递依赖于候选码）（4）BC范式（任何属性不部分依赖与候选码，不传递依赖与候选码） 创建表SQL123456CREATE TABLE user (`id` INT UNSIGNED NOT NULL AUTO_INCREMENT,`name` VARCHAR(10),`age` INT ,PRIMARY KEY (`id`))ENGINE = INNODB CHARACTER SET = utf8 更新表中数据SQL1update user set user.name = "lisheng" where id = 1; 查询表中数据的SQL1select user.name , user.age from user; 插入表中数据的SQL1insert into user (id ,name ,age) values (1,"lisheng",12); 连接1select user.name ,good.name from user join good on user.id = good.user_id; 删除表中数据的SQL1delete from user where id =1; 导出数据库1mysqldump -u dbuser -p dbname &gt; dbname.sql // 在/usr/local/mysql/bin目录执行 导入sql数据库1source /home/abc/abc.sql; // 登录到数据库内执行 查看数据库表的编码格式1show create table table-name; 设置字段默认值1ALTER TABLE user ALTER COLUMN name SET DEFAULT "" ; 修改表字段1ALTER TABLE address MODIFY COLUMN city CHAR(30); 增加一个表的一个字段1ALTER TABLE wechat_auth ADD user_id VARCHAR(255) 时间日期格式化12345678DATE_FORMAT(t1.create_time,'%Y-%c-%d %h:%i:%s') ``` ### 创建索引```sqlCREATE INDEX index_nameON table_name (column_name) 删除索引1drop INDEX index_name ON tbl_name 导入cvs文件12345678LOAD DATA INFILE '[FILE]' INTO TABLE [TABLE]； 或者 LOAD DATA INFILE '[FILE]' INTO TABLE [TABLE] FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n'； 导出cvs文件12345678SELECT * FROM [TABLE] INTO OUTFILE '[FILE]'； 或者 SELECT * FROM [TABLE] INTO OUTFILE '[FILE]' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n'； 查询指定字段重复的记录1SELECT * FROM users GROUP BY mobile HAVING COUNT(mobile)&gt;1 ORDER BY create_time DESC ; 当数据库中不存在该记录的时候插入123456789INSERT INTO `table` (value1, value2)SELECT'stuff for value1','stuff for value2'FROM DUALWHERE NOT EXISTS(SELECT *FROM `table`WHERE value1 = 'stuff for value1' AND value2 = 'stuff for value2')LIMIT 1; 例子123456789INSERT INTO `t_test` (id, name)SELECT1,'李胜'FROM DUALWHERE NOT EXISTS(SELECT *FROM `t_test`WHERE id = 1 AND name = '李胜')LIMIT 1; 给表中两个字段添加唯一性约束1ALTER TABLE `table` ADD unique unique-name (column1,column2); 删除唯一性约束1ALTER TABLE 表名 DROP KEY 约束名; inner join 和left join区别left join (左连接) 返回包括左表中所有记录和右表中连接字段相等的记录right join (右连接) 返回包括右表中所有记录和左表中连接字段相等的记录inner join (等值连接) 只返回两个表中连接字段相等的记录 SQL 优化 查询 seeker_job 去掉 seeker_job_suggest 关联 优化模糊查询 改用单 like% reverse函数建立反向索引 范围模糊查询 自增id优于uuid 使用count(1)也是自增id更好 在适当的地方添加索引 （MySQL仅能对索引最左边的前缀进行有效的查找） where语句后面的顺序 以及 建立 索引的顺序 （最左前缀匹配原则） （尽量选择区分度高的列作为索引。）( = 和 in 可以乱序) （尽量扩展索引，少去新建索引） 不以通配符开头的sql语句 like “%aaa” ALL 全表扫描 like “aaaa%” range 索引 尽量避免 null值判断 应该使用 0 默认值的 方法 避免 select * order by语句后面跟索引 排序的顺序 很重要 很重要 提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉 能用DISTINCT的就不用GROUP BY 查看编码1show variables like '%char%'; 查看表编码123show create table &lt;表名&gt;;例：show create table user; 查看字段编码123show full columns from &lt;表名&gt;;例： show full column from user; 修改数据库编码格式12alter database &lt;数据库名&gt; character set utf8mb4;例：alter database db_user character set utf8mb4; 修改表编码12alter table &lt;表名&gt; character set utf8mb4;例：alter table user character set utf8mb4; 修改字段编码12ALTER TABLE &lt;表名&gt; MODIFY COLUMN &lt;字段名&gt; &lt;字段类型&gt; CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;例：ALTER TABLE comment MODIFY COLUMN content VARCHAR(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 查询sql不走缓存1SELECT SQL_NO_CACHE * FROM users; 修改表字符集和校对集123ALTER TABLE userCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci; 修改数据库字符集和校对集123ALTER DATABASE mydataCHARACTER SET utf8mb4COLLATE utf8mb4_general_ci; 修改表字段相关信息1ALTER TABLE `job_auth_record` CHANGE `id` `id` VARCHAR(32) CHARACTER SET utf8mb4 NOT NULL COMMENT '主键id'; Mysql ASC 和 DESC 索引 怎么走的 ？？？分组差查询数量 超级吊123456SELECTcompany_id,count(*) AS countsFROM seeker_jobWHERE company_id IN ("8a9c889c5dcbe37c015dcf16e284001f", "04be17537c5e4b299c135eeaadb5e131")GROUP BY company_id; 修改校验集12345ALTER TABLE insurance_insured CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;ALTER TABLE insurance_insured CHARACTER SET utf8mb4;ALTER TABLE `insurance_insured` CHANGE `name` `name` varchar(64) COLLATE utf8mb4_general_ci DEFAULT NULL; 忽略某个索引1SELECT * FROM seeker_job IGNORE INDEX(idx_modify_time) DISTINCT COUNT12SELECT count(DISTINCT j1.job_id,j1.agent_company_id)FROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id = j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ; DISTINCT12SELECT DISTINCT j1.job_id,j1.agent_company_idFROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id = j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ; 查找重复字段记录https://www.cnblogs.com/jiangxiaobo/p/6589541.html 修改表编码个字符集123456ALTER TABLE apply_stencil CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;ALTER TABLE apply_stencil MODIFY COLUMN id VARCHAR(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;ALTER TABLE apply_stencil MODIFY COLUMN apply_id VARCHAR(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 查询一个库里面有多少表1SELECT COUNT(*) TABLES, table_schema FROM information_schema.TABLES WHERE table_schema = 'goabroad']]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim学习]]></title>
    <url>%2F2019%2F04%2F15%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim学习笔记Vim三种模式基本上vi分为三种模式，分别是一般模式、编辑模式与命令行模式 一般模式打开一个文件默认就进入到一般模式（这是默认的模式）。在这个模式中你可以使用上下左右了来移动光标，你可以删除字符或者删除整行，也可以复制粘贴你的文件数据。 编辑模式在vi一般模式下，不能进行编辑。等到按下a、s、i、o、c之后，就会进入编辑模式。左下方会出现INSERT或REPLAC的字样，此时才可以进行编辑。若想要退出编辑模式，需要按ESC。 命令行模式在一般模式中输入，“:、/、？”3个中的任何一个按钮，就可以将光标移动到最下面那一行。 快捷键1hjkl 左下上右 12ctrl+f pagedown 向下翻页ctrl+b pageup 向上翻页 1230 home 移动到当前行最前n 空格 移动n个字符$ end 移动到当前行最后 1234G 移动到文件最末行nG 移动到第n行gg 首行n+enter 向下移动n行 12:n1,n2s/word1/word2/g 在n1到n2之间找到word1，并将wor1替换为word2:1,$s/word1/word2/g 在第一行到最后一行查找word1，并替换为word2 12x,X x向前删除 X向后删除nx n为数字 连续向后删除n个字符 123456dd 删除光标所在的整行ndd 删除所在的向下的几行d1G 删除光标所在到第一行的所有数据dg 删除从光标所在到最后一行的所有数据d$ 删除从光标所在处到该行的最后一个字符d0 删除从光标所在出到该行的最前面一个字符 1234567yy 复制光标所在的那一行nyy 复制光标所在的向下n行p,P p将已复制的数据在光标下一行粘贴，P将已复制的数据在光标上一行粘贴y1G 复制光标所在行到第一行的所有数据yG 复制光标所在行到最后一行的所有数据y0 复制光标所在的那个字符到该行行首的所有数据y$ 复制光标所在的那个字符到该行行尾的所有数据 常用命令1234567891011121314常规模式 / 进行搜索u撤销刚才得到动作ctrl+r是撤销刚才撤销的动作ctrl+u 删除当前行yy复制当前行dd删除当前行p粘贴u撤销查找 /pattern 往后查找?pattern 向前查找n下一个N上一个ggVG 全选 gg到起始行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CURL工具学习]]></title>
    <url>%2F2019%2F04%2F08%2Fcurl%2F</url>
    <content type="text"><![CDATA[curl是什么curl (Command Line URL viewer)是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在“标准输出”（stdout）上面。 查看网页源码直接在curl后面加上网址，就可以看到网页源码。1curl dullnull.org 12345678&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;&lt;hr/&gt;Powered by Tengine&lt;/body&gt;&lt;/html&gt; 如果要保存这个网页，可以使用 -o 参数1curl -o fileName dullnull.org 自动跳转有的网页是自动跳转的。使用 -L 参数，curl就会跳转到新的网址。1curl -L dullnull.org 键入上面命令，就会直接跳转到https://dullnull.org 显示头信息-i 参数可以显示http response 的头信息，连同网页代码一起。1curl -i dullnull.org 12345678910111213141516171819HTTP/1.1 301 Moved PermanentlyServer: TengineDate: Sat, 13 Apr 2019 08:55:26 GMTContent-Type: text/htmlContent-Length: 278Connection: keep-aliveLocation: https://dullnull.org/Via: kunlun8.cn314[,0]Timing-Allow-Origin: *EagleId: ca6cf99c15551457264052744e&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;&lt;hr/&gt;Powered by Tengine&lt;/body&gt;&lt;/html&gt; 显示通信过程-v 参数可以显一次http通信的整个过程，包括端口连接和http request 头信息。1curl -v dullnull.org 12345678910111213141516171819202122232425262728* Rebuilt URL to: dullnull.org/* Trying 202.108.249.197...* Connected to dullnull.org (202.108.249.197) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: dullnull.org&gt; User-Agent: curl/7.47.0&gt; Accept: */*&gt; &lt; HTTP/1.1 301 Moved Permanently&lt; Server: Tengine&lt; Date: Sat, 13 Apr 2019 08:57:09 GMT&lt; Content-Type: text/html&lt; Content-Length: 278&lt; Connection: keep-alive&lt; Location: https://dullnull.org/&lt; Via: kunlun8.cn314[,0]&lt; Timing-Allow-Origin: *&lt; EagleId: ca6cf99c15551458295975589e&lt; &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;&lt;hr/&gt;Powered by Tengine&lt;/body&gt;&lt;/html&gt;* Connection #0 to host dullnull.org left intact 如果你觉得上面的信息还不够，可以使用1curl --trace output.txt 运行后，打开output.txt 查看 发送表单信息GET请求1curl example.com/form.cgi?data=xxx POST请求1curl -X POST --data "data=xxx" example.com/form.cgi HTTP 动词curl默认动词是GET，使用 -X 参数 可以支持其他参数1curl -X POST dullnull.org 1curl -X PUT dullnull.org 文件上传1curl -T file.txt url Referer1curl --referer http://www.example.com http://www.example.com User Agent1curl --user-agent "[User Agent]" [URL] cookie1curl --cookie "name=xxx" www.example.com 增加头信息1curl --header "Content-Type:application/json" http://example.com]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestFul API设计指南]]></title>
    <url>%2F2019%2F04%2F01%2Frestful%2F</url>
    <content type="text"><![CDATA[RESTful是什么REST（Representational State Transfe）是一种架构风格，遵循REST原则的架构我们就称为RESTful架构。Representational State Transfe 直译过来就是【表现层状态转化】，其实它省略了主语，表现层指的是【资源】的表现层，通俗的讲就是：资源在网络中以某种形式进行状态转移。 为什么要用RESTfulRESTful 给人的感觉是优雅、规范、易懂，一个结构清晰、易于理解的API完全可以省略许多无意义的沟通和文档。大家都使用相同的标准，有利于团队的整体效率。 接口设计一般接口就是增删改查，RESTful API就像通用的模板，我们以文章（Article）举例，那么基础的URL就有一下几种： GET /articles: 文章列表 GET /articles/id: 文章详情 POST /articles: 创建文章 PUT /articles/id: 修改文章 DELETE /articles/id: 删除文章 RESTful 中使用GET、POST、PUT和DELETE来分别表示资源的查询、创建、更新和删除，并且除了POST其他三种都具备幂等性（多次请求效果相同），POST和PUT最大的区别就是幂等性，所以PUT也可以用于创建，只要在创建前就确定好资源的id。 将id放到URL中而不是Query Param的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的URL应该是这样的： GET /articles/aid/comments: 某篇文章的评论列表 GET /comments/cid: 获取某文章的某评论详情 POST /articles/aid/comments: 在某篇文章中创建评论 PUT /comments/cid: 修改评论 PUT /comments/cid: 删除评论 这里有一点比较特殊，永远去使用可以指向资源的最短URL路径，也就是说既然/comments/cid:已经可以指向一条评论了，就不需要/articles/id/comments/cid:特意的指出所属的文章了。 GET /articles/id/like: 查看文章是否被点赞 PUT /articles/id/like: 点赞文章 DELETE /articles/id/like: 取消点赞 接口版本随着业务的调整，可能老接口不能再满足业务需求。这个时候我们尽可能加字段，或者新加接口。例如：1api.github.com/v1/users Token和SignAPI需要设计成无状态的，所以客户端在某些请求中需要带上token或者sign。 Token 用于监听请求所属用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或者重置TOKEN生存时间（类似于缓存的机制），另一种是TOKEN的生存时长固定不变。 Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后加密作为Sign传给服务端，这样即使被抓包了，对方修改参数而无法生成对应Sign也会被识破。 业务参数搜索1/users/?query=iisheng 过滤1/users/?gender=1 统计参数这个一般可能的实现方案，是在行为接口后面添加参数像，业务参数一样，还有一种实现方案是单独写一个接口，只做统计用，我感觉这种方式更好一些。 分页1/users/?offset=10&amp;limit=10 1/articles/?cursor=2015-01-01 15:20:30&amp;limit=10 1/users/?page=2&amp;pre_page=20 返回数据 Json比Xml可视化更好，也更省流量所以尽量使用Json。 创建和修改成功后需要返回该资源的全部信息。 返回数据不需要和客户端界面耦合。不要在API设计的时候就考虑少返回几个字段，少一次查询（比如用join）能带来多大性能提升。一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回。而是让客户端分别请求多个接口（也可以使用一个单独的服务（API网关），内部RPC调用基础服务，构造客户端需要的数据，返回给客户端，这样，客户端可以只调用少量接口）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet源码解析]]></title>
    <url>%2F2019%2F03%2F25%2Fservlet%2F</url>
    <content type="text"><![CDATA[一个简单的Servlet请求 新建HelloController继承HttpServlet 在web.xml中，注册HelloController，或者使用@WebServlet注解注册HelloController 重写doGet()，doPost()或者其他doXxx()方法 Servlet请求参数HttpServletRequest和HttpServletResponse是doXxx()方法的默认参数。 HttpServletRequestHttpServletRequest代表浏览器发送给服务器的请求报文。该对象由web服务器创建（如Tomcat），最终作为参数传递到doXxx()或者其他方法中，我们可以在doXxx()方法中直接使用 获取用户发送的请求参数 1request.getParmater("name"); 获取项目的名字 1request.getContextPath(); 作为一个域对象，在不同的web资源之间共享数据。 请求和转发1request.getRequestDispatcher("target.html").forward(request,response); HttpServletResponseHttpServletResponse代表服务器发送给浏览器的响应报文。该对象由web服务器创建（如Tomcat），最终将作为参数传递到doXxx()方法中，我们可以在doXxx()方法中直接使用。 响应给浏览器一个网页或者Json数据等 12PrintWriter printWriter = response.getWriter();printWriter.writer(Hello Servlet~); 请求的重定向 1response.sendRedirect("target.html"); 转发和重定向的区别 转发 重定向 请求的次数 1 2 发生的位置 服务器内部 浏览器 浏览器地址 不改变 改变 过滤器通过实现Filter接口，完成我们自定义的过滤器功能。过滤器有以下功能： HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest 根据需要检查HttpServletRequest，也可以修改HttpServletRequest的头和数据 在HttpservletResponse到达客户端之前，拦截HttpServletResponse 根据需要检查HttpServletResponse，也可以修改HttpServletReponse的头和数据 监听器监听器可以监听客户端的请求，服务端的操作，通过监听自动激发一些操作。监听器主要有以下几种： ServletContextListener:对应所有用户 ServletSessionListener:对应于一个用户 ServletRequestListener:对应用一个请求我们可以实现上面的接口，去完成监听事件。 Servlet生命周期 通过调用init()方法初始化Servlet实例 调用service()方法处理请求 调用相应的请求方式的方法比如post请求，调用doPost()方法 停止服务的时候，调用destroy()方法 HttpServlet类图关系 Servlet工作流程 浏览器发出Http请求到Servlet容器 Servlet容器生成HttpServletRequest和HttpServletResponse Servlet将HttpServletRequest和HttpServletResponse参数传递给Filter,Filter处理过滤请求 Filter将HttpServletRequest和HttpServletResponse传递给Servlet,Servlet处理请求 Servlet处理完请求后,将数据返回给Filter,Filter返回给Servlet容器,Servlet容器再返回给浏览器]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码解析之ArrayList]]></title>
    <url>%2F2019%2F03%2F18%2Farraylist%2F</url>
    <content type="text"><![CDATA[JDK版本 JDK 8 ArrayList类图ArrayList继承AbstractList，实现了List，Collection接口。 ArrayList属性以及方法图 ArrayList属性字段介绍12345678910long serialVersionUID // 序列化UIDint DEFAULT_CAPACITY // 默认容量Object[] EMPTY_ELEMENTDATA // 空数组,空的实例对象共享该空数组DEFAULTCObject[] APACITY_EMPTY_ELEMENTDATA // 对于空的默认size的实例对象,共享DEFAULTCAPACITY_EMPTY_ELEMENTDATA该空数组int size // 数组元素size(它包含的元素的数量) ArrayList方法介绍构造方法 public ArrayList(int initialCapacity) // 带默认容量参数的构造方法 public ArrayList() // 无参构造方法 public ArrayList(Collection&lt;? extends E&gt; c) // 参数是一个Collection的构造方法 扩容方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 增加ArrayList实例的容量 * 确保至少能装下参数值的数量的元素 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It's already supposed to be // at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 增加容量确保至少能装下参数值数量的元素 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 插入方法12345678910111213141516171819202122/** * 在list末尾添加新元素 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;/** * 在特定的位置插入新的元素 * 将在右面位置的元素右移一位 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 移除方法123456789101112131415161718192021222324252627282930313233343536373839/** * 移除特定位置的元素 * 将在右面位置的元素左移一位 */public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * 移除第一个出现的特定的元素值 * 不存在返回false */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 序列化方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 将ArrayLisy实例的状态保存到一个流里面 * 就是序列化 */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // 按照顺序写入所有的元素 for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * 根据一个流(参数)重新生成一个ArrayList * 就是反序列化 */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 分析总结ArrayList是List接口可调整数组大小的实现。实现了所有的List操作，允许包括null在内的所有元素。ArrayList是非线程同步的。扩容是按照原来容量的1.5倍。ArrayList继承AbstractList，通过modCount记录修改次数。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch学习总结]]></title>
    <url>%2F2019%2F03%2F11%2Felasticsearch%2F</url>
    <content type="text"><![CDATA[ElasticSearch 基本概念节点（node）一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是有一个名字标识。 索引（index）一个索引就是一个拥有几个相似特征的文档集合。索引由一个名字来标识（必须全部小写字母）。 类型（type）在一个索引中你可以定义一种或多种类型。一个类型是你逻辑上的分类/分区。 文档（document）一个文档是可被索引的基本信息单元，文档以JSON格式来表示。 分片和复制（shards &amp; replicas）一个索引可以存储超过单个节点硬件限制的大量数据。ElasticSearch提供了将索引划分成多份的能力，这些份就叫做分片。当创建一个索引的时候，可以指定分片的数量。每个分片本身也是一个功能完善，并且独立的索引，这个索引可以被放置到集群中的任何节点上。 分片之所以重要，主要有以下两点：（1）允许水平分割/扩展内容容量（2）允许在分片之上进行分布式的并行的操作，进而提高性能、吞吐量。 在一个网络环境里失败随时可能发生，在某个分片或者节点不知道怎么就处于离线状态，或者任何原因消失了，这种情况下有一种故障转移机制是非常有用并且强烈推荐的。因此，EleasticSearch可以创建一份或者多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。 复制之所以重要，主要有以下两点： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原始分片置于同一节点上是非常重要的 扩展了搜索量/吞吐量，因为搜索可以在所有的复制上并行。 ElasticSearch 常用curl增加索引mapping新字段1curl -XPUT http://127.0.0.1:9201/job_index_v6/_mapping/b2b -d '&#123;"properties":&#123;"new_field_name":&#123;"type":"string"&#125;&#125;&#125;' 查看集群是否健康 1curl 'localhost:9201/_cat/health?v' 列出所有索引1curl 'localhost:9201/_cat/indices?v' 获取集群的节点列表1curl 'localhost:9201/_cat/nodes?v' 删除索引1curl -X DELETE 127.0.0.1:9201/agent_job_index 给索引设置别名1curl -X PUT 127.0.0.1:9201/job_index_v6/_alias/job_index 查看指定索引的mapping1curl -XGET "http://127.0.0.1:9201/job_index_v6/_mapping?pretty" 清除指定索引 数据1curl -XPOST '127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty' -H 'Content-Type: application/json' -d '&#123;"query":&#123;"match_all":&#123;&#125;&#125;&#125;' 根据查询删除1curl -XPOST '127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty' -H 'Content-Type: application/json' -d '&#123;"query":&#123;"term":&#123;"userId":"1017"&#125;&#125;&#125;' 搜索1curl -X POST http://127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"term":&#123;"indexStatus":"1"&#125;&#125;&#125;' | python -m json.tool 1curl -X POST http://127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"bool":&#123;"filter":[&#123;"match":&#123;"is2CJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"isAgentJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"switchStatus":&#123;"query":2&#125;&#125;&#125;]&#125;&#125;&#125;' | python -m json.tool 搜索最大值1curl -XPUT http://127.0.0.1:9200/job_index_v6/_settings -d '&#123; "index" : &#123; "max_result_window" : 20000&#125;&#125;' 设置默认值1curl -POST 127.0.0.1:9201/job_index_v6/job/_update_by_query -d '&#123;"script":&#123;"lang":"painless","inline":"if (ctx._source.is2CJob == null) &#123;ctx._source.is2CJob= 'true'&#125;"&#125;&#125;' 添加一条数据1curl -XPOST 'localhost:9201/job_index_v6/job/22c3cade5f5a4f189f6145cb0b15b737?pretty' -d'&#123;"id":"22c3cade5f5a4f189f6145cb0b15b737","sourceId":"22c3cade5f5a4f189f6145cb0b15b737","label":0,"userId":"8a1026775d16fbb2015d17a4771a0348","name":"1231231","operatorName":null,"refuseReason":null,"description":"2","workAddress":"韩国","countryId":[513114,513100,510000],"countryNames":["韩国"],"salary":3000,"salaryHigh":4000,"listPrice":2222,"channelPrice":0,"status":2,"indexStatus":2,"is2CJob":true,"deposit":500,"modifyTime":1546593027000,"createTime":1546593027000,"refreshTime":1546593027000,"companyId":"8a1026775981103b01598110cee70004","heat":0,"praise":0,"applyment":0,"comment":0,"browseNumber":0,"postName":["建筑","电工"],"post":[111200,110000,111220],"tagName":[],"tag":[],"systemTag":[],"allTag":[2215],"businessLine":237,"score":63393027,"newOldFlag":1,"switchStatus":0,"agentQuantity":0,"company.name":"北京走出趣科技发展有限公司","company.shortName":"走出趣","company.tag":[2215],"company.location":[110000,110100,110108],"company.status":1&#125;' 查看 索引 设置1curl -XGET "http://zcq-product2:9200/job_index_v6/_settings?pretty" 查看ElasticSearch状态1curl 'localhost:9201' | python -m json.tool 按照排序搜索1curl -POST http://test2.51zouchuqu.com:9201/job_rcmd_score_index/score/_search -d '&#123;"from":0,"size":1000,"query":&#123;"bool":&#123;"disable_coord":false,"adjust_pure_negative":true,"boost":1&#125;&#125;,"explain":false,"sort":[&#123;"score":&#123;"order":"desc"&#125;&#125;]&#125;' ElasticSearch 备份、导入、导出es 数据导入导出12npm install elasticdump./bin/elasticdump 123456index-&gt;index:elasticdump --input=http://localhost:9200/test --output=http://localhost:9200/testindex-&gt;file:elasticdump --input=http://localhost:9200/test --output=./json.logfile-&gt;index:elasticdump --input=./json.log --output=http://localhost:9200/test]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令速查笔记]]></title>
    <url>%2F2019%2F03%2F04%2Fgit%2F</url>
    <content type="text"><![CDATA[git clonegit clone url 将远程git仓库克隆到本地 git initgit init 在当前目录新建一个git仓库 gitk打开git仓库图形界面 git status显示所有变更信息 git clean -fd删除所有Untracked files git stash将未add到Stage区的文件，暂时存储起来 git stash apply将git stash 暂时存储起来的文件，恢复，然后就可以继续add到Stash区 git fetch remote下载远程仓库的所有更新 git pull romote branch-name下载远程仓库的所有更新，并且Merge git config 配置123git config --global gui.encoding=utf-8 配置git图形界面编码为utf-8git config --global user.name name 设置提交代码时的用户名git config --global user.email email 设置提交代码时的邮箱 git remote 远程仓库操作12git remote -v 显示所有远程仓库git remote add name url 增加一个新的远程仓库 git add 添加文件到Stage区123456git add --all 添加所有的修改到Stage区git add file 添加指定文件到Stage区git add file1 file2 添加多个修改的文件到Stage区git add dir 添加修改的目录到Stage区git add 添加当前目录的所有修改到Stage区git add src/main* 添加所有src目录下main开头的所有文件到Stage区 git commit 提交Stage区的代码到本地仓库123git commit -m "message" 提交Stage区的代码到本地仓库区git commit file1 file2 -m "message" 提交Stage中在指定文件到本地仓库区git commit --amend -m "message" 使用新的一次commit，来代替上一次commit，新的message也会替换上一次message git branch 分支12345git branch 列出本地所有分支git branch -r 列出远程所有分支git branch branch-name 新建一个分支，但依然停留在当前分支git branch -d branch-name 删除分支git branch --set-upstream-to origin/feature/company feature/company 设置分支上游 git checkout 切换/撤销1234git checkout -b 本地分支名x origin/远程分支名x 创建本地分之并关联远程分支git checkout -b branch-name 新建一个分支，且切换到新分支git checkout branch-name 切换到另一个分支git checkout commit-file 撤销工作区文件的修改，跟上次Commit一样 git push 向远程服务器推代码12345678git push origin :master 删除远程分支git push origin --delete tag &lt;tagname&gt; 删除远程分支git push reomte branch-name 上传本地仓库到远程分支git push reomte branch-name --force 强行推送当前分支到远程分支git push remote --all 推送所有分支到远程仓库git push --tags 推送所有标签git push origin tag-name 推送指定标签git push origin :refs/tags/tag-name 删除远程标签（需要先删除本地标签） git reset 重置/回退123456git reset HEAD * 将上次add 到Stage区的文件 删除git reset --hard 重置Stage区和工作区的所有文件和上次Commit的一样git reset --hard origin/master 重置Commit代码和远程分支代码一样git reset --hard HEAD^ 回退到上个版本git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前git reset --hard commit-id 退到/进到 指定commit的sha码 git tag 标签12345git tag -a v1.4 -m 'my version 1.4' 创建带有说明的标签git tag tag-name 打标签git tag 查看所有标签git tag tag-name commit-id 给指定commit打标签git tag -d tag-name 删除标签 git diff1234git diff file-name 查看文件在工作区和暂存区区别，也可查看工作区修改前后的区别git diff branch-name file-name 查看文件和另一个分支的区别git diff --cached file-name 查看暂存区和本地仓库区别fid diff commit-id commit-id 本地仓库两次提交区别 感觉还是idea好用啊。 git show12git show tag-name 查看指定标签的提交信息git show commit-id 查看具体的某次改动 git log12345git log --pretty=oneline 文件名 查看该文件的改动历史git log --graph --pretty=oneline --abbrev-commit 格式化查看历史提交git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 统计仓库提交排名前5git log --author="goodgoodstate" --pretty=tformat: --numstat | gawk '&#123; add += $1 ; subs += $2 &#125; END &#123; printf "added lines: %s removed lines : %s \n",add,subs &#125;'查看指定用户添加代码行数，和删除代码行数 git merge 合并代码，自动创建合并commit1git merge branch-name 将指定分支合并到当前分支 git rebase 合并代码，不会创建合并commit1git merge branch-name 将指定分支合并到当前分支 rebase 操作比较危险，因为它重写了commit历史，但是rebase可以得到干净的commit历史（个人很推荐）。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令速查笔记]]></title>
    <url>%2F2019%2F02%2F25%2Flinux%2F</url>
    <content type="text"><![CDATA[cd 进入指定目录12345cd dir // 进入当前目录的子目录cd .. // 进入当前目录的上一级目录cd / // 进入系统根目录cd ~ // 进入当前用户主目录cd /usr/local // 进入特定目录 ls 列出当前目录文件123456ls -a // 列出当前目录所有文件，包含隐藏文件ls -l // 列出长数据串，包含文件的权限和属性 相当于 llls -i // 显示文件节点索引号ls -t // 按照修改时间，降序显示ls -rt // 按照修改时间，升序显示ls -alht // 按照修改时间，降序显示 h显示文件大小 个人感觉 ll -h 比较好用 mv 修改文件名字或移动位置12mv file newname // 更改文件名字mv /dir/file /otherdir // 移动文件位置 rm 删除123rm -rf dir // 递归删除指定目录中的所有文件rm file // 删除指定文件rm -rf * // 递归删除当前目录中的所有文件 cp 复制12cp -r /dir /other-dir // 将dir目录下所有文件，移动到other-dir目录中cp fileA fileB // 备份A文件，并改名 kill 杀进程12kill -9 PID // 将PID进程结束kill -17 PID // 将PID进程暂停 chown 修改文件所属用户或用户组12chown -R root:root /tmp // 修改 tmp 目录所属用户为 root，用户组为 rootchown iisheng file // 将file的所有者设置为iisheng chmod 给文件设置别人访问权限12chmod 766 file // 给某个文件别人访问权限chmod 777 * // 当前文件夹所有文件所有用户都可以读写 cat 查看文件或写到指定文件内容12345cat file // 显示整个文件内容cat -n file // 显示整个文件内容，并由1开始对行数编号cat file &gt; newFile // 将文件的内容写到新文件里面cat file | head -n 3000 | tail -n +1000 // 查看文件的1000-3000行cat /proc/PID/status // 查看指定进程的相关信息 scp 终端远程下载上传文件1234scp root@dullnull.org:/path/filename ./ // 文件下载到本地当前目录scp -P 2222 /home/jdk.tar.gz root@dullnull.org:/root/jdk.tar.gz // 上传文件scp -P 2222 -r /home/jdk/ root@isheng.me // 上传文件目录scp -P 2222 -r /home/jdk/ root@isheng.me // 使用IPV6寻址上传文件目录 netstat 打印网络信息状态123456netstat -at // 列出所有TCP端口netstat -au // 列出所有UDP端口netstat -lt // 列出所有监听TCP的端口netstat -lu // 列出所有监听UDP的端口netstat -r // 显示核心路由信息netstat -anl | grep 8888 // 查看相关端口号信息 top 实时系统的查看系统运行情况123top // 动态查看系统的整体运行情况top -p PID // 查看指定进程的运行情况top -u user // 查看指定用户的相关进程的运行情况 htop 和top类似功能 sed 处理文件并在控制台打印12sed 's/book/books/' file // s 替换指定 字符，将book替换为bookssed -i 's/book/books/g' file // g 替换文本中内容 -i 直接编辑文本选项 匹配文件中第一个book替换为books 这个东西很多功能的，暂时不详细学习 less 从头查看日志1234shift+g 跳转到文件底部按f键,是向前(下)查看 forword按b键,是向后(上)查看 backwordq 退出 more 从头查看日志123more file按ctrl+f键,是向前(下)查看 forword按ctrl+b键,是向后(上)查看 backword tail 动态查看文件尾部内容1tail -500f file // 动态查看文件尾部500行 head 显示文件开头内容1head -100f file // 查看文件前100行 rar 解压rar文件或压缩为rar文件1rar x -ep2 filename // 将Windows rar文件 解压 utf-8编码的文件 unzip 解压zip文件或压缩为zip文件123unzip -d fileDir file.zip // zip 文件 解压unzip fileName // 文件解压缩到当前目录unzip -O cp936 file.zip //将Windows文件以utf-8编码解压缩 service 启动查看进程状态12service sshd status // 查看sshd的运行状态service sshd start // 启动服务 systemctl 启动查看进程状态12systemctl status httpd.service // 查看httpd服务状态systemctl enable httpd.service // 启动服务 安装、卸载软件12sudo agt-get install git // 安装gitsudo apt-get --purge remove git // 卸载git dpkg12sudo dpkg -i *.deb // 安装.deb文件的软件sudo dpkg -P *.deb // 卸载.deb文件的软件 shutdown12shutdown -h now // 关机shutdown -r now // 重启 df1df -lh // 查看系统硬盘使用情况 du123du -sh // 查看文件目录大小du -ah // 查看文件目录下面各个文件大小du -h --max-depth=1 ./ // 查看当前目录大小 find 查找12find . -name "*.c" | xargs grep -H "intern(" // 查找当前目录指定文件后缀包含指定字符的结果find /home -name '*.md' // 查找指定目录包含指定字符串 的文件名路径 grep 全面搜索正则表达式并把行打印出来12grep -rn "hello,world!" * // 在当前目录查找 hello,world 字符串grep 'model name' /proc/cpuinfo | wc -l // 查看系统有几个CPU 一般配合别的命令一起使用效果很强大 ps 显示当前进程状态12ps aux | grep nginx // 根据名字查找进程ps -ef | grep elastic // 根据名字查找进程 lsof 查看进程打开的端口，查看打开文件的进程1lsof -i:8888 // 根据端口号查看相关进程信息 iconv 转换文件编码12iconv -f gb2312 file -o newFile // 将Windows文件转换为Linux识别的文件iconv -f gbk -t utf8 file &gt; bewFile // 将Windows文件转换为Linux识别的文件 curl 文本传输工具1234curl -H 'Content-Type:application/json' https://api.github.com -s | python -m json.tool // GET请求curl -X PUT 127.0.0.1:9200/job_index/_mapping/job -d '&#123;"properties":&#123;"new_field":&#123;"type":"integer"&#125;&#125;&#125;' // PUT请求curl -X DELETE 127.0.0.1:9200/agent_job_index // DELETE请求curl -X POST 127.0.0.1:9200/job_index/job/_search -d '&#123;"query":&#123;"term":&#123;"id":"1"&#125;&#125;&#125;' // POST请求]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
