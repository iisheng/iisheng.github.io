<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UML科普文，一篇文章掌握14种UML图</title>
    <url>/2020/04/30/uml/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>22张图讲解UML2.0的14种图…</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章写了一篇建造者模式，其中有几个UML类图，有的读者反馈看不懂了，我们今天就来解决一哈。</p>
<h2 id="什么是UML？"><a href="#什么是UML？" class="headerlink" title="什么是UML？"></a>什么是UML？</h2><p><code>UML</code>是<code>Unified Model Language</code>的缩写，中文是<code>统一建模语言</code>，是由一整套图表组成的标准化建模语言。</p>
<h2 id="为什么要用UML？"><a href="#为什么要用UML？" class="headerlink" title="为什么要用UML？"></a>为什么要用UML？</h2><p>通过使用UML使得在软件开发之前，<br>对整个软件设计有更好的可读性，可理解性，从而降低开发风险。同时，也能方便各个开发人员之间的交流。</p>
<p>UML提供了极富表达能力的建模语言，可以让软件开发过程中的不同人员分别得到自己感兴趣的信息。</p>
<p><code>Page-Jones</code> 在《Fundamental Object-Oriented Design in UML》 一书中总结了UML的主要目的，如下：</p>
<ol>
<li>为用户提供现成的、有表现力的可视化建模语言，以便他们开发和交换有意义的模型。</li>
<li>为核心概念提供可扩展性 (Extensibility) 和特殊化 (Specialization) 机制。</li>
<li>独立于特定的编程语言和开发过程。</li>
<li>为了解建模语言提供一个正式的基础。</li>
<li>鼓励面向对象工具市场的发展。</li>
<li>支持更高层次的开发概念，如协作，框架，模式和组件。</li>
<li>整合最佳的工作方法 (Best Practices)。</li>
</ol>
<h2 id="UML图有哪些？"><a href="#UML图有哪些？" class="headerlink" title="UML图有哪些？"></a>UML图有哪些？</h2><ul>
<li>UML图分为结构图和行为图。</li>
<li>结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。</li>
<li>行为图又分活动图、用例图、状态机图和交互图。</li>
<li>交互图又分为序列图、时序图、通讯图、交互概览图。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/uml-diagram.png?1"><br></center>

<h2 id="UML图概览"><a href="#UML图概览" class="headerlink" title="UML图概览"></a>UML图概览</h2><center><br>    <img src="https://img.iisheng.cn/uml-overview.png?1"><br></center>

<h2 id="什么是类图？"><a href="#什么是类图？" class="headerlink" title="什么是类图？"></a>什么是类图？</h2><ul>
<li>【概念】<br>类图是一切面向对象方法的核心建模工具。类图描述了系统中对象的类型以及它们之间存在的各种静态关系。</li>
<li>【目的】用来表示类、接口以及它们之间的静态结构和关系。</li>
</ul>
<blockquote>
<p>在类图中，常见的有以下几种关系。</p>
</blockquote>
<h3 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h3><ul>
<li>【泛化关系】是一种继承关系，表示子类继承父类的所有特征和行为。</li>
<li>【箭头指向】带三角箭头的实线，箭头指向父类。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/generalization.png?1"><br></center>

<h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><ul>
<li>【实现关系】是一种类与接口的关系，表示类是接口所有特征和行为的实现。</li>
<li>【箭头指向】带三角箭头的虚线，箭头指向接口。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/realization.png?1"><br></center>


<h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><ul>
<li>【关联关系】是一种拥有关系，它使得一个类知道另一个类的属性和方法。</li>
<li>【代码体现】成员变量</li>
<li>【箭头指向】带普通箭头的实线，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。单向的关联有一个箭头。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/association.png?1"><br></center>

<blockquote>
<p>自己买的车，想什么时候开就开。但是车是车，人是人，没有整体与部分的关系。</p>
</blockquote>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><ul>
<li>【聚合关系】是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li>
<li>【代码体现】成员变量</li>
<li>【箭头指向】带空心菱形的实线，空心菱形指向整体。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/aggregation1.png"><br></center>

<blockquote>
<p>电脑有键盘才能输入信息，电脑是整体，键盘是部分，键盘也可以离开电脑，单纯的拿去敲。所以是聚合。</p>
</blockquote>
<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><ul>
<li>【组合关系】是一种整体与部分的关系。但部分不能离开整体而单独存在，组合关系是关联关系的一种，是比聚合关系还要强的关系。</li>
<li>【代码体现】成员变量</li>
<li>【箭头指向】带实心菱形和普通箭头的实线，实心菱形指向整体。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/composition1.png"><br></center>

<blockquote>
<p>鸟是整体，翅膀是部分。鸟死了，翅膀也就不能飞了。所以是组合。我们再看一下，下面的一组经典的聚合组合关系的例子。</p>
</blockquote>
<center><br>    <img src="https://img.iisheng.cn/aggregation-composition.png"><br></center>

<blockquote>
<p>一个公司拥有多个部门，公司和部门之间是组合关系，公司破产了，部门就不复存在了。部门和员工是聚合关系，部门被裁掉，员工就换下家了。</p>
</blockquote>
<h3 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h3><ul>
<li>【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。</li>
<li>【箭头指向】带普通箭头的虚线，普通箭头指向被使用者。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/dependency.png?1"><br></center>

<blockquote>
<p>老司机只管开车，车是谁的不重要，给什么车开什么车。</p>
</blockquote>
<h2 id="什么是组件图？"><a href="#什么是组件图？" class="headerlink" title="什么是组件图？"></a>什么是组件图？</h2><ul>
<li>【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。</li>
<li>【目的】用来展示各个组件之间的依赖关系。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/component-diagram.png?1"><br></center>

<blockquote>
<p>订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。</p>
</blockquote>
<h2 id="什么是部署图？"><a href="#什么是部署图？" class="headerlink" title="什么是部署图？"></a>什么是部署图？</h2><ul>
<li>【概念】描述了系统内部的软件如何分布在不同的节点上。</li>
<li>【目的】用来表示软件和硬件的映射关系。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/deployment-diagram.png?1"><br></center>

<blockquote>
<p>图中简单的表示，不同机器上面部署的不同软件。</p>
</blockquote>
<h2 id="什么是对象图？"><a href="#什么是对象图？" class="headerlink" title="什么是对象图？"></a>什么是对象图？</h2><ul>
<li>【概念】对象图是类图的一个实例，是系统在某个时间点的详细状态的快照。</li>
<li>【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/object-diagram.png?1"><br></center>

<blockquote>
<p>图中就是描述的，某时间点<code>bat</code>这个公司有一个研发部，一个销售部，两个部门只有一个人<code>iisheng</code>。</p>
</blockquote>
<h2 id="什么是包图？"><a href="#什么是包图？" class="headerlink" title="什么是包图？"></a>什么是包图？</h2><ul>
<li>【概念】描绘了系统在包层面上的结构设计。</li>
<li>【目的】用来表示包和包之间的依赖关系。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/package-diagram.png?1"><br></center>

<ul>
<li>《Use》关系表示使用依赖，<code>Web Shopping</code>依赖<code>Payment</code></li>
<li>《Merge》关系表示合并，<code>Web Shopping</code>合并了<code>Shopping Cart</code>就拥有了<code>Shopping Cart</code>的功能</li>
<li>《Access》关系表示私有引入，比如代码中的指定包名类名</li>
<li>《Import》关系表示公共引入，比如Java中的<code>import</code>之后，就可以直接使用<code>import</code>包中的类了。</li>
</ul>
<h2 id="什么是组合结构图？"><a href="#什么是组合结构图？" class="headerlink" title="什么是组合结构图？"></a>什么是组合结构图？</h2><ul>
<li>【概念】描述了一个”组合结构”的内部结构，以及他们之间的关系。这个”组合结构”可以是系统的一部分，或者一个整体。</li>
<li>【目的】用来表示系统中逻辑上的”组合结构”。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/composite-structure-diagram.png"><br></center>

<blockquote>
<p>图中描述了<code>Car</code>是由车轴连接着的两个前面轮子、两个后面轮子，和引擎组合的。</p>
</blockquote>
<h2 id="什么是轮廓图？"><a href="#什么是轮廓图？" class="headerlink" title="什么是轮廓图？"></a>什么是轮廓图？</h2><ul>
<li>【概念】轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制UML模型。</li>
<li>【目的】用于在特定领域中构建UML模型。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/profile-diagram.png"><br></center>

<blockquote>
<p>图中我们定义了一个简易的<code>EJB</code>的概要图。<code>Bean</code>是从<code>Component</code>扩展来的。<code>Entity Bean</code>和<code>Session Bean</code>继承了<code>Bean</code>。<code>EJB</code>拥有<code>Remote</code>和<code>Home</code>接口，和<code>JAR</code>包。</p>
</blockquote>
<h2 id="什么是用例图？"><a href="#什么是用例图？" class="headerlink" title="什么是用例图？"></a>什么是用例图？</h2><ul>
<li>【概念】用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。</li>
<li>【目的】用来描述整个系统的功能。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/use-case-diagram.png?1"><br></center>

<p>用例图中包含以下三种关系：</p>
<ul>
<li>包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。</li>
<li>扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能</li>
<li>泛化关系，子用例继承父用例所有结构、行为和关系。</li>
</ul>
<h2 id="什么是活动图？"><a href="#什么是活动图？" class="headerlink" title="什么是活动图？"></a>什么是活动图？</h2><ul>
<li>【概念】描述了具体业务用例的实现流程。</li>
<li>【目的】用来表示用例实现的工作流程。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/activity-diagram.png?1"><br></center>

<blockquote>
<p>图中简单描述了，从开始到登录到查看订单列表，或者登录失败直接结束。</p>
</blockquote>
<h2 id="什么是状态机图？"><a href="#什么是状态机图？" class="headerlink" title="什么是状态机图？"></a>什么是状态机图？</h2><ul>
<li>【概念】状态机图对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</li>
<li>【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/state-machine-diagram.png?2"><br></center>

<blockquote>
<p>图中描述了，门在其生命周期内所经历的状态。</p>
</blockquote>
<h2 id="什么是序列图？"><a href="#什么是序列图？" class="headerlink" title="什么是序列图？"></a>什么是序列图？</h2><ul>
<li>【概念】序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。</li>
<li>【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/sequence-diagram.png?2"><br></center>

<blockquote>
<p>图中展示的是支付宝条码支付场景的序列图。其中，<code>loop</code>是循环，<code>alt</code>是选择，序列图的其他关系这里就不介绍了。</p>
</blockquote>
<h2 id="什么是通讯图？"><a href="#什么是通讯图？" class="headerlink" title="什么是通讯图？"></a>什么是通讯图？</h2><ul>
<li>【概念】描述了收发消息的对象的组织关系，强调对象之间的合作关系而不是时间顺序。</li>
<li>【目的】用来显示不同对象的关系。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/communication-diagram.png?2"><br></center>

<blockquote>
<p>图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。</p>
</blockquote>
<h2 id="什么是交互概览图？"><a href="#什么是交互概览图？" class="headerlink" title="什么是交互概览图？"></a>什么是交互概览图？</h2><ul>
<li>【概念】交互概览图与活动图类似，但是它的节点是交互图。</li>
<li>【目的】提供了控制流的概述。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/interaction-overview-diagram.png"><br></center>

<blockquote>
<p>图中表示一个调度系统的交互概览图，跟活动图很像。其中<code>sd</code>的框代表具体的交互流程，<code>ref</code>框代表使用交互。</p>
</blockquote>
<h2 id="什么是时序图？"><a href="#什么是时序图？" class="headerlink" title="什么是时序图？"></a>什么是时序图？</h2><ul>
<li>【概念】时序图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</li>
<li>【目的】用来表示元素状态或者值随时间的变化而变化的视图。</li>
</ul>
<center><br>    <img src="https://img.iisheng.cn/timing-diagram.png"><br></center>

<blockquote>
<p>图中展示了老年痴呆病人随着时间的变化病情的变化。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习UML，我们没必要纠结比如像聚合关系是带箭头还是不带箭头，这样的问题。更重要的是UML图所给我们带来的画图思想，让我们画UML图或者其他图能让其他人更好的理解我们的设计思想。</p>
<p>当然，你要是明确知道带箭头或者不带箭头哪个是错误的，欢迎留言告诉我。</p>
<p><sub>参考文献：</sub><br><br><sub>[1]:《Learning UML 2.0》</sub><br><br><sub>[2]: <a href="https://www.uml-diagrams.org/" target="_blank" rel="noopener">https://www.uml-diagrams.org/</a></sub><br><br><sub>[3]: <a href="https://www.visual-paradigm.com/guide/" target="_blank" rel="noopener">https://www.visual-paradigm.com/guide/</a></sub><br><br><sub>[4]: <a href="https://sparxsystems.com/resources/tutorials/" target="_blank" rel="noopener">https://sparxsystems.com/resources/tutorials/</a></sub><br></p>
]]></content>
      <categories>
        <category>🙄设计思想</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>我的强迫症系列之@Builder和建造者模式</title>
    <url>/2020/04/16/builder-pattern/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>备受争议的Lombok中@Builder是怎么实现的？</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>备受争议的<code>Lombok</code>，有的人喜欢它让代码更整洁，有的人不喜欢它，巴拉巴拉一堆原因。在我看来<code>Lombok</code>唯一的缺点可能就是需要安装插件了，但是对于业务开发的项目来说，它的优点远远超过缺点。</p>
<blockquote>
<p>我们可以看一下，有多少项目使用了Lombok（数量还在疯涨中…）</p>
</blockquote>
<p><img src="https://img.iisheng.cn/lombok-used-by.png" alt></p>
<blockquote>
<p>尽管如此，我们今天也只是单纯的来看一下@Builder()这个东西</p>
</blockquote>
<h2 id="Builder的使用"><a href="#Builder的使用" class="headerlink" title="@Builder的使用"></a>@Builder的使用</h2><h3 id="使用-Builder修饰类"><a href="#使用-Builder修饰类" class="headerlink" title="使用@Builder修饰类"></a>使用@Builder修饰类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用建造者模式创建类"><a href="#使用建造者模式创建类" class="headerlink" title="使用建造者模式创建类"></a>使用建造者模式创建类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserDO userDO = UserDO.builder()</span><br><span class="line">            .id(<span class="number">1L</span>)</span><br><span class="line">            .name(<span class="string">"iisheng"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    System.out.println(userDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译后源码"><a href="#编译后源码" class="headerlink" title="编译后源码"></a>编译后源码</h2><p>执行<code>javac -cp   ~/lombok.jar UserDO.java -verbose</code>将<code>.java</code>编译成<code>.class</code>文件。</p>
<p>通过IDE查看该<code>.class</code>源码</p>
<blockquote>
<p>下面展示的是被我处理后的源码，感兴趣的同学，可以自己执行上面命令，查看完整源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserDO(id="</span> </span><br><span class="line">            + <span class="keyword">this</span>.getId() + <span class="string">", name="</span> + <span class="keyword">this</span>.getName() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserDO(Long var1, String var2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = var1;</span><br><span class="line">        <span class="keyword">this</span>.name = var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDO.<span class="function">UserDOBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDO.UserDOBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserDO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDOBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        UserDOBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserDO.<span class="function">UserDOBuilder <span class="title">id</span><span class="params">(Long var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = var1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserDO.<span class="function">UserDOBuilder <span class="title">name</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var1;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDO <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserDO(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们可以看出来Builder的实现步骤：</p>
<ul>
<li>在<code>UserDO</code>中创建静态<code>UserDOBuilder</code></li>
<li>编写设置属性方法，返回<code>UserDOBuilder</code>对象</li>
<li>编写<code>build()</code>方法，返回<code>UserDO</code>对象</li>
</ul>
<p>是不是很简单？我曾经看过不知道哪个大佬说的一句话，整洁的代码不是说，行数更少，字数更少，而是阅读起来逻辑更清晰。所以，我觉得，哪怕我们不用@Builder，也应该多用这种建造者模式。</p>
<blockquote>
<p>是时候看看什么是建造者模式了！</p>
</blockquote>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><blockquote>
<p>这是大部分书籍网络中的建造者模式类图</p>
</blockquote>
<p><img src="https://img.iisheng.cn/builder-pattern.png" alt></p>
<h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer val;</span><br><span class="line"></span><br><span class="line">    Product(String name, Integer val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product is "</span> + name + <span class="string">" value is "</span> + val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置产品不同部分，以获得不同的产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Integer val)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置名字 公用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建造产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">buildProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 产品类内部的逻辑</span></span><br><span class="line"><span class="comment">         * 实际存储的值是 val + 100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.val = val + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 组建一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这块还可以写特殊的校验逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product(name, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getAProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置不同的零件，产生不同的产品</span></span><br><span class="line">        builder.setName(<span class="string">"ProductA"</span>);</span><br><span class="line">        builder.setVal(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我更喜欢这样的建造者模式类图</p>
</blockquote>
<p><img src="https://img.iisheng.cn/modified-builder.png" alt></p>
<p><code>Product</code>的创建，也依赖于<code>Builder</code>。代码只需要将上面的<code>Product</code>和<code>ConcreteBuilder</code>调整一下即可。</p>
<h3 id="调整后的产品类"><a href="#调整后的产品类" class="headerlink" title="调整后的产品类"></a>调整后的产品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer val;</span><br><span class="line"></span><br><span class="line">    Product(Builder builder) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.val = builder.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product is "</span> + name + <span class="string">" value is "</span> + val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码只是将构造方法改了，使用<code>Builder</code>来创建<code>Product</code>对象。</p>
<h3 id="调整后的具体建造者"><a href="#调整后的具体建造者" class="headerlink" title="调整后的具体建造者"></a>调整后的具体建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVal</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 产品类内部的逻辑</span></span><br><span class="line"><span class="comment">         * 实际存储的值是 val + 100</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.val = val + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 组建一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这块还可以写特殊的校验逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的使用带<code>Builder</code>的<code>Product</code>的构造方法。</p>
<h2 id="JDK中的建造者模式"><a href="#JDK中的建造者模式" class="headerlink" title="JDK中的建造者模式"></a>JDK中的建造者模式</h2><blockquote>
<p>StringBuilder (截取部分源码)</p>
</blockquote>
<h3 id="抽象建造者-1"><a href="#抽象建造者-1" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Documentation in subclasses because of synchro difference</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> String)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.append((String)s);</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AbstractStringBuilder)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.append((AbstractStringBuilder)s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.append(s, <span class="number">0</span>, s.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">        <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">            end = count;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> len = end - start;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(value, start+len, value, start, count-end);</span><br><span class="line">            count -= len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体建造者-1"><a href="#具体建造者-1" class="headerlink" title="具体建造者"></a>具体建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StringBuilder</code>中的建造者模式比较简单，但是我的确没找到<code>StringBuilder</code>非要用建造者模式的原因，或许就是想让我们写下面这样的代码？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">"Love "</span>)</span><br><span class="line">      .append(<span class="string">"iisheng !"</span>)</span><br><span class="line">      .insert(<span class="number">0</span>, <span class="string">"I "</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是我希望你能通过<code>StringBuilder</code>，感受一下建造者模式的气息</p>
</blockquote>
<h2 id="Guava-Cache中的建造者模式"><a href="#Guava-Cache中的建造者模式" class="headerlink" title="Guava Cache中的建造者模式"></a>Guava Cache中的建造者模式</h2><h3 id="如何使用-Guava-Cache？"><a href="#如何使用-Guava-Cache？" class="headerlink" title="如何使用 Guava Cache？"></a>如何使用 Guava Cache？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LoadingCache&lt;String, Integer&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">// 最多存放十个数据</span></span><br><span class="line">            .maximumSize(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">// 缓存10秒</span></span><br><span class="line">            .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;String, Integer&gt;() &#123;</span><br><span class="line">                <span class="comment">// 默认返回-1，也可以是查询操作，如从DB查询</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 只查询缓存，没有命中，即返回 null</span></span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"key1"</span>));</span><br><span class="line">    <span class="comment">// put数据，放在缓存中</span></span><br><span class="line">    cache.put(<span class="string">"key1"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再次查询，已经存在缓存中</span></span><br><span class="line">    System.out.println(cache.getIfPresent(<span class="string">"key1"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询缓存，未命中，调用load方法，返回 -1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(cache.get(<span class="string">"key2"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面是截取建造者模式相关的部分代码</p>
</blockquote>
<h3 id="产品接口"><a href="#产品接口" class="headerlink" title="产品接口"></a>产品接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DoNotMock</span>(<span class="string">"Use CacheBuilder.newBuilder().build()"</span>)</span><br><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">V <span class="title">getIfPresent</span><span class="params">(@CompatibleWith(<span class="string">"K"</span>)</span> Object key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key, Callable&lt;? extends V&gt; loader)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一个产品接口"><a href="#另一个产品接口" class="headerlink" title="另一个产品接口"></a>另一个产品接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Function</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">V <span class="title">getUnchecked</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">(K key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">V <span class="title">apply</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="产品实现类"><a href="#产品实现类" class="headerlink" title="产品实现类"></a>产品实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalManualCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> LocalCache&lt;K, V&gt; localCache;</span><br><span class="line">    </span><br><span class="line">    LocalManualCache(CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder) &#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">new</span> LocalCache&lt;K, V&gt;(builder, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LocalManualCache</span><span class="params">(LocalCache&lt;K, V&gt; localCache)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.localCache = localCache;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cache methods</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">V <span class="title">getIfPresent</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> localCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, <span class="keyword">final</span> Callable&lt;? extends V&gt; valueLoader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">      checkNotNull(valueLoader);</span><br><span class="line">      <span class="keyword">return</span> localCache.get(</span><br><span class="line">          key,</span><br><span class="line">          <span class="keyword">new</span> CacheLoader&lt;Object, V&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> V <span class="title">load</span><span class="params">(Object key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> valueLoader.call();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      localCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> localCache.longSize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> localCache;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      localCache.cleanUp();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Serialization Support</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ManualSerializationProxy&lt;&gt;(localCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一个产品实现类"><a href="#另一个产品实现类" class="headerlink" title="另一个产品实现类"></a>另一个产品实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalLoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LocalManualCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    LocalLoadingCache(</span><br><span class="line">        CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="keyword">new</span> LocalCache&lt;K, V&gt;(builder, checkNotNull(loader)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LoadingCache methods</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> localCache.getOrLoad(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getUnchecked</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(key);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(e.getCause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      localCache.refresh(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">apply</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getUnchecked(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Serialization Support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadingSerializationProxy&lt;&gt;(localCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实际产品实现类LocalCache"><a href="#实际产品实现类LocalCache" class="headerlink" title="实际产品实现类LocalCache"></a>实际产品实现类LocalCache</h3><p>上面两个产品类实际上，内部使用的是<code>LocalCache</code>来存储数据。我们再看下<code>LocalCache</code>的实现。</p>
<p><code>LocalCache</code>继承<code>AbstractCache</code>，我们先看<code>AbstractCache</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Constructor for use by subclasses. */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">AbstractCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, Callable&lt;? extends V&gt; valueLoader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConcurrentMap&lt;K, V&gt; <span class="title">asMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看，<code>LocalCache</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** How long after the last write to an entry the map will retain that entry. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> expireAfterWriteNanos;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** The default cache loader to use on loading operations. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; defaultLoader;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  LocalCache(</span><br><span class="line">      CacheBuilder&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; builder, <span class="meta">@Nullable</span> CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</span><br><span class="line">    concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);</span><br><span class="line"></span><br><span class="line">    maxWeight = builder.getMaximumWeight();</span><br><span class="line">    weigher = builder.getWeigher();</span><br><span class="line">    expireAfterAccessNanos = builder.getExpireAfterAccessNanos();</span><br><span class="line">    expireAfterWriteNanos = builder.getExpireAfterWriteNanos();</span><br><span class="line">    refreshNanos = builder.getRefreshNanos();</span><br><span class="line"></span><br><span class="line">    defaultLoader = loader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY);</span><br><span class="line">    <span class="keyword">if</span> (evictsBySize() &amp;&amp; !customWeigher()) &#123;</span><br><span class="line">      initialCapacity = (<span class="keyword">int</span>) Math.min(initialCapacity, maxWeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find the lowest power-of-two segmentCount that exceeds concurrencyLevel, unless</span></span><br><span class="line">    <span class="comment">// maximumSize/Weight is specified in which case ensure that each segment gets at least 10</span></span><br><span class="line">    <span class="comment">// entries. The special casing for size-based eviction is only necessary because that eviction</span></span><br><span class="line">    <span class="comment">// happens per segment instead of globally, so too many segments compared to the maximum size</span></span><br><span class="line">    <span class="comment">// will result in random eviction behavior.</span></span><br><span class="line">    <span class="keyword">int</span> segmentShift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> segmentCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * <span class="number">20</span> &lt;= maxWeight)) &#123;</span><br><span class="line">      ++segmentShift;</span><br><span class="line">      segmentCount &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - segmentShift;</span><br><span class="line">    segmentMask = segmentCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.segments = newSegmentArray(segmentCount);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBuilder</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> maximumSize = UNSET_INT;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">long</span> expireAfterWriteNanos = UNSET_INT;</span><br><span class="line">  </span><br><span class="line">  Supplier&lt;? extends StatsCounter&gt; statsCounterSupplier = NULL_STATS_COUNTER;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder&lt;K, V&gt; <span class="title">maximumSize</span><span class="params">(<span class="keyword">long</span> maximumSize)</span> </span>&#123;</span><br><span class="line">    checkState(</span><br><span class="line">        <span class="keyword">this</span>.maximumSize == UNSET_INT, <span class="string">"maximum size was already set to %s"</span>, <span class="keyword">this</span>.maximumSize);</span><br><span class="line">    checkState(</span><br><span class="line">        <span class="keyword">this</span>.maximumWeight == UNSET_INT,</span><br><span class="line">        <span class="string">"maximum weight was already set to %s"</span>,</span><br><span class="line">        <span class="keyword">this</span>.maximumWeight);</span><br><span class="line">    checkState(<span class="keyword">this</span>.weigher == <span class="keyword">null</span>, <span class="string">"maximum size can not be combined with weigher"</span>);</span><br><span class="line">    checkArgument(maximumSize &gt;= <span class="number">0</span>, <span class="string">"maximum size must not be negative"</span>);</span><br><span class="line">    <span class="keyword">this</span>.maximumSize = maximumSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder&lt;K, V&gt; <span class="title">expireAfterWrite</span><span class="params">(<span class="keyword">long</span> duration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    checkState(</span><br><span class="line">        expireAfterWriteNanos == UNSET_INT,</span><br><span class="line">        <span class="string">"expireAfterWrite was already set to %s ns"</span>,</span><br><span class="line">        expireAfterWriteNanos);</span><br><span class="line">    checkArgument(duration &gt;= <span class="number">0</span>, <span class="string">"duration cannot be negative: %s %s"</span>, duration, unit);</span><br><span class="line">    <span class="keyword">this</span>.expireAfterWriteNanos = unit.toNanos(duration);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheBuilder&lt;K, V&gt; <span class="title">recordStats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    statsCounterSupplier = CACHE_STATS_COUNTER;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> &lt;K1 extends K, V1 extends V&gt; <span class="function">Cache&lt;K1, V1&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkWeightWithWeigher();</span><br><span class="line">    checkNonLoadingCache();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalCache.LocalManualCache&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> &lt;K1 extends K, V1 extends V&gt; <span class="function">LoadingCache&lt;K1, V1&gt; <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      CacheLoader&lt;? <span class="keyword">super</span> K1, V1&gt; loader)</span> </span>&#123;</span><br><span class="line">    checkWeightWithWeigher();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalCache.LocalLoadingCache&lt;&gt;(<span class="keyword">this</span>, loader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Guava Cache的代码还是蛮复杂的，来一张UML图，便于理解</p>
</blockquote>
<p><img src="https://img.iisheng.cn/guava-cache.png" alt></p>
<ul>
<li><code>LoadingCache</code>接口继承了<code>Cache</code>接口，两个接口都定义了缓存的基本方法</li>
<li><code>CacheLoader</code>是<code>LocalCache</code>的成员变量</li>
<li><code>LocalCache</code>继承<code>AbstractMap</code>，是真正意义上的产品类</li>
<li><code>LocalManualCache</code>是<code>CacheBuilder</code>的<code>build()</code>方法产生的对象的类，<code>LocalManualCache</code>因为有<code>LocalCache</code>作为成员变量，使得它成为了产品类，<code>LocalManualCache</code>实现了<code>Cache</code>接口</li>
<li><code>LocalLoadingCache</code>继承了<code>LocalManualCache</code>，是<code>CacheBuilder</code>的<code>build(CacheLoader&lt;? super K1, V1&gt; loader)</code>方法产生的对象的类，<code>LocalLoadingCache</code>实现了<code>LoadingCache</code>接口</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="什么时候适合使用建造者模式？"><a href="#什么时候适合使用建造者模式？" class="headerlink" title="什么时候适合使用建造者模式？"></a>什么时候适合使用建造者模式？</h3><blockquote>
<p>创建对象参数过多的时候</p>
</blockquote>
<p>创建一个有很多属性的对象，如果参数在构造方法中写，看起来很乱，一长串不说，还很容易写错。</p>
<blockquote>
<p>对象的部分属性是可选择的时候</p>
</blockquote>
<p>创建的对象有很多属性是可选择的那种，常见的比如配置类等，不同使用者有不同的配置。</p>
<blockquote>
<p>对象创建完成后，就不能修改内部属性的时候</p>
</blockquote>
<p>不提供set()方法，使用建造者模式一次性把对象创建完成。</p>
<h3 id="建造者模式和工厂模式的区别是什么？"><a href="#建造者模式和工厂模式的区别是什么？" class="headerlink" title="建造者模式和工厂模式的区别是什么？"></a>建造者模式和工厂模式的区别是什么？</h3><ul>
<li>建造者模式，通过设置不同的可选参数，“定制化”的创建不同的对象</li>
<li>工厂模式，是直接创建不同但是相关类型的对象（继承同一父类或者接口的一组子类）</li>
</ul>
<h2 id="最后想说的"><a href="#最后想说的" class="headerlink" title="最后想说的"></a>最后想说的</h2><p>由<code>@Builder</code>想到的建造者模式，然后看了<code>StringBuilder</code>以及<code>Guava Cache</code>的源码，其中还是有很多值得我们学习的地方。</p>
<p>建造者模式，可能不同的人有不同的理解，不同的实现有不同的方法，但是我们只有深刻的理解了其中的设计思想，才不至于在项目中生搬硬套，才能灵活运用。</p>
<p><sub>参考文献：</sub><br><br><sub>[1]:《设计模式之禅》</sub><br><br><sub>[2]:《Effective Java中文版》</sub><br><br><sub>[3]:《设计模式之美 建造者模式》</sub><br></p>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>航班预订统计，听说这题有的人看了题解还没懂？</title>
    <url>/2020/04/09/corporate-flight-bookings/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>以清晰，易于理解的思维，讲解<a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">航班预订统计</a>和<a href="https://leetcode-cn.com/problems/car-pooling/" target="_blank" rel="noopener">拼车</a>，这两道题。欢迎大家一起来刷题。</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天，有一哥们发我一个LeetCode题目链接，紧跟着附上了自己的提交记录，一个<code>2ms</code>，另一个<code>1451ms</code>…</p>
<p><img src="https://img.iisheng.cn/wechat-screenshot.png" alt></p>
<p>我一看，这题有点意思啊，不同的思路竟然时间差这么多。搞它。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>这里有<code>n</code>个航班，它们分别从<code>1</code>到<code>n</code>进行编号。</p>
<p>我们这儿有一份航班预订表，表中第<code>i</code>条预订记录<code>bookings[i] = [i, j, k]</code>意味着我们在从<code>i</code>到<code>j</code>的每个航班上预订了<code>k</code>个座位。</p>
<p>请你返回一个长度为<code>n</code>的数组<code>answer</code>，按航班编号顺序返回每个航班上预订的座位数。</p>
<p>示例：</p>
<blockquote>
<p>输入：bookings = [ [1,2,10], [2,3,20], [2,5,25] ], n = 5</p>
<p>输出：[10,55,45,25,25]</p>
</blockquote>
<h2 id="O-m-n-解法"><a href="#O-m-n-解法" class="headerlink" title="O(m*n)解法"></a>O(m*n)解法</h2><p>根据题意初始化长度为<code>n</code>的<code>answer</code>数组，代表<code>1</code>到<code>n</code>号航班预订的座位数量，外层遍历 <code>bookings</code>，内层遍历<code>bookings[i] = [i, j, k]</code>，计算航班号<code>i</code>到<code>j</code>的座位数量，即当前座位数量加<code>k</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(</span><br><span class="line">        <span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个bookings数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] b : bookings) &#123;</span><br><span class="line">        <span class="comment">// 内层循环把每个航班预订数加上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">             i &lt;= b[<span class="number">1</span>] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            answer[i] += b[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="O-n-解法"><a href="#O-n-解法" class="headerlink" title="O(n)解法"></a>O(n)解法</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>O(m*n)</code>解法中关键一点，内层循环我们一直重复的在<code>[i, j]</code>之间加上<code>k</code>，怎么将这循环变成<code>O(1)</code>，成为问题的关键！</p>
<p><code>[i, j]</code>之间加上<code>k</code>，这让我想到了等差数列，这不就是公差为<code>k</code>的等差数列吗？然后呢？</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>设<code>answer[i]</code>表示第<code>i</code>个航班预订的座位数。定义一个差分数组<code>d[]</code>，<code>d[i]</code>表示第<code>i</code>个航班与第<code>i-1</code>个航班预订座位的差值，即<code>d[i] = answer[i] - answer[i - 1]</code>。</p>
<p>这样，我们每次遍历到<code>bookings[i] = [i, j, k]</code>，就只需要将<code>d[i]</code>增加<code>k</code>，<code>d[j + 1]</code>减少<code>k</code>即可，因为<code>i</code>到<code>j</code>之间，航班预订数量是没有变化的。</p>
<p>最后，计算<code>answer[i] = answer[i - 1] + d[i]</code>，返回<code>answer</code>即可。</p>
<h3 id="推演"><a href="#推演" class="headerlink" title="推演"></a>推演</h3><p>好吧，这样说可能有人没懂，我们按照题目的例子推演一次：</p>
<ul>
<li>初始航班预订数量数组 <code>answer = [0,0,0,0,0]</code>，差分数组<code>d = [0,0,0,0,0]</code></li>
<li>当遍历到<code>bookings[0] = [1,2,10]</code>的时候，差分数组第1位加10，第3位减10，变成<code>d = [10,0,-10,0,0]</code></li>
<li>同理，当遍历到<code>bookings[1] = [2,3,20]</code>的时候，差分数组变成<code>d = [10,20,-10,-20,0]</code></li>
<li>当遍历到<code>bookings[2] = [2,5,25]</code>的时候，差分数组变成<code>d = [10,45,-10,-20,0]</code>，第6位要减25，我们也不需要了</li>
<li>最后计算<code>answer</code>数组的值，<code>answer[0] = d[0] = 10</code>，<code>answer[1] = d[1] + answer[0] = 45 + 10 = 55</code>，<code>answer[2] = d[2] + answer[1] = -10 + 55 = 45</code>…</li>
<li>最最后发现，只申请一个数组表示<code>d[]</code>和<code>answer[]</code>就可以了，over！</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] corpFlightBookings(</span><br><span class="line">        <span class="keyword">int</span>[][] bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bookings 计算航班i+1 对航班i 变化的预订数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] b : bookings) &#123;</span><br><span class="line">        <span class="comment">// 增加的预订数</span></span><br><span class="line">        answer[b[<span class="number">0</span>] - <span class="number">1</span>] += b[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 减少的预订数量</span></span><br><span class="line">            answer[b[<span class="number">1</span>]] -= b[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 航班i的预订数等于,i-1的预订数，加i时刻变化的预定数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        answer[i] += answer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h2><blockquote>
<p>你以为这就完了吗？不要太天真。再来看一下这个题，或许会给你带来新思路。</p>
</blockquote>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你是一位顺风车司机，车上最初有 <code>capacity</code> 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。</p>
<p>这儿有一份行程计划表 <code>trips[][]</code>，其中 <code>trips[i] = [num_passengers, start_location, end_location]</code> 包含了你的第 <code>i</code> 次行程信息：</p>
<p>必须接送的乘客数量；<br>乘客的上车地点；<br>以及乘客的下车地点。<br>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p>
<p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所用乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 <code>true</code>，否则请返回 <code>false</code>）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：trips = [[2,1,5],[3,3,7]], capacity = 4</p>
<p>输出：false</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：trips = [[2,1,5],[3,3,7]], capacity = 5</p>
<p>输出：true</p>
</blockquote>
<p>提示：</p>
<ul>
<li>你可以假设乘客会自觉遵守 “先下后上” 的良好素质</li>
<li><code>trips.length &lt;= 1000</code></li>
<li><code>1 &lt;= trips[i][0] &lt;= 100</code></li>
</ul>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>这道题实际上就是问，车的座位数量是否能满足每个行程<code>i</code>的乘客，即每个乘客都坐上座位，能则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>如果我们能计算出，行程<code>i</code>，要乘车的乘客的数量，然后跟<code>capacity</code>对比一下，就能得到答案了。</p>
<p>很显然，<strong>要乘车的乘客的数量 = 车上原来乘客的数量 - 下车乘客数量 + 上车乘客数量</strong>。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以用数组或者Map记录，行程<code>i</code>，下车乘客的数量和上车乘客的数量，然后行程开始到结束，计算要乘车的乘客数量，并与<code>capacity</code>比较。</p>
<h3 id="代码实现Map版"><a href="#代码实现Map版" class="headerlink" title="代码实现Map版"></a>代码实现Map版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用TreeMap 是为了让元素根据key排序</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map =</span><br><span class="line">            <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : trips) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = map.getOrDefault(t[<span class="number">1</span>], <span class="number">0</span>) + t[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 上车乘客数量</span></span><br><span class="line">        map.put(t[<span class="number">1</span>], v);</span><br><span class="line">        v = map.getOrDefault(t[<span class="number">2</span>], <span class="number">0</span>) - t[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 下车乘客数量</span></span><br><span class="line">        map.put(t[<span class="number">2</span>], v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry</span><br><span class="line">            : map.entrySet()) &#123;</span><br><span class="line">        Integer value = entry.getValue();</span><br><span class="line">        <span class="comment">// 当前数量=之前数量+变化的数量</span></span><br><span class="line">        cur += value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现数组版"><a href="#代码实现数组版" class="headerlink" title="代码实现数组版"></a>代码实现数组版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">carPooling</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最远行程 数组长度</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : trips) &#123;</span><br><span class="line">        max = Math.max(max, t[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有要乘车的乘客数量</span></span><br><span class="line">    <span class="keyword">int</span>[] passengers = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : trips) &#123;</span><br><span class="line">        passengers[t[<span class="number">1</span>]] += t[<span class="number">0</span>];</span><br><span class="line">        passengers[t[<span class="number">2</span>]] -= t[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> passenger : passengers) &#123;</span><br><span class="line">        <span class="comment">// 当前数量 = 之前数量 + 变化的数量</span></span><br><span class="line">        cur += passenger;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回头"><a href="#回头" class="headerlink" title="回头"></a>回头</h3><p><strong>拼车</strong>的代码与场景感觉好理解一些，因为生活中我们就是这样，先下后上，能不能坐上座，就看车上原来有多少人，还有下车多少人。</p>
<p>我们再回来来看<strong>航班预订统计</strong>这题，实际上跟<strong>拼车</strong>是完全一样的题目。</p>
<p>我看到有人问，计算<code>bookings[i] = [i, j, k]</code>预订变化数量的时候，为啥是第<code>j + 1</code>的位置要减<code>k</code>，而不是<code>j</code>的位置呢？因为，<code>j - 1</code>的位置，航班预订座位数量应该加<code>k</code>，而<code>j</code>的位置，航班预订座位数量也加<code>k</code>，所以<code>j</code>和<code>j - 1</code>之间数量是没有变化的。但是，<code>j + 1</code>的位置航班数量不再加<code>k</code>了，所以<code>j + 1</code>相对于<code>j</code>位置航班预订数量是减少<code>k</code>的。</p>
<p>而<strong>拼车</strong>这道题，<code>trips[i][j]</code>，在<code>j</code>位置，车到站了，乘客就下车了，再坐一站就过站了…</p>
<p>总之，两道题本质是完全一样的，只不过略微有些细节不同。</p>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码解析，老哥，来一起复习一哈？</title>
    <url>/2020/04/03/arraylist/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>带着问题，来阅读源码，结合使用案例，相信你，看完可以对ArrayList记忆深刻了。</strong></p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDK源码解析系列文章，都是基于JDK8分析的，虽然JDK14已经出来，但是JDK8我还不会，我…</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img.iisheng.cn/array-list-diagram.png" alt></p>
<ul>
<li>实现了<code>RandomAccess</code>接口，可以随机访问</li>
<li>实现了<code>Cloneable</code>接口，可以克隆</li>
<li>实现了<code>Serializable</code>接口，可以序列化、反序列化</li>
<li>实现了<code>List</code>接口，是<code>List</code>的实现类之一</li>
<li>实现了<code>Collection</code>接口，是<code>Java Collections Framework</code>成员之一</li>
<li>实现了<code>Iterable</code>接口，可以使用<code>for-each</code>迭代</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化版本UID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span></span><br><span class="line">        serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span></span><br><span class="line">        DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> * new ArrayList(0);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]</span><br><span class="line">        EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于提供默认大小的实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> * new ArrayList();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]</span><br><span class="line">        DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList元素的数组缓冲区</span></span><br><span class="line"><span class="comment"> * ArrayList的容量，是数组的长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * non-private to simplify nested class access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList中元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小朋友，你四否有很多问号？</p>
</blockquote>
<ol>
<li>为什么空实例默认数组有的时候是<code>EMPTY_ELEMENTDATA</code>，而又有的时候是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></li>
<li>为什么<code>elementData</code>要被<code>transient</code>修饰</li>
<li>为什么<code>elementData</code>没有被<code>private</code>修饰？难道正如注释所写的<strong>non-private to simplify nested class access</strong></li>
</ol>
<blockquote>
<p>带着问题，我们继续往下看。</p>
</blockquote>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="带初始容量的构造方法"><a href="#带初始容量的构造方法" class="headerlink" title="带初始容量的构造方法"></a>带初始容量的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带一个初始容量参数的构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  如果初始容量非法就抛出</span></span><br><span class="line"><span class="comment"> *          IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData =</span><br><span class="line">                <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>initialCapacity &gt; 0</code>，就创建一个新的长度是<code>initialCapacity</code>的数组</li>
<li>如果<code>initialCapacity == 0</code>，就使用EMPTY_ELEMENTDATA</li>
<li>其他情况，<code>initialCapacity</code>不合法，抛出异常</li>
</ul>
<h3 id="无参构造方法"><a href="#无参构造方法" class="headerlink" title="无参构造方法"></a>无参构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造方法 将elementData 赋值为</span></span><br><span class="line"><span class="comment"> *   DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData =</span><br><span class="line">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带一个集合参数的构造方法"><a href="#带一个集合参数的构造方法" class="headerlink" title="带一个集合参数的构造方法"></a>带一个集合参数的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带一个集合参数的构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合，代表集合中的元素会被放到list中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果集合为空，抛出NullPointerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 如果 size != 0</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray 可能不正确的，不返回 Object[]</span></span><br><span class="line">        <span class="comment">// https://bugs.openjdk.java.net/browse/JDK-6260652</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(</span><br><span class="line">                    elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// size == 0</span></span><br><span class="line">        <span class="comment">// 将EMPTY_ELEMENTDATA 赋值给 elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用将集合转换为数组的方法</li>
<li>为了防止<code>c.toArray()</code>方法不正确的执行，导致没有返回<code>Object[]</code>，特殊做了处理</li>
<li>如果数组大小等于<code>0</code>，则使用 <code>EMPTY_ELEMENTDATA</code></li>
</ul>
<blockquote>
<p>那么问题来了，什么情况下<code>c.toArray()</code>会不返回<code>Object[]</code>呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"list"</span>));</span><br><span class="line">    <span class="comment">// class java.util.ArrayList</span></span><br><span class="line">    System.out.println(list.getClass());</span><br><span class="line"></span><br><span class="line">    Object[] listArray = list.toArray();</span><br><span class="line">    <span class="comment">// class [Ljava.lang.Object;</span></span><br><span class="line">    System.out.println(listArray.getClass());</span><br><span class="line">    listArray[<span class="number">0</span>] = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; asList = Arrays.asList(<span class="string">"asList"</span>);</span><br><span class="line">    <span class="comment">// class java.util.Arrays$ArrayList</span></span><br><span class="line">    System.out.println(asList.getClass());</span><br><span class="line"></span><br><span class="line">    Object[] asListArray = asList.toArray();</span><br><span class="line">    <span class="comment">// class [Ljava.lang.String;</span></span><br><span class="line">    System.out.println(asListArray.getClass());</span><br><span class="line">    <span class="comment">// java.lang.ArrayStoreException</span></span><br><span class="line">    asListArray[<span class="number">0</span>] = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过这个例子可以看出来，<code>java.util.ArrayList.toArray()</code>方法会返回<code>Object[]</code>没有问题。而<code>java.util.Arrays</code>的私有内部类ArrayList的<code>toArray()</code>方法可能不返回<code>Object[]</code>。</p>
<blockquote>
<p>为什么会这样？</p>
</blockquote>
<p>我们看ArrayList的<code>toArray()</code>方法源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// ArrayLisy中 elementData是这样定义的</span></span><br><span class="line">    <span class="comment">// transient Object[] elementData;</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用了<code>Arrays.copyOf()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="comment">// original.getClass() 是 class [Ljava.lang.Object</span></span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copyOf()</code>的具体实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, </span><br><span class="line">          <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果newType是Object[] copy 数组 类型就是 Object </span></span><br><span class="line"><span class="comment">     * 否则就是 newType 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道ArrayList中<code>elementData</code>就是<code>Object[]</code>类型，所以ArrayList的<code>toArray()</code>方法必然会返回<code>Object[]</code>。</p>
<p>我们再看一下<code>java.util.Arrays</code>的内部ArrayList源码（截取的部分源码）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        <span class="comment">// 直接把接收的数组 赋值 给 a</span></span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * obj 为空抛出异常</span></span><br><span class="line"><span class="comment">     * 不为空 返回 obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="comment">// 返回 a 的克隆对象</span></span><br><span class="line">        <span class="keyword">return</span> a.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是<code>Arrays.asList()</code>方法源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不难看出来<code>java.util.Arrays</code>的内部ArrayList的<code>toArray()</code>方法，是构造方法接收什么类型的数组，就返回什么类型的数组。</p>
<p>所以，在我们上面的例子中，实际上返回的是String类型的数组，再将其中的元素赋值成<code>Object</code>类型的，自然报错。</p>
<p>我们还是继续看ArrayList吧…</p>
<h2 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h2><h3 id="在列表最后添加指定元素"><a href="#在列表最后添加指定元素" class="headerlink" title="在列表最后添加指定元素"></a>在列表最后添加指定元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在列表最后添加指定元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加 modCount ！！</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在父类<code>AbstractList</code>上，定义了<code>modCount</code> 属性，用于记录数组修改的次数。</li>
</ul>
<h3 id="在指定位置添加指定元素"><a href="#在指定位置添加指定元素" class="headerlink" title="在指定位置添加指定元素"></a>在指定位置添加指定元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加指定元素</span></span><br><span class="line"><span class="comment"> * 如果指定位置已经有元素，就将该元素和随后的元素移动到右面一位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 待插入元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 待插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 可能抛出 IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 modCount ！！</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入方法调用的其他私有方法"><a href="#插入方法调用的其他私有方法" class="headerlink" title="插入方法调用的其他私有方法"></a>插入方法调用的其他私有方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elementData ==</span><br><span class="line">            DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(</span><br><span class="line">            calculateCapacity(elementData, minCapacity)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组可以分配的最大size</span></span><br><span class="line"><span class="comment"> * 一些虚拟机在数组中预留一些header words</span></span><br><span class="line"><span class="comment"> * 如果尝试分配更大的size，可能导致OutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量，至少保证比minCapacity大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 期望的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有可能溢出的代码</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量返回 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通常情况新容量是原来容量的1.5倍</li>
<li>如果原容量的1.5倍比<code>minCapacity</code>小，那么就扩容到<code>minCapacity</code></li>
<li>特殊情况扩容到<code>Integer.MAX_VALUE</code></li>
</ul>
<blockquote>
<p>看完构造方法、添加方法、扩容方法之后，上文第1个问题终于有了答案。原来，<code>new ArrayList()</code>会将<code>elementData</code> 赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，<code>new ArrayList(0)</code>会将<code>elementData</code> 赋值为 EMPTY_ELEMENTDATA，EMPTY_ELEMENTDATA添加元素会扩容到容量为<code>1</code>，而DEFAULTCAPACITY_EMPTY_ELEMENTDATA扩容之后容量为<code>10</code>。</p>
</blockquote>
<p>通过反射我们可以验证这一想法。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printDefaultCapacityList();</span><br><span class="line">    printEmptyCapacityList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDefaultCapacityList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList defaultCapacity = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    System.out.println(</span><br><span class="line">            <span class="string">"default 初始化长度："</span> + getCapacity(defaultCapacity));</span><br><span class="line"></span><br><span class="line">    defaultCapacity.add(<span class="number">1</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">            <span class="string">"default add 之后 长度："</span> + getCapacity(defaultCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEmptyCapacityList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList emptyCapacity = <span class="keyword">new</span> ArrayList(<span class="number">0</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">            <span class="string">"empty 初始化长度："</span> + getCapacity(emptyCapacity));</span><br><span class="line"></span><br><span class="line">    emptyCapacity.add(<span class="number">1</span>);</span><br><span class="line">    System.out.println(</span><br><span class="line">            <span class="string">"empty add 之后 长度："</span> + getCapacity(emptyCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">(ArrayList&lt;?&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 elementData 字段</span></span><br><span class="line">        Field field = arrayListClass.getDeclaredField(<span class="string">"elementData"</span>);</span><br><span class="line">        <span class="comment">// 开启访问权限</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 把示例传入get，获取实例字段elementData的值</span></span><br><span class="line">        Object[] objects = (Object[]) field.get(arrayList);</span><br><span class="line">        <span class="comment">//返回当前ArrayList实例的容量值</span></span><br><span class="line">        <span class="keyword">return</span> objects.length;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><h3 id="移除指定下标元素方法"><a href="#移除指定下标元素方法" class="headerlink" title="移除指定下标元素方法"></a>移除指定下标元素方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除列表中指定下标位置的元素</span></span><br><span class="line"><span class="comment"> * 将所有的后续元素，向左移动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 要移除的指定下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回被移除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 下标越界会抛出IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, </span><br><span class="line">                    index+<span class="number">1</span>, elementData, index,  numMoved);</span><br><span class="line">    <span class="comment">// 将引用置空，让GC回收</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除指定元素方法"><a href="#移除指定元素方法" class="headerlink" title="移除指定元素方法"></a>移除指定元素方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除第一个在列表中出现的指定元素</span></span><br><span class="line"><span class="comment"> * 如果存在，移除返回true</span></span><br><span class="line"><span class="comment"> * 否则，返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>移除方法名字、参数的个数都一样，使用的时候要注意。</p>
</blockquote>
<h3 id="私有移除方法"><a href="#私有移除方法" class="headerlink" title="私有移除方法"></a>私有移除方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 私有的 移除 方法 跳过边界检查且不返回移除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将引用置空，让GC回收</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><h3 id="查找指定元素的所在位置"><a href="#查找指定元素的所在位置" class="headerlink" title="查找指定元素的所在位置"></a>查找指定元素的所在位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素第一次出现的下标</span></span><br><span class="line"><span class="comment"> * 如果不存在该元素，返回 -1</span></span><br><span class="line"><span class="comment"> * 如果 o ==null 会特殊处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找指定位置的元素"><a href="#查找指定位置的元素" class="headerlink" title="查找指定位置的元素"></a>查找指定位置的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定位置的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 指定元素的位置 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> index越界会抛出IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法直接返回<code>elementData</code>数组指定下标的元素，效率还是很高的。所以ArrayList，<code>for</code>循环遍历效率也是很高的。</p>
</blockquote>
<h2 id="序列化方法"><a href="#序列化方法" class="headerlink" title="序列化方法"></a>序列化方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将ArrayLisy实例的状态保存到一个流里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照顺序写入所有的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反序列化方法"><a href="#反序列化方法" class="headerlink" title="反序列化方法"></a>反序列化方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据一个流(参数)重新生成一个ArrayList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看完序列化，反序列化方法，我们终于又能回答开篇的第二个问题了。<code>elementData</code>之所以用<code>transient</code>修饰，是因为JDK不想将整个<code>elementData</code>都序列化或者反序列化，而只是将<code>size</code>和实际存储的元素序列化或反序列化，从而节省空间和时间。</p>
</blockquote>
<h2 id="创建子数组"><a href="#创建子数组" class="headerlink" title="创建子数组"></a>创建子数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下简短版的<code>SubList</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>SubList的set()方法，<strong>是直接修改ArrayList</strong>中<code>elementData</code>数组的，使用中应该注意</li>
<li>SubList是没有实现<code>Serializable</code>接口的，<strong>是不能序列化的</strong></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="创建迭代器方法"><a href="#创建迭代器方法" class="headerlink" title="创建迭代器方法"></a>创建迭代器方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Itr属性"><a href="#Itr属性" class="headerlink" title="Itr属性"></a>Itr属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下一个要返回的元素的下标</span></span><br><span class="line"><span class="keyword">int</span> cursor;</span><br><span class="line"><span class="comment">// 最后一个要返回元素的下标 没有元素返回 -1</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 期望的 modCount</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>
<h3 id="Itr的hasNext-方法"><a href="#Itr的hasNext-方法" class="headerlink" title="Itr的hasNext() 方法"></a>Itr的hasNext() 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Itr的next-方法"><a href="#Itr的next-方法" class="headerlink" title="Itr的next()方法"></a>Itr的next()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在迭代的时候，会校验<code>modCount</code>是否等于<code>expectedModCount</code>，不等于就会抛出著名的<code>ConcurrentModificationException</code>异常。什么时候会抛出<code>ConcurrentModificationException</code>？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        arrayList.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    remove(arrayList);</span><br><span class="line">    System.out.println(arrayList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Integer number = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 抛出ConcurrentModificationException异常</span></span><br><span class="line">            list.remove(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那怎么写才能不抛出<code>ConcurrentModificationException</code>？很简单，将<code>list.remove(number);</code>换成<code>iterator.remove();</code>即可。why？请看Itr的<code>remove()</code>源码…</p>
</blockquote>
<h3 id="Itr的remove-方法"><a href="#Itr的remove-方法" class="headerlink" title="Itr的remove()方法"></a>Itr的remove()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 移除之后将modCount 重新赋值给 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因就是因为Itr的<code>remove()</code>方法，移除之后将<code>modCount</code>重新赋值给 <code>expectedModCount</code>。这就是源码，不管单线程还是多线程，只要违反了规则，就会抛异常。</p>
<blockquote>
<p>源码看的差不多了，开篇的问题却还剩一个！到底为什么<code>elementData</code>没有用<code>private</code>修饰呢？</p>
</blockquote>
<p>我们知道的，<code>private</code>修饰的变量，内部类也是可以访问到的。难道注释中<code>non-private to simplify nested class access</code>的这句话有毛病？</p>
<p>当我们看表面看不到什么东西的时候，不妨看一下底层。</p>
<p>测试类代码：<br><img src="https://img.iisheng.cn/origin-code.png" alt></p>
<p>一顿<code>javac</code>、<code>javap</code>之后（使用JDK8）：<br><img src="https://img.iisheng.cn/javap-class.png" alt></p>
<p>再一顿<code>javac</code>、<code>javap</code>之后（使用JDK11）：<br><img src="https://img.iisheng.cn/javap-jdk11-class.png" alt></p>
<p>虽然字节码指令我还看不太懂，但是我能品出来，注释是没毛病的，<code>private</code>修饰的确会影响内部类的访问。</p>
<h2 id="ArrayList类注释翻译"><a href="#ArrayList类注释翻译" class="headerlink" title="ArrayList类注释翻译"></a>ArrayList类注释翻译</h2><p>类注释还是要看的，能给我们一个整体的了解这个类。我将ArrayList的类注释大概翻译整理了一下：</p>
<ul>
<li>ArrayList是实现<code>List</code>接口的可自动扩容的数组。实现了所有的<code>List</code>操作，允许所有的元素，包括<code>null</code>值。</li>
<li>ArrayList大致和Vector相同，除了ArrayList是非同步的。</li>
<li><code>size</code> <code>isEmpty</code> <code>get</code> <code>set</code> <code>iterator</code> 和 <code>listIterator</code> 方法时间复杂度是<code>O(1)</code>，常量时间。其他方法是<code>O(n)</code>，线性时间。</li>
<li>每一个ArrayList实例都有一个<code>capacity</code>（容量）。<code>capacity</code>是用于存储列表中元素的数组的大小。<code>capacity</code>至少和列表的大小一样大。</li>
<li>如果多个线程同时访问ArrayList的实例，并且至少一个线程会修改，必须在外部保证ArrayList的同步。修改包括添加删除扩容等操作，仅仅设置值不包括。这种场景可以用其他的一些封装好的同步的<code>list</code>。如果不存在这样的<code>Object</code>，ArrayList应该用<code>Collections.synchronizedList</code>包装起来最好在创建的时候就包装起来，来保证同步访问。</li>
<li><code>iterator()</code>和<code>listIterator(int)</code>方法是<code>fail-fast</code>的，如果在迭代器创建之后，列表进行结构化修改，迭代器会抛出<code>ConcurrentModificationException</code>。</li>
<li>面对并发修改，迭代器快速失败、清理，而不是在未知的时间不确定的情况下冒险。请注意，快速失败行为不能被保证。通常来讲，不能同步进行的并发修改几乎不可能做任何保证。因此，写依赖这个异常的程序的代码是错误的，快速失败行为应该仅仅用于防止<code>bug</code>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ArrayList底层的数据结构是数组</li>
<li>ArrayList可以自动扩容，不传初始容量或者初始容量是<code>0</code>，都会初始化一个空数组，但是如果添加元素，会自动进行扩容，所以，创建ArrayList的时候，给初始容量是必要的</li>
<li><code>Arrays.asList()</code>方法返回的是的<code>Arrays</code>内部的ArrayList，用的时候需要注意</li>
<li><code>subList()</code>返回内部类，不能序列化，和ArrayList共用同一个数组</li>
<li>迭代删除要用，迭代器的<code>remove</code>方法，或者可以用倒序的<code>for</code>循环</li>
<li>ArrayList重写了序列化、反序列化方法，避免序列化、反序列化全部数组，浪费时间和空间</li>
<li><code>elementData</code>不使用<code>private</code>修饰，可以简化内部类的访问</li>
</ul>
<p>源码系列第一篇，一不小心就写的有点长。但是懵懂到深刻的过程还是挺耐人寻味的。文章中没有展开的点，或者你有什么其他好奇的地方，欢迎留言讨论。我们下篇文章再见…</p>
]]></content>
      <categories>
        <category>😤源码</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章掌握Git</title>
    <url>/2020/02/28/git/</url>
    <content><![CDATA[<h3 id="Git简单介绍"><a href="#Git简单介绍" class="headerlink" title="Git简单介绍"></a>Git简单介绍</h3><p>Git是一个分布式版本控制软件，最初由Linus Torvalds创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。</p>
<a id="more"></a>
<h3 id="Git文件状态变化图解"><a href="#Git文件状态变化图解" class="headerlink" title="Git文件状态变化图解"></a>Git文件状态变化图解</h3><p><img src="https://img.iisheng.cn/lifecycle.png" alt></p>
<h3 id="Git各个区域流程图解"><a href="#Git各个区域流程图解" class="headerlink" title="Git各个区域流程图解"></a>Git各个区域流程图解</h3><p><img src="https://img.iisheng.cn/git-area.png" alt></p>
<ul>
<li>Workspace：工作区</li>
<li>Staging：暂存区</li>
<li>Local Repository：本地仓库（可修改）</li>
<li>Local Remote Repository：本地远程仓库（本地的远程仓库的镜像，不可修改）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="Git简单命令"><a href="#Git简单命令" class="headerlink" title="Git简单命令"></a>Git简单命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在当前目录新建一个git仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开git仓库图形界面</span></span><br><span class="line">gitk</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示所有变更信息</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有Untracked files</span></span><br><span class="line">git clean -fd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载远程仓库的所有更新</span></span><br><span class="line">git fetch remote</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载远程仓库的所有更新，并且Merge</span></span><br><span class="line">git pull romote branch-name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看上次commit id</span></span><br><span class="line">git rev-parse HEAD </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定分支合并到当前分支</span></span><br><span class="line">git merge branch-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将最近的一次commit打包到patch文件中</span></span><br><span class="line">git format-patch HEAD^ </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将patch文件 添加到本地仓库</span></span><br><span class="line">git am  patch-file</span><br></pre></td></tr></table></figure>
<h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将远程git仓库克隆到本地</span></span><br><span class="line">git clone url</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将远程git仓库克隆到本地</span></span><br><span class="line">git clone -b branch url</span><br></pre></td></tr></table></figure>
<h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将修改过，未add到Staging区的文件，暂时存储起来</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复之前stash存储的内容</span></span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存stash 并写message</span></span><br><span class="line">git stash save <span class="string">"stash test"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看stash了哪些存储</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将stash@&#123;1&#125;存储的内容还原到工作区</span></span><br><span class="line">git stash apply stash@&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除stash@&#123;1&#125;存储的内容</span></span><br><span class="line">git stash drop stash@&#123;<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有缓存的stash</span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<h4 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置git图形界面编码为utf-8</span></span><br><span class="line">git config --global gui.encoding=utf-<span class="number">8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局提交代码的用户名 </span></span><br><span class="line">git config --global user.name name  </span><br><span class="line"><span class="comment">// 设置全局提交代码时的邮箱</span></span><br><span class="line">git config --global user.email email</span><br><span class="line"><span class="comment">// 设置当前项目提交代码的用户名 </span></span><br><span class="line">git config user.name name</span><br></pre></td></tr></table></figure>
<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示所有远程仓库</span></span><br><span class="line">git remote -v  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  增加一个新的远程仓库</span></span><br><span class="line">git remote add name url</span><br></pre></td></tr></table></figure>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加所有的修改到Staging区</span></span><br><span class="line">git add .</span><br><span class="line">git add --all  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加指定文件到Staging区</span></span><br><span class="line">git add file   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个修改的文件到Staging区</span></span><br><span class="line">git add file1 file2   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加修改的目录到Staging区</span></span><br><span class="line">git add dir</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加所有src目录下main开头的所有文件到Staging区    </span></span><br><span class="line">git add src/main*</span><br></pre></td></tr></table></figure>
<h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交Staging区的代码到本地仓库区</span></span><br><span class="line">git commit -m <span class="string">"message"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交Staging中在指定文件到本地仓库区</span></span><br><span class="line">git commit file1 file2 -m <span class="string">"message"</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新的一次commit，来覆盖上一次commit</span></span><br><span class="line">git commit --amend -m <span class="string">"message"</span></span><br></pre></td></tr></table></figure>
<h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列出本地所有分支</span></span><br><span class="line">git branch   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出本地所有分支 并显示最后一次提交的哈希值</span></span><br><span class="line">git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在-v 的基础上 并且显示上游分支的名字</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出上游所有分支</span></span><br><span class="line">git branch -r  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch branch-name  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除分支</span></span><br><span class="line">git branch -d branch-name   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分支上游</span></span><br><span class="line">git branch --set-upstream-to origin/master</span><br></pre></td></tr></table></figure>
<h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建本地分支并关联远程分支</span></span><br><span class="line">git checkout -b local-branch origin/remote-branch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个分支，且切换到新分支</span></span><br><span class="line">git checkout -b branch-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换到另一个分支</span></span><br><span class="line">git checkout branch-name  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销工作区文件的修改，跟上次Commit一样</span></span><br><span class="line">git checkout commit-file</span><br></pre></td></tr></table></figure>
<h4 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建带有说明的标签</span></span><br><span class="line">git tag -a v1.4 -m <span class="string">'my version 1.4'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  打标签</span></span><br><span class="line">git tag tag-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看所有标签</span></span><br><span class="line">git tag </span><br><span class="line"></span><br><span class="line"><span class="comment">// 给指定commit打标签</span></span><br><span class="line">git tag tag-name commit-id</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除标签</span></span><br><span class="line">git tag -d tag-name</span><br></pre></td></tr></table></figure>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push origin :master   </span><br><span class="line"></span><br><span class="line"><span class="comment">//  删除远程标签</span></span><br><span class="line">git push origin --delete tag tag-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传本地仓库到远程分支</span></span><br><span class="line">git push remote branch-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行推送当前分支到远程分支</span></span><br><span class="line">git push remote branch-name --force</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送所有分支到远程仓库</span></span><br><span class="line">git push remote --all  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送所有标签</span></span><br><span class="line">git push --tags</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送指定标签</span></span><br><span class="line">git push origin tag-name</span><br><span class="line"></span><br><span class="line"><span class="comment">//  删除远程标签（需要先删除本地标签）</span></span><br><span class="line">git push origin :refs/tags/tag-name</span><br></pre></td></tr></table></figure>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将未commit的文件移出Staging区</span></span><br><span class="line">git reset HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置Staging区与上次commit的一样</span></span><br><span class="line">git reset --hard  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置Commit代码和远程分支代码一样</span></span><br><span class="line">git reset --hard origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退到上个commit</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退到前3次提交之前，以此类推，回退到n次提交之前</span></span><br><span class="line">git reset --hard HEAD~<span class="number">3</span></span><br><span class="line"></span><br><span class="line">回退到指定commit</span><br><span class="line">git reset --hard commit-id</span><br></pre></td></tr></table></figure>
<h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看文件在工作区和暂存区区别</span></span><br><span class="line">git diff file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看暂存区和本地仓库区别</span></span><br><span class="line">git diff --cached  file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看文件和另一个分支的区别</span></span><br><span class="line">git diff branch-name file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看两次提交的区别</span></span><br><span class="line">git diff commit-id commit-id</span><br></pre></td></tr></table></figure>
<h4 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看指定标签的提交信息</span></span><br><span class="line">git show tag-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看具体的某次改动</span></span><br><span class="line">git show commit-id</span><br></pre></td></tr></table></figure>
<h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看该文件的改动历史</span></span><br><span class="line">git log --pretty=oneline file</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形化查看历史提交</span></span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计仓库提交排名前5</span></span><br><span class="line">git log --pretty=<span class="string">'%aN'</span> | sort | uniq -c | sort -k1 -n -r | head -n <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看指定用户添加代码行数，和删除代码行数</span></span><br><span class="line">git log --author=<span class="string">"iisheng"</span> --pretty=tformat: --numstat | awk <span class="string">'&#123; add += $1 ; subs += $2 &#125; END &#123; printf "added lines: %s removed lines : %s \n",add,subs &#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将指定分支合并到当前分支</span></span><br><span class="line">git rebase branch-name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行commit id 将rebase 停留在指定commit 处</span></span><br><span class="line">git rebase -i commit-id</span><br></pre></td></tr></table></figure>
<h4 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复第一次add 的文件，同 git rm --cached</span></span><br><span class="line">git restore --staged file</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除staging区的文件，同 git checkout</span></span><br><span class="line">git restore file</span><br></pre></td></tr></table></figure>
<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 撤销前一次commit</span></span><br><span class="line">git revert HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销前前一次commit</span></span><br><span class="line">git revert HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销指定某次commit</span></span><br><span class="line">git revert commit-id</span><br></pre></td></tr></table></figure>
<h3 id="Git小技巧"><a href="#Git小技巧" class="headerlink" title="Git小技巧"></a>Git小技巧</h3><h4 id="Git命令不能自动补全？（Mac版）"><a href="#Git命令不能自动补全？（Mac版）" class="headerlink" title="Git命令不能自动补全？（Mac版）"></a>Git命令不能自动补全？（Mac版）</h4><p>安装<code>bash-completion</code></p>
<p><code>brew install bash-completion</code></p>
<p>添加 bash-completion 到<code>~/.bash_profile</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f $(brew --prefix)/etc/bash_completion ]; then</span><br><span class="line">   . $(brew --prefix)/etc/bash_completion</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="代码没写完，突然要切换到别的分支怎么办？"><a href="#代码没写完，突然要切换到别的分支怎么办？" class="headerlink" title="代码没写完，突然要切换到别的分支怎么办？"></a>代码没写完，突然要切换到别的分支怎么办？</h4><p>暂存未提交的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p>
<p>还原暂存的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure></p>
<h4 id="怎么合并其他分支的指定Commit？"><a href="#怎么合并其他分支的指定Commit？" class="headerlink" title="怎么合并其他分支的指定Commit？"></a>怎么合并其他分支的指定Commit？</h4><p>使用<code>cherry-pick</code>命令<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git cherry-pick 指定commit-id</span><br></pre></td></tr></table></figure></p>
<h4 id="本地临时代码不想提交，怎么一次性清空？"><a href="#本地临时代码不想提交，怎么一次性清空？" class="headerlink" title="本地临时代码不想提交，怎么一次性清空？"></a>本地临时代码不想提交，怎么一次性清空？</h4><p>还原 未commit 本地更改的代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></p>
<p>还原包含commit的代码，到跟远程分支相同<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p>
<h4 id="已经提交的代码，不需要了，怎么当做没提交过？"><a href="#已经提交的代码，不需要了，怎么当做没提交过？" class="headerlink" title="已经提交的代码，不需要了，怎么当做没提交过？"></a>已经提交的代码，不需要了，怎么当做没提交过？</h4><p>还原到上次commit<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard ~HEAD</span><br></pre></td></tr></table></figure></p>
<p>还原到当前之前的几次commit<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git reset --hard ^<span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>强制推送到远程分支，确保没有其他人在push，不然可能会丢失代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git push origin develop --force</span><br></pre></td></tr></table></figure></p>
<h4 id="怎么保证团队成员提交的代码都是可运行的？"><a href="#怎么保证团队成员提交的代码都是可运行的？" class="headerlink" title="怎么保证团队成员提交的代码都是可运行的？"></a>怎么保证团队成员提交的代码都是可运行的？</h4><p>这里想说的是使用<code>git hooks</code>，一般在项目目录<code>.git/hooks</code>，客户端可以使用hooks，控制团队commit提交规范，或者push之前，自动编译项目校验项目可运行。服务端可以使用hooks，控制push之后自动构建项目，merge等自动触发单元测试等。</p>
<h4 id="git-reset-hard命令，执行错了，能恢复吗？"><a href="#git-reset-hard命令，执行错了，能恢复吗？" class="headerlink" title="git reset --hard命令，执行错了，能恢复吗？"></a><code>git reset --hard</code>命令，执行错了，能恢复吗？</h4><p>当前commit log<br><img src="https://img.iisheng.cn/current-commit-log.png" alt></p>
<p>误操作<code>git reset --hard 8529c</code><br><img src="https://img.iisheng.cn/after-reset.png" alt></p>
<p>执行<code>git reflog</code><br><img src="https://img.iisheng.cn/reflog.png" alt></p>
<p>还原到之前的样子<br><img src="https://img.iisheng.cn/restore.png" alt></p>
<h4 id="公司使用GitLab，平时还用GitHub，多账号SSH，如何配置？"><a href="#公司使用GitLab，平时还用GitHub，多账号SSH，如何配置？" class="headerlink" title="公司使用GitLab，平时还用GitHub，多账号SSH，如何配置？"></a>公司使用GitLab，平时还用GitHub，多账号SSH，如何配置？</h4><p>编辑 <code>~/.ssh/config</code>文件 没有就创建<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> github</span><br><span class="line">Host github.com</span><br><span class="line">Port 22</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">UseKeychain yes</span><br><span class="line">User iisheng</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> gitlab</span><br><span class="line">Host gitlab.iisheng.cn</span><br><span class="line">Port 22</span><br><span class="line">HostName gitlab.iisheng.cn</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">IdentityFile ~/.ssh/gitlab_id_rsa</span><br><span class="line">UseKeychain yes</span><br><span class="line">User iisheng</span><br></pre></td></tr></table></figure></p>
<h4 id="Git-Commits如何变得清爽起来？"><a href="#Git-Commits如何变得清爽起来？" class="headerlink" title="Git Commits如何变得清爽起来？"></a>Git Commits如何变得清爽起来？</h4><p>使用<code>git rebase</code>，放弃<code>git merge</code>。<code>git rebase</code>会更改commit历史，请谨慎使用。</p>
<p>下面的图是Guava项目的Commit记录。<br><img src="https://img.iisheng.cn/commits-history.png" alt></p>
<h4 id="如何修改已经提交的Commit？"><a href="#如何修改已经提交的Commit？" class="headerlink" title="如何修改已经提交的Commit？"></a>如何修改已经提交的Commit？</h4><p>原始git提交记录是这样的<br><img src="https://img.iisheng.cn/origin-log.png" alt></p>
<p>执行<code>git rebase  -i 070943d9465177f869359a52b01ec1cfcecaa41b</code>，对指定commitId之前的提交，进行修改<br><img src="https://img.iisheng.cn/rebase-modifying.png" alt></p>
<p>修改后git提交记录变成了这样<br><img src="https://img.iisheng.cn/modified-log.png" alt></p>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章掌握Maven</title>
    <url>/2019/12/07/maven/</url>
    <content><![CDATA[<h3 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h3><p>Maven，这个单词来源于犹太语，意味着知识的积累。最初在Jakarta Turbine 项目中用来简化构造项目流程。最终，形成给予Java项目的构建和管理的工具。</p>
<a id="more"></a>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><p>安装比较简单，官网下载，配置环境即可。这里推荐一下，安装之后配置仓库镜像，可以加快访问速度。</p>
<p>编辑<code>settings.xml</code>，在<code>&lt;/mirrors&gt;</code>之前添加<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Maven-创建项目"><a href="#Maven-创建项目" class="headerlink" title="Maven 创建项目"></a>Maven 创建项目</h3><h4 id="创建基本的Java项目"><a href="#创建基本的Java项目" class="headerlink" title="创建基本的Java项目"></a>创建基本的Java项目</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line"> -DgroupId=com.mycompany.app \</span><br><span class="line"> -DartifactId=my-app \</span><br><span class="line"> -DarchetypeArtifactId=maven-archetype-quickstart \</span><br><span class="line"> -DinteractiveMode=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>使用其他工具创建项目也如出一辙。</p>
<h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p><img src="https://img.iisheng.cn/maven-project-directory.png" alt></p>
<h3 id="Maven-基本概念"><a href="#Maven-基本概念" class="headerlink" title="Maven 基本概念"></a>Maven 基本概念</h3><h4 id="POM（Project-Object-Model）"><a href="#POM（Project-Object-Model）" class="headerlink" title="POM（Project Object Model）"></a>POM（Project Object Model）</h4><p>POM的全称是Project Object Model，用通俗点的话说就是对要构建的项目进行建模，将要构建的项目看成是一个对象（Object）。</p>
<p>我们可以用我们熟悉的一个Java代码来描述一下这个对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/05 15:12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示组织或者组织的项目唯一的标识符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示项目内部组件的标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String artifactId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打包方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String packaging;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示该artifact 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖的其他项目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ProjectObject&gt; dependencies;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父级项目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProjectObject parent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子模块项目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ProjectObject&gt; modules;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面几个属性 仅仅用于生成文档</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目展示名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目网址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Lifecycle（生命周期）"><a href="#Lifecycle（生命周期）" class="headerlink" title="Lifecycle（生命周期）"></a>Lifecycle（生命周期）</h4><p>在Maven中一次构建过程就是一个Lifecycle，这个Lifecycle分为多个阶段，每个阶段叫做Phase。有三种构建的生命周期，分别是<code>default</code>、<code>clean</code>、<code>site</code>。<code>default</code>用于部署项目，<code>clean</code>用于清理项目，而<code>site</code>用于创建项目文档。</p>
<p><code>default</code>Lifecycle包含如下Phase:</p>
<ul>
<li>validate：校验项目和一些必要信息是可用的</li>
<li>compile：编译项目源码</li>
<li>test：执行源码的单元测试模块</li>
<li>package：将项目打包，比如打包成jar文件</li>
<li>verify：对集成测试的结果进行检查，以确保满足质量标准</li>
<li>install：将软件包安装到本地仓库中</li>
<li>deploy：将软件包部署到远程仓库</li>
</ul>
<h4 id="maven-常用命令介绍"><a href="#maven-常用命令介绍" class="headerlink" title="maven 常用命令介绍"></a>maven 常用命令介绍</h4><p>清理项目产生的临时文件，一般是模块下的target目录<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></p>
<p>项目打包工具，会在模块下的target目录生成jar或者war等文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn <span class="keyword">package</span></span><br></pre></td></tr></table></figure></p>
<p>测试命令或者执行src/test/java下面的测试用例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure></p>
<p>模块安装命令，将打包的jar或者war文件复制到本地仓库，使用-Dmaven.test.skip=true 跳过测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure></p>
<p>发布命令，将打包的文件发布到maven仓库<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure></p>
<p>maven 多个命令同时使用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn clean <span class="keyword">package</span> -U -Dmaven.test.skip=<span class="keyword">true</span> -P test</span><br></pre></td></tr></table></figure></p>
<h4 id="Phase和Goals"><a href="#Phase和Goals" class="headerlink" title="Phase和Goals"></a>Phase和Goals</h4><p>Lifecycle只规定了项目构建的流程，即先执行<code>validate</code>，再<code>compile</code>等一系列Phase，但并没有定义每一个Phase具体做什么。这里Phase的作用类似于Java中的接口，而Phase的具体实现在Goals里面。</p>
<p>一个Phase必须绑定一个或多个Goals，才能执行具体的构建流程。为了让用户不用任何配置就能使用Maven项目，Maven默认为一些核心声明周期的Phase绑定了Goals。</p>
<p>如果需要自定义绑定，可以在<code>pom.xml</code>文件中配置。</p>
<h3 id="Maven核心概念"><a href="#Maven核心概念" class="headerlink" title="Maven核心概念"></a>Maven核心概念</h3><h4 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h4><p>Maven坐标主要是为了标识项目的唯一性。由下面几个属性组成：</p>
<ul>
<li>groupId：组织或者组织的项目名称</li>
<li>artifactId：项目中的具体模块</li>
<li>version：项目版本</li>
<li>packaging：项目打包方式</li>
<li>classifier：用于区分从同一POM构建的具有不同内容的构件</li>
</ul>
<h4 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h4><p>存储管理构件（JAR、WAR等）的地方。</p>
<p>一般分为以下三类：</p>
<ul>
<li>本地仓库：默认是<code>~/.m2/repository</code> 目录，可在配置文件中配置其他目录</li>
<li>私服：内网的Maven仓库</li>
<li>中央仓库：Maven社区提供的仓库，包含大量的常用库</li>
</ul>
<h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><p>在<code>pom.xml</code>配置项目依赖，比如<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>scope</code>用来控制依赖和编译、测试、运行的classpath的关系。有下面三种关系：</p>
<ul>
<li>compile：默认编译依赖范围。对于编译、测试、运行三种classpath都有效</li>
<li>test：测试依赖范围。只对测试classpath有效</li>
<li>provided：已提供依赖范围。编译、测试classpath有效，对于运行无效。</li>
<li>runtime：运行时提供</li>
<li>test：仅用于测试，且不可传递</li>
<li>system：类似于provided，但必须显示提供JAR</li>
<li>import：仅在<code>dependencyManagement</code>下支持。</li>
</ul>
<h5 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h5><p>Maven是通过<strong>传递依赖</strong>解析JAR包依赖，比如我项目中引入junit，在解析我的项目的时候，不仅仅仅有junit，还有junit依赖的JAR包。</p>
<p><img src="https://img.iisheng.cn/maven-dependency.png" alt></p>
<h5 id="包冲突时怎么产生的？"><a href="#包冲突时怎么产生的？" class="headerlink" title="包冲突时怎么产生的？"></a>包冲突时怎么产生的？</h5><p>假设 A-&gt;B-&gt;C-&gt;D1， E-&gt;F-&gt;D2，D1、D2 分别为 D 的不同版本。</p>
<p>如果 <code>pom.xml</code> 文件中引入了 A 和 E 之后，按照 Maven 传递依赖原则，工程内需要引入的实际 JAR 包将会有：A B C D1 和 E F D2，因此 D1、D2 将会产生包冲突。</p>
<h5 id="如何解决包冲突？"><a href="#如何解决包冲突？" class="headerlink" title="如何解决包冲突？"></a>如何解决包冲突？</h5><p>Maven解析<code>pom.xml</code>的时候，同一个JAR包只会保留一个。</p>
<p>对于包冲突，Maven处理策略：</p>
<ul>
<li>最短路径优先：Maven面对 D1 D2，会选择最短路径的那个，即D2。因为，E-&gt;F-&gt;D2 比 A-&gt;B-&gt;C-&gt;D1 路径短。</li>
<li>最先声明优先：如果路径一样，就选择最先声明的JAR包。</li>
</ul>
<h5 id="如何移除依赖？"><a href="#如何移除依赖？" class="headerlink" title="如何移除依赖？"></a>如何移除依赖？</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Maven聚合"><a href="#Maven聚合" class="headerlink" title="Maven聚合"></a>Maven聚合</h4><p>模块化，各个模块看起来更清晰。更主要的优点是，在项目根目录构建项目的时候，下面所有module里面的项目都会跟着同时构建。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;study-common&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;study-dao&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;study-service&lt;/module&gt;</span><br><span class="line">	&lt;module&gt;study-web&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Maven继承"><a href="#Maven继承" class="headerlink" title="Maven继承"></a>Maven继承</h4><p>继承为了消除重复。可以把很多相同的配置提取出来。</p>
<p>子模块通过<code>parent</code>标签配置，继承父模块属性。父模块通过<code>dependencyManagement</code>标签进行管理。</p>
<p>多模块版本号可以通过maven命令操作，在项目根目录执行</p>
<h5 id="设置新版本号"><a href="#设置新版本号" class="headerlink" title="设置新版本号"></a>设置新版本号</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn versions:set -DnewVersion=<span class="number">0.0</span>.2-SNAPSHOT</span><br></pre></td></tr></table></figure>
<h5 id="回滚设置新版本号操作"><a href="#回滚设置新版本号操作" class="headerlink" title="回滚设置新版本号操作"></a>回滚设置新版本号操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn versions:revert</span><br></pre></td></tr></table></figure>
<h5 id="提交设置新版本号操作"><a href="#提交设置新版本号操作" class="headerlink" title="提交设置新版本号操作"></a>提交设置新版本号操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mvn versions:commit</span><br></pre></td></tr></table></figure>
<p>Maven多模块项目结构，以及Maven属性继承配置等，可以参考这个项目<a href="https://github.com/iisheng/mybatis-study" target="_blank" rel="noopener">iisheng/mybatis-study</a></p>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之垃圾回收算法</title>
    <url>/2019/10/27/java-gc-algorithm/</url>
    <content><![CDATA[<h3 id="判断对象是否死亡的方法"><a href="#判断对象是否死亡的方法" class="headerlink" title="判断对象是否死亡的方法"></a>判断对象是否死亡的方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被引用。</p>
<blockquote>
<p>很难解决对象之间相互循环引用的问题。</p>
</blockquote>
<a id="more"></a>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列叫做“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般的Native方法）引用的对象</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次减弱。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是指在程序中普遍存在的，类似<code>Object obj = new Object();</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后 使用<code>SoftReference</code>类来实现软引用。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后 使用<code>WeakReference</code>类来实现弱引用。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时受到一个系统通知。在JDK 1.2之后 使用<code>PhantomReference</code>类来实现虚引用。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要清除的对象，在标记完成后统一回收所有被标记的对象。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都像一端移动，然后直接清理掉端边界以外的内存。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>将对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适用的收集算法。</p>
<p>在新生代中每次垃圾收集时都有大量对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而老年代因为对象存活率高、没有额外空间对它进行分配的担保，就必须使用<strong>标记-清理</strong>或者<strong>标记-整理</strong>算法来进行回收。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>HotSpot虚拟机的垃圾收集器<br><img src="/images/hotspot-garbage-collector.png" alt></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是单线程收集器。它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>Serial收集器是使用复制垃圾回收算法的收集器。</p>
<p>Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World 、对象分配规则、回收策略等都与Serial完全一样。</p>
<h4 id="什么是并发什么是并行"><a href="#什么是并发什么是并行" class="headerlink" title="什么是并发什么是并行"></a>什么是并发什么是并行</h4><p>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>CMS等收集器关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput）。</p>
<p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花费1分钟，那吞吐量就是99%。</p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRadio</code>参数。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器老年代版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。这个收集器的主要意义在于给Client模式下的虚拟机使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>标记-整理</strong>算法。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短。CMS收集器就非常符合这类应用的需求。</p>
<p>CMS收集器使用<strong>标记-整理</strong>算法实现的。它的运作过程包括以下四个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。</p>
<p>初始标记仅仅只是标记一下GC Roots能直接关联的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p>
<p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿。但是它也有以下4个明显缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致另一次Full GC的产生。</li>
<li>基于<strong>标记-清除</strong>算法实现，有可能收集结束时有大量空间碎片产生。</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。G1具有如下特点：</p>
<ul>
<li>并行与并发：G1能充分利用多CPU，来缩短Stop The World停顿时间，仍然可以通过并发的方式让Java程序继续运行。</li>
<li>分代收集：它能采用不同的方式处理新创建的对象和已经存活一段时间的对象、熬过多次GC的旧对象以获取更好的收集效果。</li>
<li>空间整合：G1从整体来看是基于<strong>标记-整理</strong>算法，从局部（两个Region）上来看是基于<strong>复制</strong>算法实现的。这两种算法都不会产生空间碎片，收集后能提供规整的可用内存。</li>
<li>可预测的停顿：除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N秒。</li>
</ul>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage First的由来）。</p>
<p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用<code>Remembered Set</code>来避免全堆扫描的。G1中每个Region都有一个与之对应的<code>Remembered Set</code>，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个<code>Write Barrier</code>暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的<code>Remembered Set</code>之中。当进行内存回收时，在GC根节点的枚举范围中加入<code>Remembered Set</code>既可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计维护<code>Remembered Set</code>的操作，G1收集器的运作大概分为以下几步：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>。</p>
<p>虚拟机提供了<code>-XX:PrintGCDetails</code>这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的那种大对象就是那种很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间。</p>
<p>虚拟机提供一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配（不是所有虚拟机都支持该参数）。这样做的目的是避免在Eden区以及两个<code>Suvivor</code>区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这一点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生，并且经历过一次<code>Minor GC</code>后仍存活，并且能被<code>Suvivor</code>容纳的话，将被移动到<code>Suvivor</code>空间中，并且对象年龄设为1。对象在<code>Suvivor</code>区中没熬过一次<code>Minor GC</code>，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>
<p>对象晋升到老年代的阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到了<code>MaxTenuringThreshold</code>才能晋升老年代，如果在<code>Suvivor</code>空间中相同年龄所有对象大小的总和大于<code>Suvivor</code>空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code>中要去的年龄。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生<code>Minor GC</code>之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<code>HandlePromotionFailure</code>设置不允许冒险，那这时也要改为进行一次 <code>Full GC</code>。</p>
<h3 id="Minor-GC和Full-GC有什么不一样？"><a href="#Minor-GC和Full-GC有什么不一样？" class="headerlink" title="Minor GC和Full GC有什么不一样？"></a>Minor GC和Full GC有什么不一样？</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>新生代GC （Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC会非常频繁，一般回收速度也比较快。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>老年代GC （Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（非绝对）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>垃圾回收算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引 底层数据结构 B+树是什么</title>
    <url>/2019/10/25/b+tree/</url>
    <content><![CDATA[<p>Innodb索引底层数据结构式B+树。所以介绍索引实现原理之前，我们来看一下什么是B+树。看B+树之前我们，要了解一下二叉查找树和平衡二叉树。</p>
<h3 id="什么是二叉查找树？"><a href="#什么是二叉查找树？" class="headerlink" title="什么是二叉查找树？"></a>什么是二叉查找树？</h3><p>二叉查找树，又叫做二叉排序树，也叫做二叉搜索树。</p>
<a id="more"></a>
<p>二叉查找树或者使用一颗空树；或者是具有下列性质的二叉树</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若他的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左右子树也分别为二叉搜索树。</li>
</ul>
<p>可以看出来，二叉查找树中序遍历可以得到一个关键字的有序序列。二叉查找树既拥有类似折半查找的特性，又采用了链表做存储结构，因此是动态查找表的一种适宜表示。</p>
<p>在二叉查找树上查找其关键字等于给定值结点的过程，恰是走了一条从根结点到该结点的路径的过程。所以，含有n个结点的二叉查找树夫人平均查找长度和树的形态有关。</p>
<p>当先后插入的关键字有序时，构成的二叉查找树蜕变为单支树。<br>所以，需要对二叉查找树 进行 <strong>平衡化</strong>处理，成为二叉平衡树。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树（Balanced Binary Tree）又称AVL树。它或者是一颗空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</p>
<p>如果二叉查找树是AVL树，则它的深度和logn是同数量级的。因此，它的平均查找长度也和logn同数量级。</p>
<h3 id="B-Tree平衡多路查找树"><a href="#B-Tree平衡多路查找树" class="headerlink" title="B-Tree平衡多路查找树"></a>B-Tree平衡多路查找树</h3><p>B-Tree是一种平衡的多路查找树。一颗m阶的的B-树，或为满足下列特性的m叉树：</p>
<ul>
<li>树中每个结点最多有m棵子树；</li>
<li>若根结点不是叶子结点，则至少有两棵子树；</li>
<li>除根之外的所有非终端结点至少有【m/2】棵子树；</li>
<li>所有非终端结点中包含信息数据；</li>
<li>所有叶子结点都出现在同一层次上，并且不带信息。</li>
</ul>
<p>由B-树定义可知，在B-树上进行查找的过程和二叉查找树的查找类似。B-树查找包含两种基本操作：</p>
<ul>
<li>在B-树中找结点；</li>
<li>在结点中找关键字。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是应文件系统所需而出的一种B-树的变形树。一棵m阶的B+树和m阶的B-树的差异在于：</p>
<ul>
<li>有n棵子树的结点中含有n个关键字。</li>
<li>所有叶子结点中包含了全部关键字的信息，以及指向这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有非终端结点可以看成是索引部分，结点中仅含有其子树中的最大（或最小）关键字。</li>
</ul>
<p>B+树上的查找类似B-树。只是在查找时，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。</p>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之Java类加载机制</title>
    <url>/2019/10/23/java-class-load-mechanism/</url>
    <content><![CDATA[<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>任何一个Class文件都对应着唯一一个类或者接口的定义信息</p>
<a id="more"></a>
<ul>
<li>魔数：确定这个文件是否是一个能被虚拟机接受的Class文件</li>
<li>版本号：低版本不能执行高版本Class文件，高版本可以执行低版本</li>
<li>常量池：Class文件中的资源仓库</li>
<li>访问标志：用于识别一些类或者接口层次的访问信息</li>
<li>类索引、父类索引、索引集合：确定类的继承关系</li>
<li>字段表：用于描述接口或者类中声明的变量</li>
<li>方法表：用于描述方法上声明的变量</li>
<li>属性表：Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息</li>
</ul>
<h4 id="常量池详细介绍"><a href="#常量池详细介绍" class="headerlink" title="常量池详细介绍"></a>常量池详细介绍</h4><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。<strong>这个容量计数是从1开始的</strong>，第0项位置是用来表达<strong>不引用任何一个常量池项目</strong>的含义。</p>
<p>常量池主要存放两大类常量，字面量（Literal）和符号引用（Symbolic References）。字面量比较接近Java语言层面常量的概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的元限定名（Full Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法名称和描述符</li>
</ul>
<p>在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个证明周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载阶段，虚拟机会完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。</p>
<p>验证阶段大致会完成以下4个阶段的检验动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>首先，这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>其次，这里所说的初始值，通常情况是数据类型的零值。</p>
<p>相对的，有一些特殊情况：如果类字段的字段属性表中存在<code>ConstantValue</code>，那在准备阶段变量就会初始化为<code>ConstantValue</code>属性所指的值。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h5 id="符合引用（Symbolic-References）"><a href="#符合引用（Symbolic-References）" class="headerlink" title="符合引用（Symbolic References）"></a>符合引用（Symbolic References）</h5><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</p>
<h5 id="直接引用（Direct-References）"><a href="#直接引用（Direct-References）" class="headerlink" title="直接引用（Direct References）"></a>直接引用（Direct References）</h5><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>是类加载过程的最后一步。在准备阶段，变量已经赋过一次系统要求的初始值。而在初始化阶段，则根据程序员的代码去初始化类变量和其他资源。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++实现，是虚拟机自身的一部分；另一种就是所有其他类加载器，这些类加载器都是由Java实现的，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>从Java开发人员的角度，类加载器可以分为以下三种：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器负责将<code>JAVA_HOME/lib</code>类库加载到虚拟机内存中。</li>
<li>扩展类加载器：（Extension ClassLoader）:它负责加载<code>JAVA_HOME/lib/ext</code>类库加载到虚拟机内存中。</li>
<li>应用程序类加载器（Application ClassLoader）:它负责加载用户类路径上所指定的类库。</li>
</ul>
<h4 id="双亲委派模型工作过程："><a href="#双亲委派模型工作过程：" class="headerlink" title="双亲委派模型工作过程："></a>双亲委派模型工作过程：</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求派给父类加载器去完成，每一层的加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h4 id="双亲委派模型优点："><a href="#双亲委派模型优点：" class="headerlink" title="双亲委派模型优点："></a>双亲委派模型优点：</h4><p>Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如<code>java.lang.Object</code>，无论哪一个类加载器要加载这个类，最终都会委派给处于模型最顶端的启动类加载器进行加载，因此<code>Object</code>类在程序的各种类加载器环境中都是同一个类。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM之Java内存区域</title>
    <url>/2019/10/22/java-memory-area/</url>
    <content><![CDATA[<h3 id="JVM-内存区域模型"><a href="#JVM-内存区域模型" class="headerlink" title="JVM 内存区域模型"></a>JVM 内存区域模型</h3><p>JVM 内存区域基本上由4个区域组成：</p>
<a id="more"></a>
<ul>
<li>类加载器：在JVM启动时或者类运行时，将需要的class加载到JVM中。</li>
<li>运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块。</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。</li>
<li>本地方法调用：执行C/C++实现的本地方法的代码，并返回结果。</li>
</ul>
<p><img src="/images/jvm-composition.png" alt></p>
<h3 id="Java-运行时数据区域"><a href="#Java-运行时数据区域" class="headerlink" title="Java 运行时数据区域"></a>Java 运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
<h4 id="元数据（方法区）"><a href="#元数据（方法区）" class="headerlink" title="元数据（方法区）"></a>元数据（方法区）</h4><p>各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是元数据的一部分，用于存放编译器生成的各种字面量和符号引用。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时数据的一部分。JDK1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存的限制。也可能导致<code>OutOfMemoryError</code>出现。</p>
<h3 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot虚拟机对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。</p>
<p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>并不是必然存在，仅仅起着占位符的作用。</p>
<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>Java对象需要通过栈上的reference数据来操作堆上的具体对象。对象的具体访问方式取决于虚拟机的实现。主流的访问方式有使用句柄和直接指针两种。</p>
<h4 id="使用句柄访问对象"><a href="#使用句柄访问对象" class="headerlink" title="使用句柄访问对象"></a>使用句柄访问对象</h4><p><img src="/images/handle-visit-object.png" alt></p>
<h4 id="使用直接指针访问对象"><a href="#使用直接指针访问对象" class="headerlink" title="使用直接指针访问对象"></a>使用直接指针访问对象</h4><p><img src="/images/direct-pointer-visit-object.png" alt></p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p><strong>栈帧</strong>是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接（dynamic linking）、方法返回值和异常分派（dispatch exception）。</p>
<p>栈帧随着方法调用而创建，随着方法结束而销毁。栈帧的存储空间<br>由创建它的线程分配在Java虚拟机栈之中。每一个栈帧都有一个本地变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>每个栈帧内部都包含一组称为局部变量表的变量列表。</p>
<p>一个局部变量表可以保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress的数据，两个局部变量可以保存一个类型为long或double的数据。</p>
<p>局部变量使用索引来进行定位访问，首个局部变量的索引值为0。</p>
<p>Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用类方法时，它的参数将会依次传递到局部变量表中从0开始的连续位置上。当调用实例对象方法时，第0个局部变量一定会用来存储该实例方法所在对象的引用（即this关键字）。后续的其他参数将会传递至局部变量表中从1开始的连续位置上。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每个栈帧内部包含一个称为<strong>操作数栈</strong>的后进先出栈。</p>
<p>随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>在class文件里，一个方法若想调用其他方法，或者访问成员变量，则需要通过符号引用（symbolic reference）来表示，动态链接的作用就是将这些以符号引用所表示的方法转换为对实际方法的直接引用。</p>
]]></content>
      <categories>
        <category>🙃Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之MySQL</title>
    <url>/2019/10/20/interview-mysql/</url>
    <content><![CDATA[<h3 id="MySQL范式与反模式"><a href="#MySQL范式与反模式" class="headerlink" title="MySQL范式与反模式"></a>MySQL范式与反模式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p><strong>每列都保持原子性。</strong></p>
<p>举个例子，活动表（活动编码，活动名称，活动地址），假设这个场景中，活动地址可以细分为国家、省份、城市、市区、位置，那么就没有达到第一范式。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><strong>非主属性不部分依赖于候选码。</strong></p>
<p>举个例子，版本表（版本编码，版本名称，产品编码，产品名称），其中主键是（版本编码，产品编码），这个场景中，数据库设计并不符合第二范式，因为产品名称只依赖于产品编码。存在部分依赖。所以，为了使其满足第二范式，可以改造成两个表：版本表（版本编码，产品编码）和产品表（产品编码，产品名称）。</p>
<a id="more"></a>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p><strong>非主属性不传递依赖于候选码。</strong></p>
<p>举个例子，订单表（订单编码，顾客编码，顾客名称），其中主键是（订单编码），这个场景中，顾客编码、顾客名称都完全依赖于主键，因此符合第二范式，但是顾客名称依赖于顾客编码，从而间接依赖于主键，所以不能满足第三范式。为了使其满足第三范式，可以拆分两个表：订单表（订单编码，顾客编码）和顾客表（顾客编码，顾客名称），拆分后的数据库设计，就可以完全满足第三范式的要求了。</p>
<p>值得注意的是，第二范式的侧重点是非主键列是否完全依赖于主键，还是依赖于主键的一部分。第三范式的侧重点是非主键列是直接依赖于主键，还是直接依赖于非主键列。</p>
<h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><p>范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。</p>
<p>然而，通过数据库范式化设计，将导致数据库业务涉及的表变多，并且可能需要将涉及的业务表进行多表连接查询，这样将导致性能变差，且不利于分库分表。因此，出于性能优先的考量，可能在数据库的结构中需要使用反模式的设计，即空间换取时间，采取数据冗余的方式避免表之间的关联查询。至于数据一致性问题，因为难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。</p>
<p>需要谨慎使用反模式设计数据库。一般情况下，尽可能使用范式化的数据库设计，因为范式化的数据库设计能让产品更加灵活，并且能在数据库层保持数据完整性。</p>
<p>有的时候，提升性能最好的方法是在同一表中保存冗余数据，如果能容许少量的脏数据，创建一张完全独立的汇总表或缓存表是非常好的方法。举个例子，设计一张“下载次数表”来缓存下载次数信息，可使在海量数据的情况下，提高查询总数信息的速度。</p>
<p>另外一个比较典型的场景，出于扩展性考虑，可能会使用 BLOB 和 TEXT 类型的列存储 JSON 结构的数据，这样的好处在于可以在任何时候，将新的属性添加到这个字段中，而不需要更改表结构。但是，这个设计的缺点也比较明显，就是需要获取整个字段内容进行解码来获取指定的属性，并且无法进行索引、排序、聚合等操作。因此，如果需要考虑更加复杂的使用场景，更加建议使用 MongoDB 这样的文档型数据库。</p>
<h3 id="MySQL-中-VARCHAR-与-CHAR-的区别？VARCHAR-50-中的-50-代表的涵义？"><a href="#MySQL-中-VARCHAR-与-CHAR-的区别？VARCHAR-50-中的-50-代表的涵义？" class="headerlink" title="MySQL 中 VARCHAR 与 CHAR 的区别？VARCHAR(50) 中的 50 代表的涵义？"></a>MySQL 中 <code>VARCHAR</code> 与 <code>CHAR</code> 的区别？<code>VARCHAR(50)</code> 中的 50 代表的涵义？</h3><ul>
<li>CHAR 是一种固定长度的类型，如果插入长度小于定义长度，则用空格填充</li>
<li>CARCHAR 则是一种可变长度的类型，如果插入长度小于定于长度，还是按照实际长度存储。</li>
<li>VARCHAR(50) 中 50 的涵义最多存放 50 个字符。VARCHAR(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 ORDER BY col 采用 fixed_length 计算 col 长度(memory引擎也一样)。</li>
</ul>
<h3 id="INT-11-中的-11-代表什么涵义？"><a href="#INT-11-中的-11-代表什么涵义？" class="headerlink" title="INT(11) 中的 11 代表什么涵义？"></a><code>INT(11)</code> 中的 11 代表什么涵义？</h3><p><code>INT(11)</code> 中的 11 ，不影响字段存储的范围，<strong>代表字符的显示宽度</strong>。</p>
<h3 id="索引的类型（InnoDB）有哪些？"><a href="#索引的类型（InnoDB）有哪些？" class="headerlink" title="索引的类型（InnoDB）有哪些？"></a>索引的类型（InnoDB）有哪些？</h3><p>索引，都是实现在存储引擎层的。主要有六种类型：</p>
<ul>
<li>主键索引</li>
<li>外键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ul>
<h3 id="MySQL语句中需要注意走不走索引的一些情况"><a href="#MySQL语句中需要注意走不走索引的一些情况" class="headerlink" title="MySQL语句中需要注意走不走索引的一些情况"></a>MySQL语句中需要注意走不走索引的一些情况</h3><h4 id="不走索引"><a href="#不走索引" class="headerlink" title="不走索引"></a>不走索引</h4><ul>
<li>在 WHERE 子句中使用 表达式 比如 <code>WHERE id % 2=0</code></li>
<li>LIKE 查询 前 %</li>
<li>联合索引不满足前缀原则</li>
</ul>
<h4 id="有可能走索引，有可能不走，MySQL会比较怎执行效率高"><a href="#有可能走索引，有可能不走，MySQL会比较怎执行效率高" class="headerlink" title="有可能走索引，有可能不走，MySQL会比较怎执行效率高"></a>有可能走索引，有可能不走，MySQL会比较怎执行效率高</h4><ul>
<li>在 WHERE 子句中使用 <code>!=</code> </li>
<li>在 WHERE 子句中使用 <code>&lt;&gt;</code></li>
<li>在 WHERE 子句中使用 <code>OR</code> </li>
<li>在 WHERE 子句中使用 <code>IN</code></li>
</ul>
<h3 id="什么是索引的最左匹配特性？"><a href="#什么是索引的最左匹配特性？" class="headerlink" title="什么是索引的最左匹配特性？"></a>什么是索引的最左匹配特性？</h3><p>当 B+Tree 的数据项是复合的数据结构，比如索引 (name, age, sex) 的时候，B+Tree 是按照从左到右的顺序来建立搜索树的。</p>
<ul>
<li><p>比如当 (张三, 20, F) 这样的数据来检索的时候，B+Tree 会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex ，最后得到检索的数据。</p>
</li>
<li><p>但当 (20, F) 这样的没有 name 的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</p>
</li>
<li><p>比如当 (张三, F) 这样的数据来检索时，B+Tree 可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了。<br>这个是非常重要的性质，即索引的最左匹配特性。</p>
</li>
</ul>
<h3 id="事务的特性？"><a href="#事务的特性？" class="headerlink" title="事务的特性？"></a>事务的特性？</h3><ol>
<li>原子性 Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>一致性 Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>隔离性 Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性 Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h3 id="事务的并发问题有哪些？"><a href="#事务的并发问题有哪些？" class="headerlink" title="事务的并发问题有哪些？"></a>事务的并发问题有哪些？</h3><p>实际场景下，事务并不是串行的，所以会带来如下三个问题：</p>
<ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p>
<h3 id="MySQL-事务隔离级别会产生的并发问题？"><a href="#MySQL-事务隔离级别会产生的并发问题？" class="headerlink" title="MySQL 事务隔离级别会产生的并发问题？"></a>MySQL 事务隔离级别会产生的并发问题？</h3><p>事务定义了四种事务隔离级别，不同数据库在实现时，产生的并发问题是不同的。</p>
<blockquote>
<p>不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。</p>
</blockquote>
<ul>
<li>READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其他事务也都是可见的。<blockquote>
<p><strong>会导致脏读</strong></p>
</blockquote>
</li>
<li>READ COMMITTED（读提交）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。<blockquote>
<p><strong>会导致不可重复读</strong>。这个隔离级别，也可以叫做“不可重复读”。</p>
</blockquote>
</li>
<li>REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。<blockquote>
<p><strong>会导致幻读</strong></p>
</blockquote>
</li>
<li>SERIALIZABLE（串行化）：强制事务串行执行。<blockquote>
<p>不会产生上述问题</p>
</blockquote>
</li>
</ul>
<h3 id="MySQL-查询执行顺序？"><a href="#MySQL-查询执行顺序？" class="headerlink" title="MySQL 查询执行顺序？"></a>MySQL 查询执行顺序？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)     SELECT</span><br><span class="line">(<span class="number">2</span>)     DISTINCT &lt;select_list&gt;</span><br><span class="line">(<span class="number">3</span>)     FROM &lt;left_table&gt;</span><br><span class="line">(<span class="number">4</span>)     &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(<span class="number">5</span>)     ON &lt;join_condition&gt;</span><br><span class="line">(<span class="number">6</span>)     WHERE &lt;where_condition&gt;</span><br><span class="line">(<span class="number">7</span>)     GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(<span class="number">8</span>)     HAVING &lt;having_condition&gt;</span><br><span class="line">(<span class="number">9</span>)     ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(<span class="number">10</span>)    LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h3><ul>
<li>通过事务隔离级别和MVCC，保证没有脏读和不可重复读</li>
<li>InnoDB默认使用行锁</li>
<li>一般情况的查询，我们基本使用<strong>快照读</strong>，即不加锁读。</li>
<li><code>UPDATE</code>语句和<code>DELETE</code>语句执行的时候，使用的是<strong>当前读</strong>，即加锁。</li>
</ul>
<h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>多版本并发控制（MVCC），是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。</p>
<h3 id="索引原理（InnoDB）"><a href="#索引原理（InnoDB）" class="headerlink" title="索引原理（InnoDB）"></a>索引原理（InnoDB）</h3><p>InnoDB索引底层数据结构是基于B+树实现的。</p>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>MySQL面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java虚拟机</title>
    <url>/2019/10/19/interview-java-jvm/</url>
    <content><![CDATA[<h3 id="什么是Java虚拟机？"><a href="#什么是Java虚拟机？" class="headerlink" title="什么是Java虚拟机？"></a>什么是Java虚拟机？</h3><p>Java虚拟机是一个可以执行Java字节码（Java 源文件被编译成能被 Java 虚拟机执行的字节码文件( .class )）的虚拟机进程。</p>
<p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<p>但是，跨平台的是 Java 程序(包括字节码文件)，，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 。</p>
<a id="more"></a>
<h3 id="JVM内存区域模型"><a href="#JVM内存区域模型" class="headerlink" title="JVM内存区域模型"></a>JVM内存区域模型</h3><p>JVM 内存区域基本上由4个区域组成：</p>
<ul>
<li>类加载器：在JVM启动时或者类运行时，将需要的class加载到JVM中。</li>
<li>运行时数据区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块。</li>
<li>执行引擎：负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。</li>
<li>本地方法调用：执行C/C++实现的本地方法的代码，并返回结果。</li>
</ul>
<p><img src="/images/jvm-composition.png" alt></p>
<h3 id="Java-运行时数据区域"><a href="#Java-运行时数据区域" class="headerlink" title="Java 运行时数据区域"></a>Java 运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 8:1:1 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
<h4 id="元数据（方法区）"><a href="#元数据（方法区）" class="headerlink" title="元数据（方法区）"></a>元数据（方法区）</h4><p>各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是元数据的一部分，用于存放编译器生成的各种字面量和符号引用。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>并不是虚拟机运行时数据的一部分。JDK1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存的限制。也可能导致<code>OutOfMemoryError</code>出现。</p>
<p>JVM内存区域的详细介绍可以看这篇<a href="https://iisheng.cn/2019/10/22/java-memory-area/">深入理解JVM之Java内存区域</a></p>
<h4 id="Java-内存堆和栈区别？"><a href="#Java-内存堆和栈区别？" class="headerlink" title="Java 内存堆和栈区别？"></a>Java 内存堆和栈区别？</h4><ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 java.lang.StackOverFlowError 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 java.lang.OutOfMemoryError 错误。</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。-Xss 选项设置栈内存的大小，-Xms 选项可以设置堆的开始时的大小。<br>当然，如果你记不住这个些，只要记住如下即可：</li>
</ul>
<blockquote>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
</blockquote>
<h4 id="Java-对象创建过程？"><a href="#Java-对象创建过程？" class="headerlink" title="Java 对象创建过程？"></a>Java 对象创建过程？</h4><p>JAVA 对象创建的过程，如下图所示：<br><img src="http://static2.iocoder.cn/images/JDK/2020_02_10/06.png" alt></p>
<h4 id="有哪些-OutOfMemoryError-异常？"><a href="#有哪些-OutOfMemoryError-异常？" class="headerlink" title="有哪些 OutOfMemoryError 异常？"></a>有哪些 OutOfMemoryError 异常？</h4><ul>
<li>Java 堆溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>元数据的内存溢出</li>
<li>运行时常量池溢出</li>
</ul>
<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><h4 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h4><h4 id="垃圾收集器有哪些？"><a href="#垃圾收集器有哪些？" class="headerlink" title="垃圾收集器有哪些？"></a>垃圾收集器有哪些？</h4><h4 id="判断对象死亡的2种常用方法？"><a href="#判断对象死亡的2种常用方法？" class="headerlink" title="判断对象死亡的2种常用方法？"></a>判断对象死亡的2种常用方法？</h4><h4 id="什么是新生代-GC-和老年代-GC？"><a href="#什么是新生代-GC-和老年代-GC？" class="headerlink" title="什么是新生代 GC 和老年代 GC？"></a>什么是新生代 GC 和老年代 GC？</h4><h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><h4 id="JDK-的命令行工具有哪些可以监控虚拟机？"><a href="#JDK-的命令行工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的命令行工具有哪些可以监控虚拟机？"></a>JDK 的命令行工具有哪些可以监控虚拟机？</h4><h4 id="JDK-的可视化工具有哪些可以监控虚拟机？"><a href="#JDK-的可视化工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的可视化工具有哪些可以监控虚拟机？"></a>JDK 的可视化工具有哪些可以监控虚拟机？</h4><h4 id="如何排查线程-Full-GC-频繁的问题？"><a href="#如何排查线程-Full-GC-频繁的问题？" class="headerlink" title="如何排查线程 Full GC 频繁的问题？"></a>如何排查线程 Full GC 频繁的问题？</h4><h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><h4 id="什么是类加载器？"><a href="#什么是类加载器？" class="headerlink" title="什么是类加载器？"></a>什么是类加载器？</h4><p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(.java 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(.class 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。</p>
<ul>
<li>每个这样的实例用来表示一个 Java 类。通过此实例的 Class#newInstance(…) 方法，就可以创建出该类的一个对象。</li>
<li>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</li>
</ul>
<h4 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h4><h4 id="什么是双亲委派模型（Parent-Delegation-Model）？"><a href="#什么是双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="什么是双亲委派模型（Parent Delegation Model）？"></a>什么是双亲委派模型（Parent Delegation Model）？</h4><h4 id="类的加载机制是什么？"><a href="#类的加载机制是什么？" class="headerlink" title="类的加载机制是什么？"></a>类的加载机制是什么？</h4>]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java并发</title>
    <url>/2019/10/18/interview-java-concurrency/</url>
    <content><![CDATA[<h4 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h4><p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li><p>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
</li>
<li><p>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h3><p>线程一共有五个状态，分别如下：</p>
<ul>
<li>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1 = new Thread() 。</li>
<li>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：t1.start() 。</li>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（#run() 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<ul>
<li>自然终止：正常运行完 #run()方法，终止。</li>
<li>异常终止：调用 #stop() 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>堵塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
<ul>
<li>正在睡眠：调用 <code>#sleep(long t)</code> 方法，可使线程进入睡眠方式。</li>
<li>正在等待：调用 <code>#wait()</code> 方法。调用 <code>notify()</code> 方法，回到就绪状态。</li>
<li>被另一个线程所阻塞：调用 <code>#suspend()</code> 方法。（调用 <code>#resume()</code> 方法，就可以恢复。）</li>
</ul>
</li>
</ul>
<p>整体如下图所示：</p>
<p><img src="http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c" alt></p>
<ul>
<li>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</li>
<li>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。</li>
</ul>
<h3 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h3><ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li>使用方式一<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 Thread#currentThread() 方法，直接使用 this 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li>使用方式二、或方式三<ul>
<li>优点：<ul>
<li>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li><strong>可以使用线程池。</strong></li>
</ul>
</li>
<li>缺点：<ul>
<li>编程稍微复杂，如果要访问当前线程，则必须使用Thread#currentThread() 方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h3><h3 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h3><p><strong>1）sleep 方法</strong></p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有synchronized 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 synchronized)，一个线程优先级为MAX_PRIORITY ，另一个为 MIN_PRIORITY 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 #sleep(5000) 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p><strong>2）yield 方法</strong></p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p><strong>3）join 方法</strong></p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 中。B运行完后，A才会继续执行。示例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 t 完成为止。然而，如果它加入的线程 t 没有存活，则当前线程不需要停止。</li>
</ul>
<h3 id="sleep-0-有什么用途？"><a href="#sleep-0-有什么用途？" class="headerlink" title="sleep(0) 有什么用途？"></a>sleep(0) 有什么用途？</h3><p><code>Thread#sleep(0)</code> 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 <code>Thread#sleep(0)</code> 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。<code>Thread#sleep(0)</code> 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个<strong>让位动作</strong></p>
<h3 id="你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？"><a href="#你如何确保-main-方法所在的线程是-Java-程序最后结束的线程？" class="headerlink" title="你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？"></a>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</h3><blockquote>
<p>考点，就是 join 方法。</p>
</blockquote>
<p>我们可以使用 Thread 类的 <code>#join()</code> 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h3 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h3><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<h3 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h3><p><strong>1）线程同步</strong><br>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：<br>事件<ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p><strong>2）线程互斥</strong><br>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<h3 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h3><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<h3 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a>synchronized 的原理是什么?</h3><h3 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h3><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<h3 id="什么是活锁？"><a href="#什么是活锁？" class="headerlink" title="什么是活锁？"></a>什么是活锁？</h3><p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败</p>
<h3 id="死锁和活锁的区别？"><a href="#死锁和活锁的区别？" class="headerlink" title="死锁和活锁的区别？"></a>死锁和活锁的区别？</h3><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，聪慧的胖友是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</li>
</ul>
<h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</li>
<li>在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</li>
</ul>
<h3 id="乐观锁的实现方式有哪些"><a href="#乐观锁的实现方式有哪些" class="headerlink" title="乐观锁的实现方式有哪些"></a>乐观锁的实现方式有哪些</h3><ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h3 id="什么是Java-Lock-接口？"><a href="#什么是Java-Lock-接口？" class="headerlink" title="什么是Java Lock 接口？"></a>什么是Java Lock 接口？</h3><h3 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h3><p>已经获取到锁的对象，再次申请获取锁，也可以申请成功，就是可重入锁。</p>
<h3 id="synchronized-和-ReentrantLock-异同？"><a href="#synchronized-和-ReentrantLock-异同？" class="headerlink" title="synchronized 和 ReentrantLock 异同？"></a>synchronized 和 ReentrantLock 异同？</h3><p>相同点：</p>
<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
<p>不同点：</p>
<ul>
<li>同步实现机制不同<ul>
<li>synchronized 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和 LockSupport（用于阻塞和解除阻塞）实现同步。</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li>synchronized 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 volatile state 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li>synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 finally 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li>synchronized 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li>synchronized 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 synchronized 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 synchronized 。</p>
</blockquote>
<blockquote>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。</p>
</blockquote>
<h3 id="ReadWriteLock-是什么"><a href="#ReadWriteLock-是什么" class="headerlink" title="ReadWriteLock 是什么"></a>ReadWriteLock 是什么</h3><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock 对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<h3 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h3><p><img src="http://static2.iocoder.cn/images/JDK/2020_02_07/01.png" alt></p>
<h3 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ol>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ol>
<p><strong>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</strong> </p>
<h3 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h3><h3 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h3><ul>
<li><p>SynchronizedMap</p>
<ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li><p>ConcurrentHashMap</p>
<ul>
<li><p>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</p>
</li>
<li><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h3><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<h3 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h3><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<blockquote>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
</blockquote>
<p><strong>1）普通线程池</strong></p>
<ul>
<li><code>#newFixedThreadPool(int nThreads)</code> 方法，创建一个固定长度的线程池。<ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
<li><code>#newCachedThreadPool()</code> 方法，创建一个可缓存的线程池。<ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
<li><code>#newSingleThreadExecutor()</code> 方法，创建一个单线程的线程池。<ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
<p><strong>2）定时任务线程池</strong></p>
<ul>
<li><code>#newScheduledThreadPool(int corePoolSize)</code> 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li><code>#newSingleThreadExecutor()</code> 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
<h3 id="ThreadPoolExecutor-有哪些拒绝策略？"><a href="#ThreadPoolExecutor-有哪些拒绝策略？" class="headerlink" title="ThreadPoolExecutor 有哪些拒绝策略？"></a>ThreadPoolExecutor 有哪些拒绝策略？</h3><p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy() ，直接抛出异常 RejectedExecutionException 。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy() ，直接调用 run 方法并且阻塞执行。</li>
<li>ThreadPoolExecutor.DiscardPolicy() ，直接丢弃后来的任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy() ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。</p>
<h3 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h3><p><strong>1）Callable</strong></p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<blockquote>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
</blockquote>
<p><strong>2）Future</strong></p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p><strong>3）FutureTask</strong></p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h3 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h3><h3 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<p>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程<br>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 </p>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Spring MVC</title>
    <url>/2019/10/17/interview-spring-mvc/</url>
    <content><![CDATA[<h3 id="Spring-MVC-各组件以及功能"><a href="#Spring-MVC-各组件以及功能" class="headerlink" title="Spring MVC 各组件以及功能"></a>Spring MVC 各组件以及功能</h3><ul>
<li>MultipartResolver：内容类型( Content-Type )为 <code>multipart/*</code> 的请求的解析器接口</li>
<li>LocaleResolver：本地化( 国际化 )解析器接口</li>
<li>ThemeResolver：主题解析器接口(例如，从请求头 User-Agent ，判断使用 PC 端，还是移动端的主题)</li>
<li>HandlerMapping：处理器匹配接口，根据请求( handler )获得其的处理器( handler )和拦截器们( HandlerInterceptor 数组 )</li>
<li>HandlerAdapter：处理器适配器接口</li>
<li>HandlerExceptionResolver：处理器异常解析器接口，将处理器( handler )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果</li>
<li>RequestToViewNameTranslator：请求到视图名的转换器接口</li>
<li>ViewResolver：实体解析器接口，根据视图名和国际化，获得最终的视图 View 对象</li>
<li>FlashMapManager：FlashMap 管理器接口，负责重定向时，保存参数到临时存储中</li>
</ul>
<a id="more"></a>
<h3 id="DispatcherServlet-的工作流程"><a href="#DispatcherServlet-的工作流程" class="headerlink" title="DispatcherServlet 的工作流程"></a>DispatcherServlet 的工作流程</h3><ol>
<li>发送请求：用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器 DispatcherServlet 捕获。</li>
<li>映射处理器：DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以 HandlerExecutionChain 对象的形式返回。</li>
<li>处理器适配：DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 #preHandler(…) 方法）。Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象</li>
<li>解析视图：根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</li>
<li>渲染视图 + 响应请求</li>
</ol>
<h3 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h3><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中加载配置文件，完成初始化 Spring MVC 组件的工作。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<h4 id="Spring-MVC-运行流程图"><a href="#Spring-MVC-运行流程图" class="headerlink" title="Spring MVC 运行流程图"></a>Spring MVC 运行流程图</h4><p><img src="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png" alt></p>
<h3 id="Spring-MVC拦截器"><a href="#Spring-MVC拦截器" class="headerlink" title="Spring MVC拦截器"></a>Spring MVC拦截器</h3><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandlerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并且，只有该处理器 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一共有三个方法，分别为：<ul>
<li><code>#preHandle(...)</code> 方法，调用 Controller 方法之前执行。</li>
<li><code>#postHandle(...)</code> 方法，调用 Controller 方法之后执行。</li>
<li><code>#afterCompletion(...)</code> 方法，处理完 Controller 方法返回结果之后执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>如何充分利用你的24小时</title>
    <url>/2019/10/09/time-mgt/</url>
    <content><![CDATA[<p><strong>如果你对 “如何充分利用你的24小时”感兴趣，我推荐你读《时间管理 如何充分利用你的24小时》漫画版。</strong></p>
<p>以下是我个人从书中学到的以及一些自己的体会。</p>
<h3 id="意识到自己的时间花费在什么地方"><a href="#意识到自己的时间花费在什么地方" class="headerlink" title="意识到自己的时间花费在什么地方"></a>意识到自己的时间花费在什么地方</h3><p>每天睡觉之前的时间，可以总结一下当天都做什么事情，分别花费了多少时间。画一个如下类似的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间段</th>
<th style="text-align:center">内容</th>
<th style="text-align:center">时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">02:30-12:00</td>
<td style="text-align:center">睡觉</td>
<td style="text-align:center">9.5小时</td>
</tr>
<tr>
<td style="text-align:center">14:00-20:00</td>
<td style="text-align:center">打王者荣耀</td>
<td style="text-align:center">6小时</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">19:00-22:00</td>
<td style="text-align:center">看电视剧</td>
<td style="text-align:center">5小时</td>
</tr>
<tr>
<td style="text-align:center">23:00-24:00</td>
<td style="text-align:center">定外卖吃饭</td>
<td style="text-align:center">3小时</td>
</tr>
</tbody>
</table>
<p>这样可以清晰看到自己在某件事情上花费的时间，可以根据自己的情况在计划表中减少或者增加。</p>
<a id="more"></a>
<h3 id="确定自己的目标"><a href="#确定自己的目标" class="headerlink" title="确定自己的目标"></a>确定自己的目标</h3><p>找自己喜欢的方式给自己制定明确的计划表，比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01:00-08:00</td>
<td style="text-align:center">睡觉</td>
</tr>
<tr>
<td style="text-align:center">08:30-09:00</td>
<td style="text-align:center">吃早餐</td>
</tr>
<tr>
<td style="text-align:center">09:00-12:00</td>
<td style="text-align:center">学习数据结构</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">23:00-24:00</td>
<td style="text-align:center">洗澡、做当天总结、做第二天计划</td>
</tr>
</tbody>
</table>
<p>对比自己的计划表和实际花费的时间表，总结自己的行为，改进自己的时间管理。</p>
<h3 id="选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情"><a href="#选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情" class="headerlink" title="选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情"></a>选择对自己目标有帮助的事情去做，放弃那些影响自己达成目标的事情</h3><h4 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h4><ul>
<li>闹钟响起，立即下床</li>
<li>上午时间，学习数据结构与算法相关</li>
<li>规律、健康的饮食和运动</li>
<li>快速做抉择</li>
<li>快速阅读</li>
<li>利用碎片时间，地铁上、等外卖、排队的时候，可以看公众号、极客时间<br>、知识星球</li>
<li>不拖延，按照计划表去做。大任务，分解成小任务，放到计划表中。</li>
<li>拒绝杂乱无章，物应各有其所，亦应各在其所</li>
<li>每周对自己的时间花费行为进行总结，每月也要总结，已经制定下月计划</li>
</ul>
<h4 id="时间管理技巧"><a href="#时间管理技巧" class="headerlink" title="时间管理技巧"></a>时间管理技巧</h4><ul>
<li>利用好碎片时间</li>
<li>做事前花特定时间思考，思考时间过后开始行动</li>
<li>做事专注</li>
<li>做事不半途而废，做完之后，不再打开</li>
<li>注意在重要的事情上多花费时间</li>
<li>注意优先顺序，在精力充沛的时间，做当天最困难的事情</li>
<li>保似水之心</li>
<li>拒绝杂乱无章</li>
<li>总结、制定计划</li>
<li>规律、健康的饮食和运动</li>
</ul>
]]></content>
      <categories>
        <category>😮心得体会</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java集合</title>
    <url>/2019/10/02/interview-java-collection/</url>
    <content><![CDATA[<h3 id="Java集合框架都有哪些？"><a href="#Java集合框架都有哪些？" class="headerlink" title="Java集合框架都有哪些？"></a>Java集合框架都有哪些？</h3><h4 id="实现Collection接口的，存放特定元素的集合的对象"><a href="#实现Collection接口的，存放特定元素的集合的对象" class="headerlink" title="实现Collection接口的，存放特定元素的集合的对象"></a>实现<code>Collection</code>接口的，存放特定元素的集合的对象</h4><p><img src="https://static001.geekbang.org/resource/image/67/c7/675536edf1563b11ab7ead0def1215c7.png" alt></p>
<a id="more"></a>
<h4 id="实现Map接口的，将键映射到值的对象"><a href="#实现Map接口的，将键映射到值的对象" class="headerlink" title="实现Map接口的，将键映射到值的对象"></a>实现<code>Map</code>接口的，将键映射到值的对象</h4><p><img src="https://static001.geekbang.org/resource/image/26/7c/266cfaab2573c9777b1157816784727c.png" alt></p>
<h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。（）</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li>HashMap：HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
</ul>
<p>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</p>
<ul>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ul>
<h4 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h4><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。可以用下标遍历或者迭代器遍历。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。只能用迭代器遍历。</li>
</ul>
<h4 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h5 id="适用场景分析："><a href="#适用场景分析：" class="headerlink" title="适用场景分析："></a>适用场景分析：</h5><ul>
<li>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</li>
<li>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</li>
</ul>
<h4 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h4><p>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。</p>
<h4 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h4><ul>
<li>HashSet底层用HashMap实现的</li>
<li>TreeSet底层用TreeMap实现的</li>
</ul>
<h4 id="HashMap-和-TreeMap-的区别？"><a href="#HashMap-和-TreeMap-的区别？" class="headerlink" title="HashMap 和 TreeMap 的区别？"></a>HashMap 和 TreeMap 的区别？</h4><ul>
<li>HashMap底层实现是数组+链表或者红黑树，TreeMap底层实现是红黑树</li>
<li>Map 中插入、删除和定位元素这类操作，HashMap 比较适合</li>
<li>假如你需要对一个有序的 key 集合进行遍历， TreeMap 更适合。</li>
</ul>
<h4 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h4><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。</p>
<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个<strong>链表散列</strong>。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<p><img src="http://dl2.iteye.com/upload/attachment/0017/7479/3f05dd61-955e-3eb2-bf8e-31da8a361148.jpg" alt></p>
<h4 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h4><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 % 取余的操作来实现。但是，重点来了：</p>
<ul>
<li>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 <code>hash % length == hash &amp; (length - 1)</code> 的前提是 length 是 2 的 n 次方；）。</li>
<li>并且，采用二进制位操作 &amp;，相对于 % 能够提高运算效率，<br>这就解释了 HashMap 的长度为什么是 2 的幂次方。</li>
</ul>
<h3 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h3><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 <code>#remove(Object Obj)</code> 方法删除，可以通过迭代器的 <code>#remove()</code> 方法删除。</p>
<h4 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h4><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h4 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h4><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 <code>java.util</code> 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 <code>ConcurrentModification</code> 异常。在 <code>java.util.concurrent</code> 包下的全是安全失败的。</li>
</ul>
<h4 id="如何删除-List-中的某个元素？"><a href="#如何删除-List-中的某个元素？" class="headerlink" title="如何删除 List 中的某个元素？"></a>如何删除 List 中的某个元素？</h4><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h3><ul>
<li>Comparable 接口，<code>在 java.lang</code> 包下，用于当前对象和其它对象的比较，所以它有一个 <code>#compareTo(Object obj)</code> 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 <code>java.util</code> 包下，用于传入的两个对象的比较，所以它有一个 <code>#compare(Object obj1, Object obj2)</code> 方法用来排序，该方法有两个参数。</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备系列之Java基础</title>
    <url>/2019/09/24/interview-java-basic/</url>
    <content><![CDATA[<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向过程</strong>是分析出实现需求所需要的步骤，通过函数一步一步实现这些步骤，然后依次调用。<strong>将实现步骤化</strong>。</p>
<p><strong>面向对象</strong>是把整个需求按照特点、功能划分，将这些存在共性的部分封装成对象。创建对象不是为了完成某一个步骤，而是描述某个事物在解决问题中的行文。<strong>将实现行为化</strong>。</p>
<h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><ul>
<li>封装：隐藏对象内部的特性和行为。</li>
<li>继承：子类继承父类的特性和行为。</li>
<li>多态：不同类的对象，对同一消息，做出不同响应。</li>
<li>抽象：把一类事物共有的属性和行为提出来，形成一个模板。</li>
</ul>
<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul>
<li>重写 override<ul>
<li>方法名、参数、返回值相同</li>
<li>方法被定义为final 不能被重写</li>
<li>存在于父类和子类之间</li>
</ul>
</li>
<li>重载 overload<ul>
<li>参数类型、个数、顺序至少有一个不同</li>
<li>不能重载只有返回值不同的方法名</li>
<li>存在于父类和子类、同类中</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h4><blockquote>
<p>衍生问题，Java 是编译执行的语言，还是解释执行的语言。</p>
</blockquote>
<ul>
<li>编译型语言：在被执行之前需要一个专门的编译过程，把程序编译为机器语言的文件，比如windows下的exe文件。下次不需要再编译，可以直接在机器上运行。效率比较高。编译型语言有C、C++等。</li>
<li>解释型语言：不需要编译。在运行时翻译成机器识别的机器语言。每次执行都需要一次翻译的过程。效率比较低。解释型语言有C#、Python等。</li>
</ul>
<p>Java中引入虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机转化为特定系统的机器码执行。在Java中这种虚拟机理解的代码叫做<strong>字节码（即扩展名为.class的文件）</strong>，它不面向任何的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的。但是实现的虚拟机是相同的。Java源程序经过编译器编译后编程字节码，字节码由虚拟机解释器执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就解释了Java的编译与解释并存的特点。</strong></p>
<h3 id="什么是自动拆装箱"><a href="#什么是自动拆装箱" class="headerlink" title="什么是自动拆装箱"></a>什么是自动拆装箱</h3><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<ul>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
</ul>
<h3 id="对Object-对象中-hashCode-和-equals-方法的理解"><a href="#对Object-对象中-hashCode-和-equals-方法的理解" class="headerlink" title="对Object 对象中 hashCode 和 equals 方法的理解"></a>对Object 对象中 hashCode 和 equals 方法的理解</h3><ul>
<li>equals 方法，用于比较对象的内容是否相等。当子类覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</li>
<li>hashCode 方法，大多在集合中用到。如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<p>hashCode 方法的重写，可以看看 <a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">《科普：为什么 String hashCode 方法选择数字31作为乘子》</a>方法。</p>
<h3 id="讲讲类的实例化顺序"><a href="#讲讲类的实例化顺序" class="headerlink" title="讲讲类的实例化顺序"></a>讲讲类的实例化顺序</h3><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<h3 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h3><p>Java IO 相关的类在<code>java.io</code>包下，具体操作分成面向字节（Byte）和面向字符（Character）两种方式，如下图所示。</p>
<p><img src="/images/java-io.png" alt></p>
<h4 id="Java提供了哪些IO方式？-NIO如何实现多路复用？"><a href="#Java提供了哪些IO方式？-NIO如何实现多路复用？" class="headerlink" title="Java提供了哪些IO方式？ NIO如何实现多路复用？"></a>Java提供了哪些IO方式？ NIO如何实现多路复用？</h4><p>首先，传统的 <code>java.io</code> 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p><code>java.io</code> 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 <code>java.net</code> 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java  1.4 中引入了 NIO 框架（<code>java.nio</code> 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<h3 id="Error和Exception区别"><a href="#Error和Exception区别" class="headerlink" title="Error和Exception区别"></a>Error和Exception区别</h3><ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/ac/00/accba531a365e6ae39614ebfa3273900.png" alt></p>
<h3 id="反射的用途以及实现"><a href="#反射的用途以及实现" class="headerlink" title="反射的用途以及实现"></a>反射的用途以及实现</h3><p>反射主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象</li>
<li>调用类的成员变量和方法</li>
<li>生成动态代理</li>
</ul>
<h4 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h4><p>动态代理是设计模式中代理模式的一个分类。代理模式分为静态代理和动态代理。</p>
<p>详细介绍你可以看这篇<a href="https://iisheng.cn/2019/08/14/proxy-pattern/">设计模式之代理模式</a></p>
<h3 id="Java对象创建的方式"><a href="#Java对象创建的方式" class="headerlink" title="Java对象创建的方式"></a>Java对象创建的方式</h3><ol>
<li>使用<code>new</code>关键字创建对象</li>
<li>使用<code>Class</code>类的<code>newIntance</code>方法（反射机制）</li>
<li>使用 <code>Constructor</code> 类的 <code>newInstance</code> 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
<h3 id="强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？"><a href="#强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？"></a>强引用、软引用、弱引用、虚引用（幻象引用）有什么区别？</h3><p>不同的引用类型，主要提现的是对象不同的可达性（reachable）状态和对垃圾收集的影响。</p>
<ul>
<li><p>强引用（Strong Reference）<br>是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将对应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li><p>软引用（Sort Reference）<br>是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集。只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>弱引用（Weak Reference）<br>并不能使对象豁免垃圾收集，仅仅是提供一种在弱引用状态下对象的访问途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重新实例化。它同样是很多缓存实现的选择。</p>
</li>
<li><p>虚引用，也叫幻象引用<br>你不能通过它访问对象。虚引用仅仅是提供一种确保对象被finalize以后，做某些事情的机智，比如，通常用来做所谓的Post-Mortem清理机智，也有人利用虚引用监控对象的创建和销毁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>😜面试系列</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之贪心算法</title>
    <url>/2019/09/17/greedy/</url>
    <content><![CDATA[<h3 id="贪心算法思想"><a href="#贪心算法思想" class="headerlink" title="贪心算法思想"></a>贪心算法思想</h3><p><strong>贪心算法</strong>就是这样的算法，它在每一步都做出当时看起来最佳的选择。也就是说<strong>它总是做出局部最优的选择，寄希望这样的选择导致全局最优解。</strong></p>
<blockquote>
<p>贪心算法并不保证得到最优解，但很多问题确实可以求得最优解。</p>
</blockquote>
<h3 id="我们可以按如下步骤设计贪心算法："><a href="#我们可以按如下步骤设计贪心算法：" class="headerlink" title="我们可以按如下步骤设计贪心算法："></a>我们可以按如下步骤设计贪心算法：</h3><ol>
<li>将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。</li>
<li>证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。</li>
<li>证明做出选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。</li>
</ol>
<a id="more"></a>
<h3 id="贪心算法与动态规划的区别"><a href="#贪心算法与动态规划的区别" class="headerlink" title="贪心算法与动态规划的区别"></a>贪心算法与动态规划的区别</h3><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>一个正在抢劫商店的小偷，发现了n个商品，第i个商品价值v<sub>i</sub>美元，重w<sub>i</sub>磅，v<sub>i</sub>和w<sub>i</sub>都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳W磅重的商品，W是一个整数。他应该拿哪些商品？（我们称这个问题为0-1背包问题，因为对每个商品，小偷要么把他完整拿走，要么把他留下；他不能只拿走商品的一部分，或者把一个商品拿走多次。）</p>
<h4 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h4><p>设定与0-1背包问题一样的，但对每个商品，小偷可以拿走其一部分。你可以将0-1背包中的商品想象为金锭，而分数背包问题中的商品更像金砂。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>我们可以用<strong>贪心策略解决分数背包问题</strong>。我们首先计算每个商品的每磅价值v<sub>i</sub>/w<sub>i</sub>。遵循贪心策略，小偷首先尽量多的拿走每磅价值最高的商品。如果此商品已经全部拿走而背包未满，他继续尽量多的拿走每磅价值第二高的商品，依此类推，直到达到重量上限W。</p>
<p>对于分数背包问题，上述贪心策略首先拿走每磅价值最大的商品，是可以生成最优解的。该策略对0-1背包无效是因为小偷<strong>无法装满背包，空闲空间降低了方案的有效每磅价值</strong>。</p>
<p>在0-1背包问题中，当我们考虑是否将一个商品加入背包时，<strong>必须比较包含此商品的子问题的解与不包含它的子问题的解</strong>，然后才能做出选择。<strong>这会导致大量的重叠子问题–动态规划的标识</strong>。这种问题就适合用动态规划去做。</p>
<h4 id="分糖果问题"><a href="#分糖果问题" class="headerlink" title="分糖果问题"></a>分糖果问题</h4><p><a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">leetcode 135. Candy</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy2</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = candies[ratings.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = candies[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            candies[i] = Math.max(candies[i], temp);</span><br><span class="line">            result += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之动态规划</title>
    <url>/2019/09/10/dp/</url>
    <content><![CDATA[<h4 id="动态规划算法思想"><a href="#动态规划算法思想" class="headerlink" title="动态规划算法思想"></a>动态规划算法思想</h4><p>动态规划（dynamic programming）与分治方法相似，都是通过组合子问题的解来求解原问题（在这里，programming 指的是一种表格法）。分治法将问题划分为互不相交的子问题，再将他们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即<strong>不同的子问题具有公共的子问题</strong>（子问题的求解释递归进行的，将其划分为更小的子子问题）。在这种情况下，分治法会做许多不必要的工作，它会反复求解那些公共子问题。而动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子问题时都重新计算，避免了这种不必要的计算工作。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>动态规划方法通常用来求解<strong>最优化问题</strong>。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解（an optimal solution），而不是最优解（the optimal solution），因为可能有多个解都达到最优值。</p>
<a id="more"></a>
<h4 id="设计动态规划算法的步骤"><a href="#设计动态规划算法的步骤" class="headerlink" title="设计动态规划算法的步骤"></a>设计动态规划算法的步骤</h4><p>我们通常按如下4个步骤来设计一个动态规划算法：</p>
<ol>
<li>刻画一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
<li>利用计算出的信息构造一个最优解</li>
</ol>
<p>步骤1~3是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4.如果确实要做步骤4，有时就需要步骤3的过程中维护一些额外信息，以便用来构造一个最优解。</p>
<h4 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h4><p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">leetcode 583. Delete Operation for Two Strings</a></p>
<p>基本解法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> len1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二维数组可用 一位数组 + 临时一位数组 替换掉</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = word1.charAt(<span class="number">0</span>) == word2.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span> || word1.charAt(i) == word2.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[<span class="number">0</span>][j - <span class="number">1</span>] == <span class="number">1</span> || word1.charAt(<span class="number">0</span>) == word2.charAt(j)) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 此处赋值语句可优化</span></span><br><span class="line">                <span class="comment">// dp[i - 1][j - 1] + 1 &gt;=  Math.max(dp[i - 1][j], dp[i][j - 1])</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(dp[i]));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len1 - dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>] + len2 - dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>优化解法：</p>
<ul>
<li>借用临时数组temp，将二维dp数组降维</li>
<li>优化赋值判断逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistanceDpQuick</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">       <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用一维数组</span></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">           <span class="comment">// 借用临时数组temp，将二维dp数组降维</span></span><br><span class="line">           <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">               <span class="comment">// 优化基本解法的 赋值逻辑</span></span><br><span class="line">               <span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) &#123;</span><br><span class="line">                   temp[j + <span class="number">1</span>] = Math.max(temp[j + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   temp[j + <span class="number">1</span>] = Math.max(dp[j + <span class="number">1</span>], temp[j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           dp = temp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> len1 - dp[len2] + len2 - dp[len2];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h4><p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">leetcode 718. Maximum Length of Repeated Subarray</a></p>
<p>基本解法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length == <span class="number">0</span> || B.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; B.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] == B[i]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[<span class="number">0</span>][i] &gt; result) &#123;</span><br><span class="line">                    result = dp[<span class="number">0</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == B[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][<span class="number">0</span>] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) &#123;</span><br><span class="line">                    result = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(dp[i]));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>优化解法：使用倒序遍历的方式将一维数组降维<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLengthDpQuick</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l1 = A.length;</span><br><span class="line">       <span class="keyword">int</span> l2 = B.length;</span><br><span class="line">       <span class="keyword">if</span> (l1 == <span class="number">0</span> || l2 == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l2 + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = l2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                   dp[j + <span class="number">1</span>] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">if</span> (dp[j + <span class="number">1</span>] &gt; max) &#123;</span><br><span class="line">                       max = dp[j + <span class="number">1</span>];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   dp[j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结之分治算法</title>
    <url>/2019/09/03/divide-conquer/</url>
    <content><![CDATA[<h4 id="分治法思想"><a href="#分治法思想" class="headerlink" title="分治法思想"></a>分治法思想</h4><p>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
<h4 id="分治模式在每层递归时都有三个步骤："><a href="#分治模式在每层递归时都有三个步骤：" class="headerlink" title="分治模式在每层递归时都有三个步骤："></a>分治模式在每层递归时都有三个步骤：</h4><ul>
<li><strong>分解</strong>原问题为若干个子问题，这些子问题是原问题规模较小的实例。</li>
<li><strong>解决</strong>这些子问题，递归地求解各子问题。然而，若子问题规模足够小，则直接求解。</li>
<li><strong>合并</strong>这些子问题的解成原问题的解。</li>
</ul>
<h4 id="归并排序中的分治模式"><a href="#归并排序中的分治模式" class="headerlink" title="归并排序中的分治模式"></a>归并排序中的分治模式</h4><ol>
<li><strong>分解</strong>：分解待排序的n个元素的序列成各具n/2各元素的两个子序列。</li>
<li><strong>解决</strong>：使用归并排序递归地排序两个子序列。</li>
<li><strong>合并</strong>：合并两个已排序的子序列以产生已排序的答案。</li>
</ol>
<a id="more"></a>
<p>我们用代码实现一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写一个归并排序-</span></span><br><span class="line"><span class="comment"> * 归并排序遵循 归并模式</span></span><br><span class="line"><span class="comment"> * 分解：将n个元素的数组分解为2个 n/2个元素的数组</span></span><br><span class="line"><span class="comment"> * 解决：分别对2个子数组排序</span></span><br><span class="line"><span class="comment"> * 合并：合并2个已经排序的子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将两个数组 合并 [min, mid] [mid+1, max]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">        array[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"排序前数组"</span> + Arrays.toString(array));</span><br><span class="line">    mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"排序后数组"</span> + Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h4><p>当一个算法包含对其自身的递归调用时，我们往往可以用<strong>递归方程</strong>或<strong>递归式</strong>来描述其运行时间，该方程根据在较小上的运行时间来描述在规模为n的问题上的总运行时间。</p>
<h4 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h4><p>给一个数组，找出一个具有最大和的连续子数组，返回最大和。</p>
<p> <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode 53. Maximum Subarray</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路</span></span><br><span class="line"><span class="comment"> * 分解：将数组分为2个 子数组</span></span><br><span class="line"><span class="comment"> * 解决：两个子数组的 最大和 可以直接求得， 包含中间点 的 最大和 经过特殊计算一下</span></span><br><span class="line"><span class="comment"> * 合并：返回两个子数组 最大和 中 最大的一个 或者 返回 包含中间点 的最大和</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calcMaxSubarray(nums, <span class="number">0</span>, (nums.length - <span class="number">1</span>) / <span class="number">2</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算最大子数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcMaxSubarray</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left &gt;= right 跳出递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左面子数组 最大值</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = calcMaxSubarray(array, left, (left + mid) / <span class="number">2</span>, mid);</span><br><span class="line">    <span class="comment">// 右面子数组 最大值</span></span><br><span class="line">    <span class="keyword">int</span> rightMax = calcMaxSubarray(array, mid + <span class="number">1</span>, (mid + <span class="number">1</span> + right) / <span class="number">2</span>, right);</span><br><span class="line">    <span class="comment">// 包含中间点的 两个子数组 的最大值 初始值 设为 中点的值</span></span><br><span class="line">    <span class="keyword">int</span> midMax = array[mid], temp = midMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        temp += array[i];</span><br><span class="line">        midMax = Math.max(temp, midMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp = midMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        temp += array[i];</span><br><span class="line">        midMax = Math.max(temp, midMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(midMax, Math.max(leftMax, rightMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式</title>
    <url>/2019/08/16/factory-method-pattern/</url>
    <content><![CDATA[<h3 id="什么是工厂方法模式"><a href="#什么是工厂方法模式" class="headerlink" title="什么是工厂方法模式"></a>什么是工厂方法模式</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/factory-method-pattern.png" alt></p>
<a id="more"></a>
<h3 id="工厂方法模式简单代码实现"><a href="#工厂方法模式简单代码实现" class="headerlink" title="工厂方法模式简单代码实现"></a>工厂方法模式简单代码实现</h3><h4 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:36:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 产品类的公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:37:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象工厂类"><a href="#抽象工厂类" class="headerlink" title="抽象工厂类"></a>抽象工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:38:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具体工厂类"><a href="#具体工厂类" class="headerlink" title="具体工厂类"></a>具体工厂类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/21 21:40:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            product = (Product) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式</title>
    <url>/2019/08/14/proxy-pattern/</url>
    <content><![CDATA[<h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>代理模式（委托模式）就是：<strong>为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/proxy-pattern.png" alt></p>
<a id="more"></a>
<h3 id="代理模式简单代码实现"><a href="#代理模式简单代码实现" class="headerlink" title="代理模式简单代码实现"></a>代理模式简单代码实现</h3><p>代理主题接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:21:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的主题类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:21:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Real Subject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理主题类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(RealSubject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:23:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造一个真实的主题对象</span></span><br><span class="line">        RealSubject real = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过真实主题对象构造一个代理对象</span></span><br><span class="line">        ProxySubject proxy = <span class="keyword">new</span> ProxySubject(real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理的相关方法</span></span><br><span class="line">        proxy.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是动态代理"><a href="#什么是动态代理" class="headerlink" title="什么是动态代理"></a>什么是动态代理</h3><p>代理模式大致可以分为两大部分，一是静态代理，二是动态代理。</p>
<ul>
<li>静态代理：代理者的代码提前已经写好了，然后再对其进行编译。也就是说在代码运行前，class编译文件就已经存在。</li>
<li>与静态代理相反，代码执行前我们并不知道要代理谁，而是通过反射机制在运行时动态的生成代理者的对象。</li>
</ul>
<h3 id="Java中动态代理代码实现"><a href="#Java中动态代理代码实现" class="headerlink" title="Java中动态代理代码实现"></a>Java中动态代理代码实现</h3><p>实现InvocationHandler接口，重写invoke()方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:37:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(proxy, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java实现动态代理的代码"><a href="#Java实现动态代理的代码" class="headerlink" title="Java实现动态代理的代码"></a>Java实现动态代理的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/12 23:40:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造真实的对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个动态代理</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取真实对象的lassLoader</span></span><br><span class="line">        ClassLoader classLoader = realSubject.getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态构造一个 代理对象</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, dynamicProxy);</span><br><span class="line">        subject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之策略模式</title>
    <url>/2019/07/20/strategy-pattern/</url>
    <content><![CDATA[<h3 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h3><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以相互互换。</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="/images/strategy-pattern.png" alt></p>
<a id="more"></a>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><h4 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:09:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="策略具体实现1"><a href="#策略具体实现1" class="headerlink" title="策略具体实现1"></a>策略具体实现1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:09:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"策略1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/18 16:10:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnyThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/2019/07/05/queue/</url>
    <content><![CDATA[<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>队列（queue）</strong>是一种线性集合，其元素从一端进入，从另一端删除。队列元素是按照<strong>先进先出（First In First Out, FIFO）</strong>方式处理的。从队列删除元素的次序，与往队列放置元素的次序是一样的。</p>
<h3 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/30 23:11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列末端添加一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列前端删除一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列最前端的元素，但不移出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果队列为空返回true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列中元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回队列字符串表示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="用链表实现队列"><a href="#用链表实现队列" class="headerlink" title="用链表实现队列"></a>用链表实现队列</h3><p><code>LinearNode&lt;T&gt;</code>是链表一个节点的实现，<a href="https://github.com/iisheng/java-algorithm/blob/master/src/main/java/cn/iisheng/common/LinearNode.java" target="_blank" rel="noopener">点击查看源码</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.iisheng.common.LinearNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/31 08:07:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearNode&lt;T&gt; head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        LinearNode&lt;T&gt; node = <span class="keyword">new</span> LinearNode(element);</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.setNext(node);</span><br><span class="line">        &#125;</span><br><span class="line">        tail = node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T result = head.getElement();</span><br><span class="line">        head = head.getNext();</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.getElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用数组实现队列"><a href="#用数组实现队列" class="headerlink" title="用数组实现队列"></a>用数组实现队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/09/02 21:39:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">QueueADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, rear, count;</span><br><span class="line">    <span class="keyword">private</span> T[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        front = rear = count = <span class="number">0</span>;</span><br><span class="line">        queue = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == queue.length) &#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue[rear] = element;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % queue.length;</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T result = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % queue.length;</span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T[] larger = (T[]) <span class="keyword">new</span> Object[queue.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            larger[i] = queue[front];</span><br><span class="line">            front = (front + <span class="number">1</span>) % queue.length;</span><br><span class="line">        &#125;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = count;</span><br><span class="line">        queue = larger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层序遍历（level-order-travelsal）"><a href="#二叉树的层序遍历（level-order-travelsal）" class="headerlink" title="二叉树的层序遍历（level-order travelsal）"></a>二叉树的层序遍历（level-order travelsal）</h3><p>从根节点开始，访问每一层的所有节点，一次一层。</p>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode 102. Binary Tree Level Order Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; currentRes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 当前队列的大小就是上一层节点个数，依次出队</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode current = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                currentRes.add(current.val);</span><br><span class="line">                <span class="comment">// 左子树和右子树入队</span></span><br><span class="line">                <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(current.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(current.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(currentRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之栈</title>
    <url>/2019/06/24/stack/</url>
    <content><![CDATA[<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>栈</strong>是一种线性集合，栈的元素是按照后进先出(LIFO)(Last in, first out)的方法进行处理的，最后进入栈中的元素最先被移出。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:17:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回且不移除栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果栈里面没有元素返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈中元素的总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个代表当前栈的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="用数组实现栈"><a href="#用数组实现栈" class="headerlink" title="用数组实现栈"></a>用数组实现栈</h3><p>栈的数组实现可以通过4个假设来设计：</p>
<ul>
<li>该数组是一个对象引用的数组（其数据类型在栈实例化的时候确定）</li>
<li>栈底总是在数组的索引0处</li>
<li>栈的元素是按照顺序并连续地存储在数组中</li>
<li>有一个整数变量top，该变量保存了紧跟栈顶元素后的数组索引号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.iisheng.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:18:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素下一个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储栈元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T[] stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认容量创建一个空栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        stack = (T[]) (<span class="keyword">new</span> Object[DEFAULT_CAPACITY]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用指定容量创建一个空栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        stack = (T[]) (<span class="keyword">new</span> Object[initialCapacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     * 确保 该数组不是满的</span></span><br><span class="line"><span class="comment">     * 把数组的top引用设置为要加入到栈中的对象</span></span><br><span class="line"><span class="comment">     * 增加top的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == stack.length) &#123;</span><br><span class="line">            expandCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        stack[top] = element;</span><br><span class="line">        top++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = Arrays.copyOf(stack, stack.length * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回栈顶元素</span></span><br><span class="line"><span class="comment">     * 确保 栈不为空</span></span><br><span class="line"><span class="comment">     * 减小top计数器</span></span><br><span class="line"><span class="comment">     * 设置一个临时引用等于stack[top]的元素</span></span><br><span class="line"><span class="comment">     * 设置stack[top]为空</span></span><br><span class="line"><span class="comment">     * 返回该临时引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">        T result = stack[top];</span><br><span class="line">        stack[top] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回且不移除栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果栈为空返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回代表栈的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用链表实现栈"><a href="#用链表实现栈" class="headerlink" title="用链表实现栈"></a>用链表实现栈</h3><p><code>LinearNode&lt;T&gt;</code>是链表一个节点的实现，<a href="https://github.com/iisheng/java-algorithm/blob/master/src/main/java/cn/iisheng/common/LinearNode.java" target="_blank" rel="noopener">点击查看源码</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.iisheng.common.LinearNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/07/29 23:32:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">StackADT</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在栈中存储元素的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向栈顶的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinearNode&lt;T&gt; top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        top = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T element)</span> </span>&#123;</span><br><span class="line">        LinearNode&lt;T&gt; temp = <span class="keyword">new</span> LinearNode&lt;&gt;(element);</span><br><span class="line"></span><br><span class="line">        temp.setNext(top);</span><br><span class="line">        top = temp;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T result = top.getElement();</span><br><span class="line">        top = top.getNext();</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.getElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈来计算后缀表达式"><a href="#使用栈来计算后缀表达式" class="headerlink" title="使用栈来计算后缀表达式"></a>使用栈来计算后缀表达式</h3><p><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">leetcode 224. Basic Calculator</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> operand = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// For the on-going result</span></span><br><span class="line">       <span class="keyword">int</span> sign = <span class="number">1</span>;  <span class="comment">// 1 means positive, -1 means negative</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Forming operand, since it could be more than one digit</span></span><br><span class="line">               operand = <span class="number">10</span> * operand + (<span class="keyword">int</span>) (ch - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Evaluate the expression to the left,</span></span><br><span class="line">               <span class="comment">// with result, sign, operand</span></span><br><span class="line">               result += sign * operand;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Save the recently encountered '+' sign</span></span><br><span class="line">               sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset operand</span></span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'-'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               result += sign * operand;</span><br><span class="line">               sign = -<span class="number">1</span>;</span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Push the result and sign on to the stack, for later</span></span><br><span class="line">               <span class="comment">// We push the result first, then sign</span></span><br><span class="line">               stack.push(result);</span><br><span class="line">               stack.push(sign);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset operand and result, as if new evaluation begins for the new sub-expression</span></span><br><span class="line">               sign = <span class="number">1</span>;</span><br><span class="line">               result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Evaluate the expression to the left</span></span><br><span class="line">               <span class="comment">// with result, sign and operand</span></span><br><span class="line">               result += sign * operand;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// ')' marks end of expression within a set of parenthesis</span></span><br><span class="line">               <span class="comment">// Its result is multiplied with sign on top of stack</span></span><br><span class="line">               <span class="comment">// as stack.pop() is the sign before the parenthesis</span></span><br><span class="line">               result *= stack.pop();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Then add to the next operand on the top.</span></span><br><span class="line">               <span class="comment">// as stack.pop() is the result calculated before this parenthesis</span></span><br><span class="line">               <span class="comment">// (operand on stack) + (sign on stack * (result from parenthesis))</span></span><br><span class="line">               result += stack.pop();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Reset the operand</span></span><br><span class="line">               operand = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result + (sign * operand);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈来遍历树"><a href="#使用栈来遍历树" class="headerlink" title="使用栈来遍历树"></a>使用栈来遍历树</h3><h4 id="二叉树的前序遍历（preorder-travelsal）"><a href="#二叉树的前序遍历（preorder-travelsal）" class="headerlink" title="二叉树的前序遍历（preorder travelsal）"></a>二叉树的前序遍历（preorder travelsal）</h4><p>从根节点开始，访问每一个节点及其孩子。（根 -&gt; 左 -&gt; 右）</p>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">leetcode 144. Binary Tree Preorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">       <span class="comment">// 根节点 最先入栈</span></span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           root = stack.pop();</span><br><span class="line">           <span class="comment">// 遍历 根节点</span></span><br><span class="line">           result.add(root.val);</span><br><span class="line">           <span class="comment">// 右节点先入栈 后遍历</span></span><br><span class="line">           <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 左节点后入栈 先遍历</span></span><br><span class="line">           <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">               stack.push(root.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的中序遍历（inorder-travelsal）"><a href="#二叉树的中序遍历（inorder-travelsal）" class="headerlink" title="二叉树的中序遍历（inorder travelsal）"></a>二叉树的中序遍历（inorder travelsal）</h4><p>从根节点开始，访问节点的左孩子，然后是该节点，再然后是任何剩余节点。（左 -&gt; 根 -&gt; 右）</p>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">leetcode 94. Binary Tree Inorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversalWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 根先进 左孩子后进 左孩子先出 根后出</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            <span class="comment">// 根 出  右孩子 进</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉树的后序遍历（inorder-travelsal）"><a href="#二叉树的后序遍历（inorder-travelsal）" class="headerlink" title="二叉树的后序遍历（inorder travelsal）"></a>二叉树的后序遍历（inorder travelsal）</h4><p>从根节点开始，访问节点的孩子，然后是该节点。（左 -&gt; 右 -&gt; 根）</p>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">leetcode 145. Binary Tree Postorder Traversal</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversalWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">      <span class="comment">// 根先进</span></span><br><span class="line">      stack.push(root);</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">          root = stack.pop();</span><br><span class="line">          <span class="comment">// 插在list第0位</span></span><br><span class="line">          result.add(<span class="number">0</span>, root.val);</span><br><span class="line">          <span class="comment">// 左孩子 先进 后出 最后插在 第0位</span></span><br><span class="line">          <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(root.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 右孩子 后进 先出 先插在第0位</span></span><br><span class="line">          <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">              stack.push(root.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用栈计算直方图最大面积"><a href="#使用栈计算直方图最大面积" class="headerlink" title="使用栈计算直方图最大面积"></a>使用栈计算直方图最大面积</h3><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">leetcode 84. Largest Rectangle in Histogram</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> maxArea = <span class="number">0</span>, n = heights.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; heights[st.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">               <span class="keyword">int</span> area = heights[st.pop()] * (st.isEmpty() ? i : i - st.peek() - <span class="number">1</span>);</span><br><span class="line">               maxArea = Math.max(maxArea, area);</span><br><span class="line">           &#125;</span><br><span class="line">           st.push(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> area = heights[st.pop()] * (st.isEmpty() ? n : n - st.peek() - <span class="number">1</span>);</span><br><span class="line">           maxArea = Math.max(maxArea, area);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😨数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式</title>
    <url>/2019/06/18/singleton-pattern/</url>
    <content><![CDATA[<h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p><img src="/images/singleton-pattern.png" alt></p>
<a id="more"></a>
<h3 id="普通单例模式代码"><a href="#普通单例模式代码" class="headerlink" title="普通单例模式代码"></a>普通单例模式代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    // 通过该方法获取实例对象</span></span><br><span class="line"><span class="comment">//    public static synchronized LazySingleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">//        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">//            singleton = new LazySingleton();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return singleton;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> iisheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/10/17 13:11:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程不安全的单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton singleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制产生多个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该方法获取实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>☺️设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法总结</title>
    <url>/2019/05/13/sort/</url>
    <content><![CDATA[<h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><p>临近的数字两两进行比较，按照从小到大或者从大到小的顺序交换，这样一趟后，最大或者最小的数字被交换到最后一位。<br>然后再从头开始两两进行比较交换，直到排序完成。</p>
<p>　　交换数组中两个元素的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap=arr[i];</span><br><span class="line">	arr[i]=arr[j];</span><br><span class="line">	arr[j]=swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>冒泡排序算法代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">		swap(arr, j + <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3><p>直接从待选择排序数组里面选择一个最小（或者最大）的数字，与第一个位置的数交换。<br>然后再在剩下的数中选择最小（或者最大）的数字，与第二个位置的数字交换，如此循环到只剩下一个数字为止。</p>
<p>选择排序代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> min = arr[i];</span><br><span class="line">		<span class="keyword">int</span> min_index = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">				min = arr[j];</span><br><span class="line">				min_index = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, min_index, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><p>　　每一步将一个待排序数据按其大小插入到已经排序的数组中的适当位置，直到全部插入完毕。<br>　　插入排序代码实现：<br>　　<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">			arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h3><p>选择一个基本元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，另一部分大于或等于基准元素。<br>这一趟扫描结束后，该基准就处于序列的中间位置。然后再用同样的方法递归的排序划分这两部分。</p>
<p>快速排序代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	recursion(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = partition(arr, low, high);</span><br><span class="line">		recursion(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">		recursion(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 基数 在数组 中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot)</span><br><span class="line">			--high;</span><br><span class="line">		arr[low] = arr[high];</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt; pivot)</span><br><span class="line">			++low;</span><br><span class="line">		arr[high] = arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[low] = pivot;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😒算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础知识</title>
    <url>/2019/04/29/redis/</url>
    <content><![CDATA[<h3 id="Redis基本数据类型"><a href="#Redis基本数据类型" class="headerlink" title="Redis基本数据类型"></a>Redis基本数据类型</h3><h4 id="Binary-safe-strings"><a href="#Binary-safe-strings" class="headerlink" title="Binary-safe strings"></a>Binary-safe strings</h4><p>string 类型是二进制安全的.意思是redis的string可以包含任意数据,比如jgp图片或者已经序列化的的对象.</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>实质是每一个都是string类型的双向链表,push和pop的命令算法的时间复杂度都是O(1),list还会记录链表的长度,所以llen操作也是O(1).</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>是string类型的无序集合.set是通过 hash table实现的,所以添加,查找,删除的复杂度都是O(1),hash table 会随着添加或者删除自动调整大小.</p>
<h4 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h4><p>sorted sets 也是string类型元素的集合,不同的是每个元素都会关联一个double类型的score,元素顺序有score决定.sorted sets的实现是skip list和hash table的混合体.</p>
<a id="more"></a>
<h4 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h4><p>是string类型的field和value的映射表.它的添加和删除都是O(1).hash特别适合用于存储对象</p>
<h4 id="Bit-arrays"><a href="#Bit-arrays" class="headerlink" title="Bit arrays"></a>Bit arrays</h4><p>可以用特殊的命令,处理string的value,像处理一个位数组一样</p>
<h4 id="HyperLogLogs"><a href="#HyperLogLogs" class="headerlink" title="HyperLogLogs"></a>HyperLogLogs</h4><p>它是一个概率数据库.(用于估算集合的基数)</p>
<h3 id="Redis-基本命令"><a href="#Redis-基本命令" class="headerlink" title="Redis 基本命令"></a>Redis 基本命令</h3><h4 id="操作string的命令"><a href="#操作string的命令" class="headerlink" title="操作string的命令"></a>操作string的命令</h4><ul>
<li>set key value</li>
<li>get key value</li>
<li>mset key1 value1 key2 value2</li>
<li><p>mget key1 key2</p>
</li>
<li><p>incr key 对值做加加,返回新的值(对不存在的key返回1,对非intkey会报错)</p>
</li>
<li>decr key 对值做减减,返回新的值(对不存在的key返回1,对非intkey会报错)</li>
<li>incrby key integer 加指定值(key不存在会认为,原来的value为0)</li>
<li>decrby key integer 减指定值(key不存在会认为,原来的value为0)</li>
<li>append key value 给指定key的字符串追加value</li>
<li>substr key start end 返回截取过的key的字符串值,注意并不修改key,下标从0开始,区间前闭后闭</li>
</ul>
<h4 id="操作list的命令"><a href="#操作list的命令" class="headerlink" title="操作list的命令"></a>操作list的命令</h4><ul>
<li>lpush key string 在key对应的头部添加字符串元素,返回1代表成功,返回0表示key存在且不是list类型</li>
<li>rpush key string 在key对应的尾部添加字符串元素,返回1代表成功</li>
<li>lpop key 从list的头部删除元素,并返回删除的元素,如果list不存在或为空返回nil,如果不是list返回错误</li>
<li>rpop key 同上,但是从尾部删除</li>
<li>llen key 返回key对应list的长度,key不存在返回0,如果key对应的不是list返回错误</li>
<li>lrange key start end 返回指定区间内的元素,下标从0开始,负值表示从后面计算,-1表示倒数第一个元素,key不存在返回空列表</li>
<li>ltrim key start end 截取list,保留指定区间内元素,成功返回1,key不存在返回错误</li>
<li>lset key index value 设置list中指定下标的元素值,成功返回1,key或者下标不存在返回错误</li>
<li>linsert key before value value2在值value前插入值value2</li>
</ul>
<h4 id="操作sets的命令"><a href="#操作sets的命令" class="headerlink" title="操作sets的命令"></a>操作sets的命令</h4><ul>
<li>saad key value 添加一个string元素到key对应的set集合,成功返回1,如果元素已经在元素中返回0,可以对应的set不存在返回错误</li>
<li>srem key value 从key对应set中移除给定元素,成功返回1,如果value在集合中不存在或者key不存在返回0,key对应的不是set类型返回错误</li>
<li>spop 删除并返回set中一个随机元素,如果set是空或者key不存在返回nil</li>
<li>srandommembe key 同 spop,但是不删除元素</li>
</ul>
<h4 id="操作sorted-sets的命令"><a href="#操作sorted-sets的命令" class="headerlink" title="操作sorted sets的命令"></a>操作sorted sets的命令</h4><ul>
<li>zadd key score member 添加元素到集合,当member已存在,更新score</li>
<li>zrem key member 删除指定元素,1表示成功,如果不成功返回0</li>
</ul>
<h4 id="操作hashes的命令"><a href="#操作hashes的命令" class="headerlink" title="操作hashes的命令"></a>操作hashes的命令</h4><ul>
<li>hset key field value 设置hash field 为指定值,如果key不存在则先创建</li>
<li>hget key field 获取指定hash的hash field</li>
</ul>
<h3 id="Redis高级特性"><a href="#Redis高级特性" class="headerlink" title="Redis高级特性"></a>Redis高级特性</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>设置redis密码,可以配置redis.conf也可以直接在redis-cli中设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config set requirepass ******</span><br></pre></td></tr></table></figure></p>
<p>查看redis是否设置密码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config get requirepass</span><br></pre></td></tr></table></figure></p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>Redis主从复制过程:</p>
<ul>
<li>slave和master建立连接,发送sync同步命令</li>
<li>master会启动一个后台线程,将数据库线程保存到文件中,同时master主线程会开始收集新的写命令缓存.</li>
<li>后台完成保存后,就将此文件发送给slave</li>
<li>slave将此文件保存到硬盘上</li>
</ul>
<h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><ul>
<li><p>redis对事务的支持比较简单,redis只能保证一个client发起的事务中的命令可以连续执行,而中间不会插入其他的client命令.当一个client在发出multi命令时,这个连接会进入一个事务的上下文,连续后续命令不会立即执行,而是先放到一个队列中,当执行exec命令时,redis会顺序执行队列中的所有命令.</p>
</li>
<li><p>redis在事务中发生错误不会回滚.</p>
</li>
</ul>
<h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>redis提供了一系列不同的持久化选项:</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照.</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存.</li>
</ul>
<h4 id="发布订阅消息"><a href="#发布订阅消息" class="headerlink" title="发布订阅消息"></a>发布订阅消息</h4><p>发布订阅（pub/sub）是一种消息通知模式，主要的目的是截除消息发布者和消息订阅者之间的耦合，Redis作为一个pub/sub的server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道（channel）.当发布者通过publish命令向redis server发送特定类型的信息时，订阅该信息类型的全部client都会收到此消息.</p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>Redis的虚拟内存与操作系统的虚拟内存不是一回事，但是思路和目的都是相同的.就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据.尤其是对于redis这样的内存数据库，内存总是不够用的.除了可以将数据分割到多个redis server外.另外能够提高数据库容量的办法就是使用虚拟内存把那些不经常访问的数据交换到磁盘上.</p>
<h3 id="Redis集成Spring-Boot"><a href="#Redis集成Spring-Boot" class="headerlink" title="Redis集成Spring Boot"></a>Redis集成Spring Boot</h3><p>pom文件添加redis依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- redis --&gt;  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>application.properties增加redis相关属性<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#redis  </span><br><span class="line">spring.redis.hostName=goodgoodstate.me</span><br><span class="line">spring.redis.port=<span class="number">6379</span>    </span><br><span class="line">spring.redis.password=xxx  </span><br><span class="line">spring.redis.pool.maxActive=<span class="number">8</span>    </span><br><span class="line">spring.redis.pool.maxWait=-<span class="number">1</span>    </span><br><span class="line">spring.redis.pool.maxIdle=<span class="number">8</span>    </span><br><span class="line">spring.redis.pool.minIdle=<span class="number">0</span>    </span><br><span class="line">spring.redis.timeout=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>配置类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value =&#123; StringRedisTemplate.class, RedisTemplate.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h3><p>设置Redis中String类型的键值对,600秒自动失效<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">"key"</span>, <span class="string">"value"</span>, <span class="number">600</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p>
<p>获取Redis中String类型的value<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String value = (String) redisTemplate.opsForValue().get(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取操作Hash对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashOperations&lt;String, String, String&gt; hashOperations = redisTemplate.opsForHash();</span><br></pre></td></tr></table></figure></p>
<p>put一个map对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashOperations.putAll(key, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure></p>
<p>获取一个hash里面的maspKey对应的值<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String value = hashOperations.get(<span class="string">"key"</span>, <span class="string">"mapKey"</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>😏中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 语句学习总结</title>
    <url>/2019/04/22/mysql/</url>
    <content><![CDATA[<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>修改MySQL登录设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf  在最后加一句  skip-grant-tables</span><br></pre></td></tr></table></figure></p>
<p>重启MySQL<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysql&gt;update mysql.user set authentication_string=password(<span class="string">"新密码"</span>);</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>（1）第一范式（每列都保持原子性)<br>（2）第二范式（非主属性不部分依赖于候选码）<br>（3）第三范式（非主属性不传递依赖于候选码）<br>（4）BC范式（任何属性不部分依赖与候选码，不传递依赖与候选码）</p>
<h3 id="创建表SQL"><a href="#创建表SQL" class="headerlink" title="创建表SQL"></a>创建表SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">        <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">        <span class="string">`age`</span> <span class="built_in">INT</span> ,</span><br><span class="line">        PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="更新表中数据SQL"><a href="#更新表中数据SQL" class="headerlink" title="更新表中数据SQL"></a>更新表中数据SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> user.name = <span class="string">"lisheng"</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询表中数据的SQL"><a href="#查询表中数据的SQL" class="headerlink" title="查询表中数据的SQL"></a>查询表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name , user.age <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<h3 id="插入表中数据的SQL"><a href="#插入表中数据的SQL" class="headerlink" title="插入表中数据的SQL"></a>插入表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span> ,<span class="keyword">name</span> ,age) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"lisheng"</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user.name ,good.name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">join</span> good <span class="keyword">on</span> user.id = good.user_id;</span><br></pre></td></tr></table></figure>
<h3 id="删除表中数据的SQL"><a href="#删除表中数据的SQL" class="headerlink" title="删除表中数据的SQL"></a>删除表中数据的SQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p dbname &gt; dbname.sql   <span class="comment">// 在/usr/local/mysql/bin目录执行</span></span><br></pre></td></tr></table></figure>
<h3 id="导入sql数据库"><a href="#导入sql数据库" class="headerlink" title="导入sql数据库"></a>导入sql数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source /home/abc/abc.sql;  // 登录到数据库内执行</span><br></pre></td></tr></table></figure>
<h3 id="查看数据库表的编码格式"><a href="#查看数据库表的编码格式" class="headerlink" title="查看数据库表的编码格式"></a>查看数据库表的编码格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">table</span>-<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>
<h3 id="设置字段默认值"><a href="#设置字段默认值" class="headerlink" title="设置字段默认值"></a>设置字段默认值</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ALTER</span>  <span class="keyword">COLUMN</span> <span class="keyword">name</span> <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="string">""</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字段"><a href="#修改表字段" class="headerlink" title="修改表字段"></a>修改表字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> address <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> city <span class="built_in">CHAR</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<h3 id="增加一个表的一个字段"><a href="#增加一个表的一个字段" class="headerlink" title="增加一个表的一个字段"></a>增加一个表的一个字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> wechat_auth <span class="keyword">ADD</span> user_id <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br></pre></td></tr></table></figure>
<h3 id="时间日期格式化"><a href="#时间日期格式化" class="headerlink" title="时间日期格式化"></a>时间日期格式化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  DATE_FORMAT(t1.create_time,'%Y-%c-%d %h:%i:%s') </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 创建索引</span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> tbl_name</span><br></pre></td></tr></table></figure>
<h3 id="导入cvs文件"><a href="#导入cvs文件" class="headerlink" title="导入cvs文件"></a>导入cvs文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> [<span class="keyword">TABLE</span>]；  </span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>   </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>   </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span>；</span><br></pre></td></tr></table></figure>
<h3 id="导出cvs文件"><a href="#导出cvs文件" class="headerlink" title="导出cvs文件"></a>导出cvs文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'[FILE]'</span>；  </span><br><span class="line">或者  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> [<span class="keyword">TABLE</span>]  </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'[FILE]'</span>  </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>   </span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span>   </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span>；</span><br></pre></td></tr></table></figure>
<h3 id="查询指定字段重复的记录"><a href="#查询指定字段重复的记录" class="headerlink" title="查询指定字段重复的记录"></a>查询指定字段重复的记录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> mobile <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(mobile)&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="当数据库中不存在该记录的时候插入"><a href="#当数据库中不存在该记录的时候插入" class="headerlink" title="当数据库中不存在该记录的时候插入"></a>当数据库中不存在该记录的时候插入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`table`</span> (value1, value2)</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="string">'stuff for value1'</span>,</span><br><span class="line">    <span class="string">'stuff for value2'</span></span><br><span class="line">  <span class="keyword">FROM</span> DUAL</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> *</span><br><span class="line">                   <span class="keyword">FROM</span> <span class="string">`table`</span></span><br><span class="line">                   <span class="keyword">WHERE</span> value1 = <span class="string">'stuff for value1'</span> <span class="keyword">AND</span> value2 = <span class="string">'stuff for value2'</span>)</span><br><span class="line">  <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>例子<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_test`</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="string">'isheng'</span></span><br><span class="line">  <span class="keyword">FROM</span> DUAL</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> *</span><br><span class="line">                   <span class="keyword">FROM</span> <span class="string">`t_test`</span></span><br><span class="line">                   <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'iisheng'</span>)</span><br><span class="line">  <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="给表中两个字段添加唯一性约束"><a href="#给表中两个字段添加唯一性约束" class="headerlink" title="给表中两个字段添加唯一性约束"></a>给表中两个字段添加唯一性约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> <span class="keyword">ADD</span> <span class="keyword">unique</span> <span class="keyword">unique</span>-<span class="keyword">name</span> (column1,column2);</span><br></pre></td></tr></table></figure>
<h3 id="删除唯一性约束"><a href="#删除唯一性约束" class="headerlink" title="删除唯一性约束"></a>删除唯一性约束</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP KEY 约束名;</span><br></pre></td></tr></table></figure>
<h3 id="inner-join-和left-join区别"><a href="#inner-join-和left-join区别" class="headerlink" title="inner join 和left join区别"></a>inner join 和left join区别</h3><p>left join (左连接) 返回包括左表中所有记录和右表中连接字段相等的记录<br><br>right join (右连接) 返回包括右表中所有记录和左表中连接字段相等的记录<br><br>inner join (等值连接) 只返回两个表中连接字段相等的记录</p>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><ol>
<li>查询 seeker_job  去掉 seeker_job_suggest  关联</li>
<li>优化模糊查询 改用单 like% reverse函数建立反向索引</li>
<li>范围模糊查询 自增id优于uuid  使用count(1)也是自增id更好</li>
<li>在适当的地方添加索引   （MySQL仅能对索引最左边的前缀进行有效的查找）</li>
<li>where语句后面的顺序 以及 建立 索引的顺序  （最左前缀匹配原则）</li>
<li>（尽量选择区分度高的列作为索引。）( = 和 in 可以乱序)</li>
<li>（尽量扩展索引，少去新建索引）</li>
<li>不以通配符开头的sql语句 like “%aaa” ALL 全表扫描 like “aaaa%” range 索引</li>
<li>尽量避免 null值判断 应该使用 0 默认值的 方法</li>
<li>避免 select * </li>
<li>order by语句后面跟索引   排序的顺序 很重要 很重要</li>
<li>提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉</li>
<li>能用DISTINCT的就不用GROUP BY</li>
</ol>
<h3 id="查看编码"><a href="#查看编码" class="headerlink" title="查看编码"></a>查看编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show variables like <span class="string">'%char%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看表编码"><a href="#查看表编码" class="headerlink" title="查看表编码"></a>查看表编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show create table &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">例：show create table user;</span><br></pre></td></tr></table></figure>
<h3 id="查看字段编码"><a href="#查看字段编码" class="headerlink" title="查看字段编码"></a>查看字段编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">show full columns from &lt;表名&gt;;</span><br><span class="line"></span><br><span class="line">例： show full column from user;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库编码格式"><a href="#修改数据库编码格式" class="headerlink" title="修改数据库编码格式"></a>修改数据库编码格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter database &lt;数据库名&gt; character set utf8mb4;</span><br><span class="line">例：alter database db_user character set utf8mb4;</span><br></pre></td></tr></table></figure>
<h3 id="修改表编码"><a href="#修改表编码" class="headerlink" title="修改表编码"></a>修改表编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table &lt;表名&gt; character set utf8mb4;</span><br><span class="line">例：alter table user character set utf8mb4;</span><br></pre></td></tr></table></figure>
<h3 id="修改字段编码"><a href="#修改字段编码" class="headerlink" title="修改字段编码"></a>修改字段编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; MODIFY COLUMN &lt;字段名&gt; &lt;字段类型&gt; CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line">例：<span class="function">ALTER TABLE comment MODIFY COLUMN content <span class="title">VARCHAR</span><span class="params">(<span class="number">512</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询sql不走缓存"><a href="#查询sql不走缓存" class="headerlink" title="查询sql不走缓存"></a>查询sql不走缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM users;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字符集和校对集"><a href="#修改表字符集和校对集" class="headerlink" title="修改表字符集和校对集"></a>修改表字符集和校对集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER  TABLE user</span><br><span class="line">CHARACTER SET utf8mb4</span><br><span class="line">COLLATE utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库字符集和校对集"><a href="#修改数据库字符集和校对集" class="headerlink" title="修改数据库字符集和校对集"></a>修改数据库字符集和校对集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE mydata</span><br><span class="line">CHARACTER SET utf8mb4</span><br><span class="line">COLLATE utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>
<h3 id="修改表字段相关信息"><a href="#修改表字段相关信息" class="headerlink" title="修改表字段相关信息"></a>修改表字段相关信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE `job_auth_record` CHANGE `id` `id` VARCHAR(<span class="number">32</span>) CHARACTER SET utf8mb4 NOT NULL COMMENT <span class="string">'主键id'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Mysql-ASC-和-DESC-索引-怎么走的-？？？"><a href="#Mysql-ASC-和-DESC-索引-怎么走的-？？？" class="headerlink" title="Mysql ASC 和 DESC 索引 怎么走的 ？？？"></a>Mysql ASC 和 DESC 索引 怎么走的 ？？？</h3><h3 id="分组差查询数量-超级吊"><a href="#分组差查询数量-超级吊" class="headerlink" title="分组差查询数量  超级吊"></a>分组差查询数量  超级吊</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  company_id,</span><br><span class="line">  count(*) AS counts</span><br><span class="line">FROM seeker_job</span><br><span class="line"><span class="function">WHERE company_id <span class="title">IN</span> <span class="params">(<span class="string">"8a9c889c5dcbe37c015dcf16e284001f"</span>, <span class="string">"04be17537c5e4b299c135eeaadb5e131"</span>)</span></span></span><br><span class="line"><span class="function">GROUP BY company_id</span>;</span><br></pre></td></tr></table></figure>
<h3 id="修改校验集"><a href="#修改校验集" class="headerlink" title="修改校验集"></a>修改校验集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE insurance_insured CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">ALTER  TABLE insurance_insured CHARACTER SET utf8mb4;</span><br><span class="line"></span><br><span class="line">ALTER TABLE `insurance_insured` CHANGE `name` `name`  varchar(<span class="number">64</span>) COLLATE utf8mb4_general_ci DEFAULT NULL;</span><br></pre></td></tr></table></figure>
<h3 id="忽略某个索引"><a href="#忽略某个索引" class="headerlink" title="忽略某个索引"></a>忽略某个索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * <span class="function">FROM seeker_job IGNORE <span class="title">INDEX</span><span class="params">(idx_modify_time)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="DISTINCT-COUNT"><a href="#DISTINCT-COUNT" class="headerlink" title="DISTINCT COUNT"></a>DISTINCT COUNT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT  <span class="title">count</span><span class="params">(DISTINCT j1.job_id,j1.agent_company_id)</span></span></span><br><span class="line"><span class="function">FROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id </span>= j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ;</span><br></pre></td></tr></table></figure>
<h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT  DISTINCT j1.job_id,j1.agent_company_id</span><br><span class="line">FROM job_agent j1 INNER JOIN job_agent j2 ON j1.job_id = j2.job_id AND j1.agent_company_id = j2.agent_company_id AND j1.id != j2.id ;</span><br></pre></td></tr></table></figure>
<h4 id="查找重复字段记录"><a href="#查找重复字段记录" class="headerlink" title="查找重复字段记录"></a>查找重复字段记录</h4><p><a href="https://www.cnblogs.com/jiangxiaobo/p/6589541.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxiaobo/p/6589541.html</a></p>
<h3 id="修改表编码个字符集"><a href="#修改表编码个字符集" class="headerlink" title="修改表编码个字符集"></a>修改表编码个字符集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ALTER  TABLE apply_stencil CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="function">ALTER TABLE apply_stencil MODIFY COLUMN id <span class="title">VARCHAR</span><span class="params">(<span class="number">32</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ALTER TABLE apply_stencil MODIFY COLUMN apply_id <span class="title">VARCHAR</span><span class="params">(<span class="number">32</span>)</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询一个库里面有多少表"><a href="#查询一个库里面有多少表" class="headerlink" title="查询一个库里面有多少表"></a>查询一个库里面有多少表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(*)</span> TABLES, table_schema FROM information_schema.TABLES  WHERE table_schema </span>= <span class="string">'goabroad'</span></span><br></pre></td></tr></table></figure>
<h3 id="时间相关格式化函数"><a href="#时间相关格式化函数" class="headerlink" title="时间相关格式化函数"></a>时间相关格式化函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create_time时间格式</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%u'</span>)</span> weeks,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY weeks</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%m%d'</span>)</span> days,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY days</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">DATE_FORMAT</span><span class="params">(create_time,<span class="string">'%Y%m'</span>)</span> months,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY months</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">create_time时间戳格式</span></span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%u'</span>)</span> weeks,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY weeks</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%m%d'</span>)</span> days,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY days</span>;</span><br><span class="line"><span class="function">SELECT <span class="title">FROM_UNIXTIME</span><span class="params">(create_time,<span class="string">'%Y%m'</span>)</span> months,<span class="title">COUNT</span><span class="params">(id)</span> COUNT FROM role GROUP BY months</span></span><br></pre></td></tr></table></figure>
<h3 id="回收表"><a href="#回收表" class="headerlink" title="回收表"></a>回收表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">alter table name engine=innodb</span><br></pre></td></tr></table></figure>
<h3 id="left-和-length-函数"><a href="#left-和-length-函数" class="headerlink" title="left() 和 length()函数"></a>left() 和 length()函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UPDATE seeker_job SET country_id = left(country_id,<span class="number">6</span>) <span class="function">WHERE <span class="title">length</span><span class="params">(country_id)</span> &gt; 6</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看mysql版本号"><a href="#查看mysql版本号" class="headerlink" title="查看mysql版本号"></a>查看mysql版本号</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">version</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😶数据库</category>
      </categories>
      <tags>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习</title>
    <url>/2019/04/15/vim/</url>
    <content><![CDATA[<h4 id="Vim学习笔记"><a href="#Vim学习笔记" class="headerlink" title="Vim学习笔记"></a>Vim学习笔记</h4><h4 id="Vim三种模式"><a href="#Vim三种模式" class="headerlink" title="Vim三种模式"></a>Vim三种模式</h4><p>基本上vi分为三种模式，分别是一般模式、编辑模式与命令行模式</p>
<h5 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h5><p>打开一个文件默认就进入到一般模式（这是默认的模式）。在这个模式中你可以使用上下左右了来移动光标，你可以删除字符或者删除整行，也可以复制粘贴你的文件数据。</p>
<h5 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h5><p>在vi一般模式下，不能进行编辑。等到按下a、s、i、o、c之后，就会进入编辑模式。左下方会出现INSERT或REPLAC的字样，此时才可以进行编辑。若想要退出编辑模式，需要按ESC。</p>
<h5 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h5><p>在一般模式中输入，“:、/、？”3个中的任何一个按钮，就可以将光标移动到最下面那一行。</p>
<a id="more"></a>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hjkl 左下上右</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctrl+f  pagedown 向下翻页</span><br><span class="line">ctrl+b  pageup 向上翻页</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>  home  移动到当前行最前</span><br><span class="line">n 空格  移动n个字符</span><br><span class="line">$  end  移动到当前行最后</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">G 移动到文件最末行</span><br><span class="line">nG 移动到第n行</span><br><span class="line">gg 首行</span><br><span class="line">n+enter  向下移动n行</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">:n1,n2s/word1/word2/g     在n1到n2之间找到word1，并将wor1替换为word2</span><br><span class="line">:<span class="number">1</span>,$s/word1/word2/g       在第一行到最后一行查找word1，并替换为word2</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x,X     x向前删除   X向后删除</span><br><span class="line">nx      n为数字     连续向后删除n个字符</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dd 删除光标所在的整行</span><br><span class="line">ndd 删除所在的向下的几行</span><br><span class="line">d1G 删除光标所在到第一行的所有数据</span><br><span class="line">dg  删除从光标所在到最后一行的所有数据</span><br><span class="line">d$  删除从光标所在处到该行的最后一个字符</span><br><span class="line">d0  删除从光标所在出到该行的最前面一个字符</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yy  复制光标所在的那一行</span><br><span class="line">nyy  复制光标所在的向下n行</span><br><span class="line">p,P   p将已复制的数据在光标下一行粘贴，P将已复制的数据在光标上一行粘贴</span><br><span class="line">y1G   复制光标所在行到第一行的所有数据</span><br><span class="line">yG   复制光标所在行到最后一行的所有数据</span><br><span class="line">y0   复制光标所在的那个字符到该行行首的所有数据</span><br><span class="line">y$   复制光标所在的那个字符到该行行尾的所有数据</span><br></pre></td></tr></table></figure>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">常规模式  /   进行搜索</span><br><span class="line">u撤销刚才得到动作</span><br><span class="line">ctrl+r是撤销刚才撤销的动作</span><br><span class="line">ctrl+u 删除当前行</span><br><span class="line">yy复制当前行</span><br><span class="line">dd删除当前行</span><br><span class="line">p粘贴</span><br><span class="line">u撤销</span><br><span class="line">查找 </span><br><span class="line">/pattern  往后查找</span><br><span class="line">?pattern  向前查找</span><br><span class="line">n下一个</span><br><span class="line">N上一个</span><br><span class="line">ggVG 全选 gg到起始行</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL工具学习</title>
    <url>/2019/04/08/curl/</url>
    <content><![CDATA[<h3 id="CURL是什么"><a href="#CURL是什么" class="headerlink" title="CURL是什么"></a>CURL是什么</h3><p>CURL (Command Line URL viewer)是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在“标准输出”（stdout）上面。</p>
<h4 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h4><p>直接在curl后面加上网址，就可以看到网页源码。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span><br><span class="line">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果要保存这个网页，可以使用 -o 参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -o fileName iisheng.cn</span><br></pre></td></tr></table></figure></p>
<h4 id="自动跳转"><a href="#自动跳转" class="headerlink" title="自动跳转"></a>自动跳转</h4><p>有的网页是自动跳转的。使用 -L 参数，curl就会跳转到新的网址。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -L iisheng.cn</span><br></pre></td></tr></table></figure></p>
<p>键入上面命令，就会直接跳转到<a href="https://iisheng.cn">https://iisheng.cn</a></p>
<h4 id="显示头信息"><a href="#显示头信息" class="headerlink" title="显示头信息"></a>显示头信息</h4><p>-i 参数可以显示http response 的头信息，连同网页代码一起。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -i iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line">Server: Tengine</span><br><span class="line">Date: Sat, <span class="number">13</span> Apr <span class="number">2019</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">26</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">278</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https:<span class="comment">//iisheng.cn/</span></span><br><span class="line">Via: kunlun8.cn314[,<span class="number">0</span>]</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: ca6cf99c15551457264052744e</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=<span class="string">"white"</span>&gt;</span><br><span class="line">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span><br><span class="line">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="显示通信过程"><a href="#显示通信过程" class="headerlink" title="显示通信过程"></a>显示通信过程</h4><p>-v 参数可以显一次http通信的整个过程，包括端口连接和http request 头信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -v iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Rebuilt URL to: iisheng.cn/</span><br><span class="line">*   Trying <span class="number">202.108</span>.249.197...</span><br><span class="line">* Connected to iisheng.cn (202.108.249.197) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: iisheng.cn</span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.47</span>.0</span><br><span class="line">&gt; Accept: *<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt; </span></span><br><span class="line"><span class="comment">&lt; HTTP/1.1 301 Moved Permanently</span></span><br><span class="line"><span class="comment">&lt; Server: Tengine</span></span><br><span class="line"><span class="comment">&lt; Date: Sat, 13 Apr 2019 08:57:09 GMT</span></span><br><span class="line"><span class="comment">&lt; Content-Type: text/html</span></span><br><span class="line"><span class="comment">&lt; Content-Length: 278</span></span><br><span class="line"><span class="comment">&lt; Connection: keep-alive</span></span><br><span class="line"><span class="comment">&lt; Location: https://iisheng.cn/</span></span><br><span class="line"><span class="comment">&lt; Via: kunlun8.cn314[,0]</span></span><br><span class="line"><span class="comment">&lt; Timing-Allow-Origin: *</span></span><br><span class="line"><span class="comment">&lt; EagleId: ca6cf99c15551458295975589e</span></span><br><span class="line"><span class="comment">&lt; </span></span><br><span class="line"><span class="comment">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span></span><br><span class="line"><span class="comment">&lt;html&gt;</span></span><br><span class="line"><span class="comment">&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">&lt;body bgcolor="white"&gt;</span></span><br><span class="line"><span class="comment">&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;hr/&gt;Powered by Tengine&lt;/body&gt;</span></span><br><span class="line"><span class="comment">&lt;/html&gt;</span></span><br><span class="line"><span class="comment">* Connection #0 to host iisheng.cn left intact</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上面的信息还不够，可以使用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --trace output.txt</span><br></pre></td></tr></table></figure></p>
<p>运行后，打开output.txt 查看</p>
<h4 id="发送表单信息"><a href="#发送表单信息" class="headerlink" title="发送表单信息"></a>发送表单信息</h4><p>GET请求<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure></p>
<p>POST请求<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST --data <span class="string">"data=xxx"</span> example.com/form.cgi</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h4><p>curl默认动词是GET，使用 -X 参数 可以支持其他参数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST iisheng.cn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT iisheng.cn</span><br></pre></td></tr></table></figure>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -T file.txt url</span><br></pre></td></tr></table></figure>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --referer http:<span class="comment">//www.example.com http://www.example.com</span></span><br></pre></td></tr></table></figure>
<h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User Agent"></a>User Agent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --user-agent <span class="string">"[User Agent]"</span> [URL]</span><br></pre></td></tr></table></figure>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --cookie <span class="string">"name=xxx"</span> www.example.com</span><br></pre></td></tr></table></figure>
<h3 id="增加头信息"><a href="#增加头信息" class="headerlink" title="增加头信息"></a>增加头信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl --header <span class="string">"Content-Type:application/json"</span> http:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title>RestFul API设计指南</title>
    <url>/2019/04/01/restful/</url>
    <content><![CDATA[<h3 id="RESTful是什么"><a href="#RESTful是什么" class="headerlink" title="RESTful是什么"></a>RESTful是什么</h3><p>REST（Representational State Transfe）是一种架构风格，遵循REST原则的架构我们就称为RESTful架构。Representational State Transfe 直译过来就是【表现层状态转化】，其实它省略了主语，表现层指的是【资源】的表现层，通俗的讲就是：资源在网络中以某种形式进行状态转移。</p>
<h3 id="为什么要用RESTful"><a href="#为什么要用RESTful" class="headerlink" title="为什么要用RESTful"></a>为什么要用RESTful</h3><p>RESTful 给人的感觉是优雅、规范、易懂，一个结构清晰、易于理解的API完全可以省略许多无意义的沟通和文档。大家都使用相同的标准，有利于团队的整体效率。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>一般接口就是增删改查，RESTful API就像通用的模板，我们以文章（Article）举例，那么基础的URL就有一下几种：</p>
<ul>
<li><code>GET /articles:</code> 文章列表</li>
<li><code>GET /articles/id:</code> 文章详情</li>
<li><code>POST /articles:</code> 创建文章</li>
<li><code>PUT /articles/id:</code> 修改文章</li>
<li><code>DELETE /articles/id:</code> 删除文章</li>
</ul>
<p>RESTful 中使用GET、POST、PUT和DELETE来分别表示资源的查询、创建、更新和删除，并且除了POST其他三种都具备幂等性（多次请求效果相同），POST和PUT最大的区别就是幂等性，所以PUT也可以用于创建，只要在创建前就确定好资源的id。</p>
<a id="more"></a>
<p>将id放到URL中而不是Query Param的其中一个好处是可以表示资源之间的层级关系，例如文章下面会有评论（Comment）和点赞（Like），这两项资源必然会属于一篇文章，所以它们的URL应该是这样的：</p>
<ul>
<li><code>GET /articles/aid/comments:</code> 某篇文章的评论列表</li>
<li><code>GET /comments/cid:</code> 获取某文章的某评论详情</li>
<li><code>POST /articles/aid/comments:</code> 在某篇文章中创建评论</li>
<li><code>PUT /comments/cid:</code> 修改评论</li>
<li><code>PUT /comments/cid:</code> 删除评论</li>
</ul>
<p>这里有一点比较特殊，永远去使用可以指向资源的最短URL路径，也就是说既然<code>/comments/cid:</code>已经可以指向一条评论了，就不需要<code>/articles/id/comments/cid:</code>特意的指出所属的文章了。</p>
<ul>
<li><code>GET /articles/id/like:</code> 查看文章是否被点赞</li>
<li><code>PUT /articles/id/like:</code> 点赞文章</li>
<li><code>DELETE /articles/id/like:</code> 取消点赞</li>
</ul>
<h3 id="接口版本"><a href="#接口版本" class="headerlink" title="接口版本"></a>接口版本</h3><p>随着业务的调整，可能老接口不能再满足业务需求。这个时候我们尽可能加字段，或者新加接口。例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">api.github.com/v1/users</span><br></pre></td></tr></table></figure></p>
<h3 id="Token和Sign"><a href="#Token和Sign" class="headerlink" title="Token和Sign"></a>Token和Sign</h3><p>API需要设计成无状态的，所以客户端在某些请求中需要带上token或者sign。</p>
<ul>
<li>Token 用于监听请求所属用户，一般都是服务端在登录后随机生成一段字符串（UUID）和登录用户进行绑定，再将其返回给客户端。Token的状态保持一般有两种方式实现：一种是在用户每次操作都会延长或者重置TOKEN生存时间（类似于缓存的机制），另一种是TOKEN的生存时长固定不变。</li>
<li>Sign 用于证明该次请求合理，所以一般客户端会把请求参数拼接后加密作为Sign传给服务端，这样即使被抓包了，对方修改参数而无法生成对应Sign也会被识破。</li>
</ul>
<h3 id="业务参数"><a href="#业务参数" class="headerlink" title="业务参数"></a>业务参数</h3><p>搜索<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?query=iisheng</span><br></pre></td></tr></table></figure></p>
<p>过滤<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?gender=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="统计参数"><a href="#统计参数" class="headerlink" title="统计参数"></a>统计参数</h3><p>这个一般可能的实现方案，是在行为接口后面添加参数像，业务参数一样，还有一种实现方案是单独写一个接口，只做统计用，我感觉这种方式更好一些。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?offset=<span class="number">10</span>&amp;limit=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/articles/?cursor=<span class="number">2015</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">15</span>:<span class="number">20</span>:<span class="number">30</span>&amp;limit=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/users/?page=<span class="number">2</span>&amp;pre_page=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h3><ol>
<li>Json比Xml可视化更好，也更省流量所以尽量使用Json。</li>
<li>创建和修改成功后需要返回该资源的全部信息。</li>
<li>返回数据不需要和客户端界面耦合。不要在API设计的时候就考虑少返回几个字段，少一次查询（比如用join）能带来多大性能提升。一定要以资源为单位，即使客户端一个页面需要展示多个资源，也不要在一个接口中全部返回。而是让客户端分别请求多个接口（也可以使用一个单独的服务（API网关），内部RPC调用基础服务，构造客户端需要的数据，返回给客户端，这样，客户端可以只调用少量接口）</li>
</ol>
]]></content>
      <categories>
        <category>🙄设计思想</category>
      </categories>
      <tags>
        <tag>RESTFul</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet源码解析</title>
    <url>/2019/03/25/servlet/</url>
    <content><![CDATA[<h3 id="一个简单的Servlet请求"><a href="#一个简单的Servlet请求" class="headerlink" title="一个简单的Servlet请求"></a>一个简单的Servlet请求</h3><ol>
<li>新建HelloController继承HttpServlet</li>
<li>在web.xml中，注册HelloController，或者使用@WebServlet注解注册HelloController</li>
<li>重写doGet()，doPost()或者其他doXxx()方法</li>
</ol>
<h3 id="Servlet请求参数"><a href="#Servlet请求参数" class="headerlink" title="Servlet请求参数"></a>Servlet请求参数</h3><p>HttpServletRequest和HttpServletResponse是doXxx()方法的默认参数。</p>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest代表浏览器发送给服务器的请求报文。该对象由web服务器创建（如Tomcat），最终作为参数传递到doXxx()或者其他方法中，我们可以在doXxx()方法中直接使用</p>
<ol>
<li><p>获取用户发送的请求参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getParmater(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取项目的名字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getContextPath();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>作为一个域对象，在不同的web资源之间共享数据。</li>
<li>请求和转发<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"target.html"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><p>HttpServletResponse代表服务器发送给浏览器的响应报文。该对象由web服务器创建（如Tomcat），最终将作为参数传递到doXxx()方法中，我们可以在doXxx()方法中直接使用。</p>
<ol>
<li><p>响应给浏览器一个网页或者Json数据等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter printWriter = response.getWriter();</span><br><span class="line">printWriter.writer(Hello Servlet~);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求的重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"target.html"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">转发</th>
<th style="text-align:right">重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求的次数</td>
<td style="text-align:center">1</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td>发生的位置</td>
<td style="text-align:center">服务器内部</td>
<td style="text-align:right">浏览器</td>
</tr>
<tr>
<td>浏览器地址</td>
<td style="text-align:center">不改变</td>
<td style="text-align:right">改变</td>
</tr>
</tbody>
</table>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>通过实现Filter接口，完成我们自定义的过滤器功能。过滤器有以下功能：</p>
<ol>
<li>HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest</li>
<li>根据需要检查HttpServletRequest，也可以修改HttpServletRequest的头和数据</li>
<li>在HttpservletResponse到达客户端之前，拦截HttpServletResponse</li>
<li>根据需要检查HttpServletResponse，也可以修改HttpServletReponse的头和数据</li>
</ol>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器可以监听客户端的请求，服务端的操作，通过监听自动激发一些操作。监听器主要有以下几种：</p>
<ol>
<li>ServletContextListener:对应所有用户</li>
<li>ServletSessionListener:对应于一个用户</li>
<li>ServletRequestListener:对应用一个请求<br>我们可以实现上面的接口，去完成监听事件。</li>
</ol>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ol>
<li>通过调用init()方法初始化Servlet实例</li>
<li>调用service()方法处理请求</li>
<li>调用相应的请求方式的方法比如post请求，调用doPost()方法</li>
<li>停止服务的时候，调用destroy()方法</li>
</ol>
<h3 id="HttpServlet类图关系"><a href="#HttpServlet类图关系" class="headerlink" title="HttpServlet类图关系"></a>HttpServlet类图关系</h3><p><img src="/images/servlet-class-diagram.png" alt="image"></p>
<h3 id="Servlet工作流程"><a href="#Servlet工作流程" class="headerlink" title="Servlet工作流程"></a>Servlet工作流程</h3><p><img src="/images/http-request-sequence-diagram.png" alt="image"></p>
<ol>
<li>浏览器发出Http请求到Servlet容器</li>
<li>Servlet容器生成HttpServletRequest和HttpServletResponse</li>
<li>Servlet将HttpServletRequest和HttpServletResponse参数传递给Filter,Filter处理过滤请求</li>
<li>Filter将HttpServletRequest和HttpServletResponse传递给Servlet,Servlet处理请求</li>
<li>Servlet处理完请求后,将数据返回给Filter,Filter返回给Servlet容器,Servlet容器再返回给浏览器</li>
</ol>
]]></content>
      <categories>
        <category>😤源码</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch学习总结</title>
    <url>/2019/03/11/elasticsearch/</url>
    <content><![CDATA[<h3 id="ElasticSearch-基本概念"><a href="#ElasticSearch-基本概念" class="headerlink" title="ElasticSearch 基本概念"></a>ElasticSearch 基本概念</h3><h4 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h4><p>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是有一个名字标识。</p>
<h4 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h4><p>一个索引就是一个拥有几个相似特征的文档集合。索引由一个名字来标识（必须全部小写字母）。</p>
<h4 id="类型（type）"><a href="#类型（type）" class="headerlink" title="类型（type）"></a>类型（type）</h4><p>在一个索引中你可以定义一种或多种类型。一个类型是你逻辑上的分类/分区。</p>
<h4 id="文档（document）"><a href="#文档（document）" class="headerlink" title="文档（document）"></a>文档（document）</h4><p>一个文档是可被索引的基本信息单元，文档以JSON格式来表示。</p>
<a id="more"></a>
<h4 id="分片和复制（shards-amp-replicas）"><a href="#分片和复制（shards-amp-replicas）" class="headerlink" title="分片和复制（shards &amp; replicas）"></a>分片和复制（shards &amp; replicas）</h4><p>一个索引可以存储超过单个节点硬件限制的大量数据。ElasticSearch提供了将索引划分成多份的能力<br>，这些份就叫做分片。当创建一个索引的时候，可以指定分片的数量。每个分片本身也是一个功能完善，并且独立的索引，这个索引可以被放置到集群中的任何节点上。</p>
<p>分片之所以重要，主要有以下两点：（1）允许水平分割/扩展内容容量（2）允许在分片之上进行分布式的并行的操作，进而提高性能、吞吐量。</p>
<p>在一个网络环境里失败随时可能发生，在某个分片或者节点不知道怎么就处于离线状态，或者任何原因消失了，这种情况下有一种故障转移机制是非常有用并且强烈推荐的。因此，EleasticSearch可以创建一份或者多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
<p>复制之所以重要，主要有以下两点：</p>
<ol>
<li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原始分片置于同一节点上是非常重要的</li>
<li>扩展了搜索量/吞吐量，因为搜索可以在所有的复制上并行。</li>
</ol>
<h3 id="ElasticSearch-常用curl"><a href="#ElasticSearch-常用curl" class="headerlink" title="ElasticSearch 常用curl"></a>ElasticSearch 常用curl</h3><h5 id="增加索引mapping新字段"><a href="#增加索引mapping新字段" class="headerlink" title="增加索引mapping新字段"></a>增加索引mapping新字段</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPUT http:<span class="comment">//127.0.0.1:9201/job_index_v6/_mapping/b2b -d '&#123;"properties":&#123;"new_field_name":&#123;"type":"string"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="查看集群是否健康"><a href="#查看集群是否健康" class="headerlink" title="查看集群是否健康"></a>查看集群是否健康</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/health?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="列出所有索引"><a href="#列出所有索引" class="headerlink" title="列出所有索引"></a>列出所有索引</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/indices?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="获取集群的节点列表"><a href="#获取集群的节点列表" class="headerlink" title="获取集群的节点列表"></a>获取集群的节点列表</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201/_cat/nodes?v'</span></span><br></pre></td></tr></table></figure>
<h5 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X DELETE <span class="number">127.0</span>.0.1:<span class="number">9201</span>/agent_job_index</span><br></pre></td></tr></table></figure>
<h5 id="给索引设置别名"><a href="#给索引设置别名" class="headerlink" title="给索引设置别名"></a>给索引设置别名</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="number">127.0</span>.0.1:<span class="number">9201</span>/job_index_v6/_alias/job_index</span><br></pre></td></tr></table></figure>
<h5 id="查看指定索引的mapping"><a href="#查看指定索引的mapping" class="headerlink" title="查看指定索引的mapping"></a>查看指定索引的mapping</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">"http://127.0.0.1:9201/job_index_v6/_mapping?pretty"</span></span><br></pre></td></tr></table></figure>
<h5 id="清除指定索引-数据"><a href="#清除指定索引-数据" class="headerlink" title="清除指定索引 数据"></a>清除指定索引 数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;"query":&#123;"match_all":&#123;&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="根据查询删除"><a href="#根据查询删除" class="headerlink" title="根据查询删除"></a>根据查询删除</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'127.0.0.1:9201/job_index_v6/job/_delete_by_query?refresh&amp;slices=5&amp;pretty'</span> -H <span class="string">'Content-Type: application/json'</span> -d <span class="string">'&#123;"query":&#123;"term":&#123;"userId":"1017"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"term":&#123;"indexStatus":"1"&#125;&#125;&#125;' | python -m json.tool</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST http:<span class="comment">//127.0.0.1:9200/job_index_v6/job/_search -d '&#123;"query":&#123;"bool":&#123;"filter":[&#123;"match":&#123;"is2CJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"isAgentJob":&#123;"query":true&#125;&#125;&#125;,&#123;"match":&#123;"switchStatus":&#123;"query":2&#125;&#125;&#125;]&#125;&#125;&#125;' | python -m json.tool</span></span><br></pre></td></tr></table></figure>
<h5 id="搜索最大值"><a href="#搜索最大值" class="headerlink" title="搜索最大值"></a>搜索最大值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPUT http:<span class="comment">//127.0.0.1:9200/job_index_v6/_settings -d '&#123; "index" : &#123; "max_result_window" : 20000&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -POST <span class="number">127.0</span>.0.1:<span class="number">9201</span>/job_index_v6/job/_update_by_query -d <span class="string">'&#123;"script":&#123;"lang":"painless","inline":"if (ctx._source.is2CJob == null) &#123;ctx._source.is2CJob= '</span><span class="keyword">true</span><span class="string">'&#125;"&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<h5 id="添加一条数据"><a href="#添加一条数据" class="headerlink" title="添加一条数据"></a>添加一条数据</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9201/job_index_v6/job/22c3cade5f5a4f189f6145cb0b15b737?pretty'</span> -d<span class="string">'&#123;"id":"22c3cade5f5a4f189f6145cb0b15b737","sourceId":"22c3cade5f5a4f189f6145cb0b15b737","label":0,"userId":"8a1026775d16fbb2015d17a4771a0348","name":"1231231","operatorName":null,"refuseReason":null,"description":"2","workAddress":"韩国","countryId":[513114,513100,510000],"countryNames":["韩国"],"salary":3000,"salaryHigh":4000,"listPrice":2222,"channelPrice":0,"status":2,"indexStatus":2,"is2CJob":true,"deposit":500,"modifyTime":1546593027000,"createTime":1546593027000,"refreshTime":1546593027000,"companyId":"8a1026775981103b01598110cee70004","heat":0,"praise":0,"applyment":0,"comment":0,"browseNumber":0,"postName":["建筑","电工"],"post":[111200,110000,111220],"tagName":[],"tag":[],"systemTag":[],"allTag":[2215],"businessLine":237,"score":63393027,"newOldFlag":1,"switchStatus":0,"agentQuantity":0,"company.name":"北京走出趣科技发展有限公司","company.shortName":"走出趣","company.tag":[2215],"company.location":[110000,110100,110108],"company.status":1&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="查看-索引-设置"><a href="#查看-索引-设置" class="headerlink" title="查看 索引 设置"></a>查看 索引 设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">"http://zcq-product2:9200/job_index_v6/_settings?pretty"</span></span><br></pre></td></tr></table></figure>
<h4 id="查看ElasticSearch状态"><a href="#查看ElasticSearch状态" class="headerlink" title="查看ElasticSearch状态"></a>查看ElasticSearch状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl <span class="string">'localhost:9201'</span> | python -m json.tool</span><br></pre></td></tr></table></figure>
<h5 id="按照排序搜索"><a href="#按照排序搜索" class="headerlink" title="按照排序搜索"></a>按照排序搜索</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -POST http:<span class="comment">//test2.51zouchuqu.com:9201/job_rcmd_score_index/score/_search -d '&#123;"from":0,"size":1000,"query":&#123;"bool":&#123;"disable_coord":false,"adjust_pure_negative":true,"boost":1&#125;&#125;,"explain":false,"sort":[&#123;"score":&#123;"order":"desc"&#125;&#125;]&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="ElasticSearch-备份、导入、导出"><a href="#ElasticSearch-备份、导入、导出" class="headerlink" title="ElasticSearch 备份、导入、导出"></a>ElasticSearch 备份、导入、导出</h3><h4 id="es-数据导入导出"><a href="#es-数据导入导出" class="headerlink" title="es 数据导入导出"></a>es 数据导入导出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install elasticdump</span><br><span class="line">./bin/elasticdump</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index-&gt;index:</span><br><span class="line">elasticdump --input=http:<span class="comment">//localhost:9200/test --output=http://localhost:9200/test</span></span><br><span class="line">index-&gt;file:</span><br><span class="line">elasticdump --input=http:<span class="comment">//localhost:9200/test --output=./json.log</span></span><br><span class="line">file-&gt;index:</span><br><span class="line">elasticdump --input=./json.log --output=http:<span class="comment">//localhost:9200/test</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😏中间件</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令速查笔记</title>
    <url>/2019/02/25/linux/</url>
    <content><![CDATA[<h3 id="cd-进入指定目录"><a href="#cd-进入指定目录" class="headerlink" title="cd  进入指定目录"></a>cd  进入指定目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd dir          <span class="comment">// 进入当前目录的子目录</span></span><br><span class="line">cd ..           <span class="comment">// 进入当前目录的上一级目录</span></span><br><span class="line">cd /            <span class="comment">// 进入系统根目录</span></span><br><span class="line">cd ~            <span class="comment">// 进入当前用户主目录</span></span><br><span class="line">cd /usr/local   <span class="comment">// 进入特定目录</span></span><br></pre></td></tr></table></figure>
<h3 id="ls-列出当前目录文件"><a href="#ls-列出当前目录文件" class="headerlink" title="ls 列出当前目录文件"></a>ls 列出当前目录文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ls -a   <span class="comment">// 列出当前目录所有文件，包含隐藏文件</span></span><br><span class="line">ls -l   <span class="comment">// 列出长数据串，包含文件的权限和属性 相当于 ll</span></span><br><span class="line">ls -i   <span class="comment">// 显示文件节点索引号</span></span><br><span class="line">ls -t   <span class="comment">// 按照修改时间，降序显示</span></span><br><span class="line">ls -rt  <span class="comment">// 按照修改时间，升序显示</span></span><br><span class="line">ls -alht  <span class="comment">// 按照修改时间，降序显示 h显示文件大小</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">个人感觉 ll -h 比较好用</font>

<h3 id="mv-修改文件名字或移动位置"><a href="#mv-修改文件名字或移动位置" class="headerlink" title="mv  修改文件名字或移动位置"></a>mv  修改文件名字或移动位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mv file newname         <span class="comment">// 更改文件名字</span></span><br><span class="line">mv /dir/file /otherdir  <span class="comment">// 移动文件位置</span></span><br></pre></td></tr></table></figure>
<h3 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a>rm 删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rm -rf dir  <span class="comment">// 递归删除指定目录中的所有文件</span></span><br><span class="line">rm file     <span class="comment">// 删除指定文件</span></span><br><span class="line">rm -rf *    <span class="comment">// 递归删除当前目录中的所有文件</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="cp-复制"><a href="#cp-复制" class="headerlink" title="cp 复制"></a>cp 复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cp -r /dir /other-dir    <span class="comment">// 将dir目录下所有文件，移动到other-dir目录中</span></span><br><span class="line">cp fileA fileB           <span class="comment">// 备份A文件，并改名</span></span><br></pre></td></tr></table></figure>
<h3 id="kill-杀进程"><a href="#kill-杀进程" class="headerlink" title="kill 杀进程"></a>kill 杀进程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kill -<span class="number">9</span>  PID   <span class="comment">// 将PID进程结束</span></span><br><span class="line">kill -<span class="number">17</span> PID   <span class="comment">// 将PID进程暂停</span></span><br></pre></td></tr></table></figure>
<h3 id="chown-修改文件所属用户或用户组"><a href="#chown-修改文件所属用户或用户组" class="headerlink" title="chown 修改文件所属用户或用户组"></a>chown 修改文件所属用户或用户组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chown -R root:root /tmp    <span class="comment">// 修改 tmp 目录所属用户为 root，用户组为 root</span></span><br><span class="line">chown iisheng file  <span class="comment">// 将file的所有者设置为iisheng</span></span><br></pre></td></tr></table></figure>
<h3 id="chmod-给文件设置别人访问权限"><a href="#chmod-给文件设置别人访问权限" class="headerlink" title="chmod 给文件设置别人访问权限"></a>chmod 给文件设置别人访问权限</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">766</span> file <span class="comment">// 给某个文件别人访问权限</span></span><br><span class="line">chmod <span class="number">777</span> * <span class="comment">// 当前文件夹所有文件所有用户都可以读写</span></span><br></pre></td></tr></table></figure>
<h3 id="cat-查看文件或写到指定文件内容"><a href="#cat-查看文件或写到指定文件内容" class="headerlink" title="cat  查看文件或写到指定文件内容"></a>cat  查看文件或写到指定文件内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat file                                  <span class="comment">// 显示整个文件内容</span></span><br><span class="line">cat -n file                               <span class="comment">// 显示整个文件内容，并由1开始对行数编号</span></span><br><span class="line">cat file &gt; newFile                        <span class="comment">// 将文件的内容写到新文件里面</span></span><br><span class="line">cat file | head -n <span class="number">3000</span> | tail -n +<span class="number">1000</span>   <span class="comment">// 查看文件的1000-3000行</span></span><br><span class="line">cat /proc/PID/status                      <span class="comment">// 查看指定进程的相关信息</span></span><br></pre></td></tr></table></figure>
<h3 id="scp-终端远程下载上传文件"><a href="#scp-终端远程下载上传文件" class="headerlink" title="scp 终端远程下载上传文件"></a>scp 终端远程下载上传文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scp  root<span class="meta">@iisheng</span>.cn:/path/filename ./                              <span class="comment">// 文件下载到本地当前目录</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  /home/jdk.tar.gz   root<span class="meta">@iisheng</span>.cn:/root/jdk.tar.gz  <span class="comment">// 上传文件</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  -r /home/jdk/ root<span class="meta">@isheng</span>.me                        <span class="comment">// 上传文件目录</span></span><br><span class="line">scp  -P  <span class="number">2222</span>  -r /home/jdk/ root<span class="meta">@isheng</span>.me                        <span class="comment">// 使用IPV6寻址上传文件目录</span></span><br></pre></td></tr></table></figure>
<h3 id="netstat-打印网络信息状态"><a href="#netstat-打印网络信息状态" class="headerlink" title="netstat  打印网络信息状态"></a>netstat  打印网络信息状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netstat -at                <span class="comment">// 列出所有TCP端口</span></span><br><span class="line">netstat -au                <span class="comment">// 列出所有UDP端口</span></span><br><span class="line">netstat -lt                <span class="comment">// 列出所有监听TCP的端口</span></span><br><span class="line">netstat -lu                <span class="comment">// 列出所有监听UDP的端口</span></span><br><span class="line">netstat -r                 <span class="comment">// 显示核心路由信息</span></span><br><span class="line">netstat -anl | grep <span class="number">8888</span>   <span class="comment">// 查看相关端口号信息</span></span><br></pre></td></tr></table></figure>
<h3 id="top-实时系统的查看系统运行情况"><a href="#top-实时系统的查看系统运行情况" class="headerlink" title="top  实时系统的查看系统运行情况"></a>top  实时系统的查看系统运行情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top              <span class="comment">// 动态查看系统的整体运行情况</span></span><br><span class="line">top -p PID       <span class="comment">// 查看指定进程的运行情况</span></span><br><span class="line">top -u user      <span class="comment">// 查看指定用户的相关进程的运行情况</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">htop 和top类似功能</font>

<h3 id="sed-处理文件并在控制台打印"><a href="#sed-处理文件并在控制台打印" class="headerlink" title="sed  处理文件并在控制台打印"></a>sed  处理文件并在控制台打印</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/book/books/'</span> file   <span class="comment">// s 替换指定 字符，将book替换为books</span></span><br><span class="line">sed -i <span class="string">'s/book/books/g'</span> file  <span class="comment">// g 替换文本中内容 -i 直接编辑文本选项 匹配文件中第一个book替换为books</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">这个东西很多功能的，暂时不详细学习</font>

<h3 id="less-从头查看日志"><a href="#less-从头查看日志" class="headerlink" title="less 从头查看日志"></a>less 从头查看日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shift+g 跳转到文件底部</span><br><span class="line">按f键,是向前(下)查看  forword</span><br><span class="line">按b键,是向后(上)查看  backword</span><br><span class="line">q  退出</span><br></pre></td></tr></table></figure>
<h3 id="more-从头查看日志"><a href="#more-从头查看日志" class="headerlink" title="more 从头查看日志"></a>more 从头查看日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">more file</span><br><span class="line">按ctrl+f键,是向前(下)查看  forword</span><br><span class="line">按ctrl+b键,是向后(上)查看 backword</span><br></pre></td></tr></table></figure>
<h3 id="tail-动态查看文件尾部内容"><a href="#tail-动态查看文件尾部内容" class="headerlink" title="tail 动态查看文件尾部内容"></a>tail 动态查看文件尾部内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tail -<span class="number">500f</span> file  <span class="comment">// 动态查看文件尾部500行</span></span><br></pre></td></tr></table></figure>
<h3 id="head-显示文件开头内容"><a href="#head-显示文件开头内容" class="headerlink" title="head 显示文件开头内容"></a>head 显示文件开头内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">head -<span class="number">100f</span> file  <span class="comment">// 查看文件前100行</span></span><br></pre></td></tr></table></figure>
<h3 id="rar-解压rar文件或压缩为rar文件"><a href="#rar-解压rar文件或压缩为rar文件" class="headerlink" title="rar 解压rar文件或压缩为rar文件"></a>rar 解压rar文件或压缩为rar文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rar x -ep2 filename    <span class="comment">// 将Windows rar文件 解压 utf-8编码的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="unzip-解压zip文件或压缩为zip文件"><a href="#unzip-解压zip文件或压缩为zip文件" class="headerlink" title="unzip 解压zip文件或压缩为zip文件"></a>unzip 解压zip文件或压缩为zip文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unzip -d fileDir file.zip   <span class="comment">// zip 文件 解压</span></span><br><span class="line">unzip fileName <span class="comment">// 文件解压缩到当前目录</span></span><br><span class="line">unzip -O cp936 file.zip <span class="comment">//将Windows文件以utf-8编码解压缩</span></span><br></pre></td></tr></table></figure>
<h3 id="service-启动查看进程状态"><a href="#service-启动查看进程状态" class="headerlink" title="service 启动查看进程状态"></a>service 启动查看进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service sshd status        <span class="comment">// 查看sshd的运行状态</span></span><br><span class="line">service sshd start        <span class="comment">// 启动服务</span></span><br></pre></td></tr></table></figure>
<h3 id="systemctl-启动查看进程状态"><a href="#systemctl-启动查看进程状态" class="headerlink" title="systemctl 启动查看进程状态"></a>systemctl 启动查看进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl status httpd.service <span class="comment">// 查看httpd服务状态</span></span><br><span class="line">systemctl enable httpd.service <span class="comment">// 启动服务</span></span><br></pre></td></tr></table></figure>
<h3 id="安装、卸载软件"><a href="#安装、卸载软件" class="headerlink" title="安装、卸载软件"></a>安装、卸载软件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo agt-get install git  <span class="comment">// 安装git</span></span><br><span class="line">sudo apt-get --purge remove git  <span class="comment">// 卸载git</span></span><br></pre></td></tr></table></figure>
<h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i *.deb    <span class="comment">// 安装.deb文件的软件</span></span><br><span class="line">sudo dpkg -P *.deb    <span class="comment">// 卸载.deb文件的软件</span></span><br></pre></td></tr></table></figure>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shutdown -h now    <span class="comment">// 关机</span></span><br><span class="line">shutdown -r now    <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">df -lh   <span class="comment">// 查看系统硬盘使用情况</span></span><br></pre></td></tr></table></figure>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">du -sh     <span class="comment">// 查看文件目录大小</span></span><br><span class="line">du -ah     <span class="comment">// 查看文件目录下面各个文件大小</span></span><br><span class="line">du -h --max-depth=<span class="number">1</span> ./  <span class="comment">// 查看当前目录大小</span></span><br></pre></td></tr></table></figure>
<h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.c"</span> | xargs grep -H <span class="string">"intern("</span>  <span class="comment">// 查找当前目录指定文件后缀包含指定字符的结果</span></span><br><span class="line">find /home -name <span class="string">'*.md'</span> <span class="comment">// 查找指定目录包含指定字符串 的文件名路径</span></span><br></pre></td></tr></table></figure>
<h3 id="grep-全面搜索正则表达式并把行打印出来"><a href="#grep-全面搜索正则表达式并把行打印出来" class="headerlink" title="grep 全面搜索正则表达式并把行打印出来"></a>grep 全面搜索正则表达式并把行打印出来</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grep -rn <span class="string">"hello,world!"</span> *  <span class="comment">// 在当前目录查找 hello,world 字符串</span></span><br><span class="line">grep <span class="string">'model name'</span> /proc/cpuinfo | wc -l  <span class="comment">// 查看系统有几个CPU</span></span><br></pre></td></tr></table></figure>
<font color="red" size="3" face="“Consolas”">一般配合别的命令一起使用效果很强大</font>

<h3 id="ps-显示当前进程状态"><a href="#ps-显示当前进程状态" class="headerlink" title="ps  显示当前进程状态"></a>ps  显示当前进程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx     <span class="comment">// 根据名字查找进程</span></span><br><span class="line">ps -ef | grep elastic   <span class="comment">// 根据名字查找进程</span></span><br></pre></td></tr></table></figure>
<h3 id="lsof-查看进程打开的端口，查看打开文件的进程"><a href="#lsof-查看进程打开的端口，查看打开文件的进程" class="headerlink" title="lsof  查看进程打开的端口，查看打开文件的进程"></a>lsof  查看进程打开的端口，查看打开文件的进程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lsof -i:<span class="number">8888</span>      <span class="comment">// 根据端口号查看相关进程信息</span></span><br></pre></td></tr></table></figure>
<h3 id="iconv-转换文件编码"><a href="#iconv-转换文件编码" class="headerlink" title="iconv  转换文件编码"></a>iconv  转换文件编码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconv -f gb2312 file -o newFile  <span class="comment">// 将Windows文件转换为Linux识别的文件</span></span><br><span class="line">iconv -f gbk -t utf8 file &gt; bewFile  <span class="comment">// 将Windows文件转换为Linux识别的文件</span></span><br></pre></td></tr></table></figure>
<h3 id="curl-文本传输工具"><a href="#curl-文本传输工具" class="headerlink" title="curl 文本传输工具"></a>curl 文本传输工具</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> https:<span class="comment">//api.github.com -s | python -m json.tool  // GET请求</span></span><br><span class="line">curl -X PUT <span class="number">127.0</span>.0.1:<span class="number">9200</span>/job_index/_mapping/job -d <span class="string">'&#123;"properties":&#123;"new_field":&#123;"type":"integer"&#125;&#125;&#125;'</span>  <span class="comment">// PUT请求</span></span><br><span class="line">curl -X DELETE <span class="number">127.0</span>.0.1:<span class="number">9200</span>/agent_job_index  <span class="comment">// DELETE请求</span></span><br><span class="line">curl -X POST <span class="number">127.0</span>.0.1:<span class="number">9200</span>/job_index/job/_search -d <span class="string">'&#123;"query":&#123;"term":&#123;"id":"1"&#125;&#125;&#125;'</span> <span class="comment">// POST请求</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>😳工具</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
</search>
